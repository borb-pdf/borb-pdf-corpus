                                                                                                                                                                 1
                           The Design and Implementation of FFTW3
                                                                 Matteo Frigo and Steven G. Johnson
                                                                               (Invited Paper)
                 Abstract—FFTW is an implementation of the discrete Fourier                     of a multi-dimensional array. (Most implementations sup-
               transform (DFT) that adapts to the hardware in order to                          port only a single DFT of contiguous data.)
               maximize performance. This paper shows that such an approach                  • FFTW supports DFTs of real data, as well as of real
               can yield an implementation that is competitive with hand-                       symmetric/antisymmetric data (also called discrete co-
               optimized libraries, and describes the software structure that                   sine/sine transforms).
               makes our current FFTW3 version ﬂexible and adaptive. We
               further discuss a new algorithm for real-data DFTs of prime size,             The interaction of the user with FFTW occurs in two
               a new way of implementing DFTs by means of machine-speciﬁc                 stages: planning, in which FFTW adapts to the hardware,
               “SIMD” instructions, and how a special-purpose compiler can                and execution, in which FFTW performs useful work for the
               derive optimized implementations of the discrete cosine and sine           user. To compute a DFT, the user ﬁrst invokes the FFTW
               transforms automatically from a DFT algorithm.                             planner, specifying the problem to be solved. The problem is
                 Index Terms—FFT, adaptive software, Fourier transform,                   a data structure that describes the “shape” of the input data—
               cosine transform, Hartley transform, I/O tensor.                           array sizes and memory layouts—but does not contain the data
                                                                                          itself. In return, the planner yields a plan, an executable data
                                       I. INTRODUCTION                                    structure that accepts the input data and computes the desired
                    FTW [1] is a widely used free-software library that                   DFT. Afterwards, the user can execute the plan as many times
               Fcomputes the discrete Fourier transform (DFT) and its                     as desired.
               various special cases. Its performance is competitive even with               The FFTW planner works by measuring the actual run time
               vendor-optimized programs, but unlike these programs, FFTW                 of many different plans and by selecting the fastest one. This
               is not tuned to a ﬁxed machine. Instead, FFTW uses a planner               process is analogous to what a programmer would do by hand
               to adapt its algorithms to the hardware in order to maximize               whentuningaprogramtoaﬁxedmachine,butinFFTW’scase
               performance. The input to the planner is a problem, a multi-               no manual intervention is required. Because of the repeated
               dimensional loop of multi-dimensional DFTs. The planner                    performance measurements, however, the planner tends to be
               applies a set of rules to recursively decompose a problem into             time-consuming. In performance-critical applications, many
               simpler sub-problems of the same type. “Sufﬁciently simple”                transforms of the same size are typically required, and there-
               problems are solved directly by optimized, straight-line code              fore a large one-time cost is usually acceptable. Otherwise,
               that is automatically generated by a special-purpose compiler.             FFTWprovidesamodeofoperationwheretheplannerquickly
               This paper describes the overall structure of FFTW as well as              returns a “reasonable” plan that is not necessarily the fastest.
               the speciﬁc improvements in FFTW3, our latest version.                        The planner generates plans according to rules that recur-
                 FFTWisfast, but its speed does not come at the expense of                sively decompose a problem into simpler sub-problems. When
               ﬂexibility. In fact, FFTW is probably the most ﬂexible DFT                 the problem becomes “sufﬁciently simple,” FFTW produces
               library available:                                                         a plan that calls a fragment of optimized straight-line code
                 • FFTW is written in portable C and runs well on many                    that solves the problem directly. These fragments are called
                    architectures and operating systems.                                  codelets in FFTW’s lingo. You can envision a codelet as
                 • FFTW computes DFTs in O(nlogn) time for any                            computing a “small” DFT, but many variations and special
                    length n. (Most other DFT implementations are either                  cases exist. For example, a codelet might be specialized to
                                                                                          compute the DFT of real input (as opposed to complex).
                    restricted to a subset of sizes or they become Θ(n2) for              FFTW’s speed depends therefore on two factors. First, the
                    certain values of n, for example when n is prime.)                    decomposition rules must produce a space of plans that is rich
                 • FFTW imposes no restrictions on the rank (dimension-                   enough to contain “good” plans for most machines. Second,
                    ality) of multi-dimensional transforms. (Most other im-               the codelets must be fast, since they ultimately perform all the
                    plementations are limited to one-dimensional, or at most              real work.
                    two- and three-dimensional data.)                                        FFTW’s codelets are generated automatically by a special-
                 • FFTW supports multiple and/or strided DFTs; for exam-                  purpose compiler called genfft. Most users do not interact
                    ple, to transform a 3-component vector ﬁeld or a portion              with genfft at all: the standard FFTW distribution contains
                 M. Frigo is with the IBM Austin Research Laboratory, 11501 Burnet        a set of about 150 pre-generated codelets that cover the most
               Road, Austin, TX 78758. He was supported in part by the Defense Advanced   common uses. Users with special needs can use genfft
               Research Projects Agency (DARPA) under contract No. NBCH30390004.          to generate their own codelets. genfft is useful because
                 S. G. Johnson is with the Massachusetts Institute of Technology, 77      of the following features. From a high-level mathematical
               Mass. Ave. Rm. 2-388, Cambridge, MA 02139. He was supported in part        description of a DFT algorithm, genfft derives an optimized
               by the Materials Research Science and Engineering Center program of the
               National Science Foundation under award DMR-9400334.                       implementation automatically. From a complex-DFT algo-
