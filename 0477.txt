                    ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER
                                                  BYZANTIUM VERSION dbc2f9b - 2019-03-28
                                                                   DR. GAVIN WOOD
                                                            FOUNDER, ETHEREUM&PARITY
                                                                   GAVIN@PARITY.IO
                        Abstract. The blockchain paradigm when coupled with cryptographically-secured transactions has demonstrated its
                        utility through a number of projects, with Bitcoin being one of the most notable ones. Each such project can be seen as
                        a simple application on a decentralised, but singleton, compute resource. We can call this paradigm a transactional
                        singleton machine with shared-state.
                           Ethereum implements this paradigm in a generalised manner. Furthermore it provides a plurality of such resources,
                        each with a distinct state and operating code but able to interact through a message-passing framework with others.
                        Wediscuss its design, implementation issues, the opportunities it provides and the future hurdles we envisage.
                                   1. Introduction                             is often lacking, and plain old prejudices are diﬃcult to
                  With ubiquitous internet connections in most places          shake.
               of the world, global information transmission has become           Overall, we wish to provide a system such that users
               incredibly cheap. Technology-rooted movements like Bit-         can be guaranteed that no matter with which other indi-
               coin have demonstrated through the power of the default,        viduals, systems or organisations they interact, they can
               consensus mechanisms, and voluntary respect of the social       do so with absolute conﬁdence in the possible outcomes
               contract, that it is possible to use the internet to make       and how those outcomes might come about.
               a decentralised value-transfer system that can be shared        1.2. Previous Work. Buterin [2013a] ﬁrst proposed the
               across the world and virtually free to use. This system can     kernel of this work in late November, 2013. Though now
               be said to be a very specialised version of a cryptographi-     evolved in many ways, the key functionality of a block-
               cally secure, transaction-based state machine. Follow-up        chain with a Turing-complete language and an eﬀectively
               systems such as Namecoin adapted this original “currency        unlimited inter-transaction storage capability remains un-
               application” of the technology into other applications albeit   changed.
               rather simplistic ones.                                            Dwork and Naor [1992] provided the ﬁrst work into the
                  Ethereum is a project which attempts to build the gen-       usage of a cryptographic proof of computational expendi-
               eralised technology; technology on which all transaction-       ture (“proof-of-work”) as a means of transmitting a value
               based state machine concepts may be built. Moreover it          signal over the Internet. The value-signal was utilised here
               aims to provide to the end-developer a tightly integrated       as a spam deterrence mechanism rather than any kind
               end-to-end system for building software on a hitherto un-       of currency, but critically demonstrated the potential for
               explored compute paradigm in the mainstream: a trustful         a basic data channel to carry a strong economic signal,
               object messaging compute framework.                             allowing a receiver to make a physical assertion without
                                                                               having to rely upon trust. Back [2002] later produced a
                                                                               system in a similar vein.
               1.1. Driving Factors. There are many goals of this                 The ﬁrst example of utilising the proof-of-work as a
               project; one key goal is to facilitate transactions between     strong economic signal to secure a currency was by Vish-
               consenting individuals who would otherwise have no means        numurthy et al. [2003]. In this instance, the token was
               to trust one another. This may be due to geographical           used to keep peer-to-peer ﬁle trading in check, providing
               separation, interfacing diﬃculty, or perhaps the incompati-    “consumers” with the ability to make micro-payments to
               bility, incompetence, unwillingness, expense, uncertainty,     “suppliers” for their services. The security model aﬀorded
               inconvenience, or corruption of existing legal systems. By      bytheproof-of-work was augmented with digital signatures
               specifying a state-change system through a rich and unam-       and a ledger in order to ensure that the historical record
               biguous language, and furthermore architecting a system         couldn’t be corrupted and that malicious actors could not
               such that we can reasonably expect that an agreement will       spoof payment or unjustly complain about service deliv-
               be thus enforced autonomously, we can provide a means           ery. Five years later, Nakamoto [2008] introduced another
               to this end.                                                    such proof-of-work-secured value token, somewhat wider in
                  Dealings in this proposed system would have several          scope. The fruits of this project, Bitcoin, became the ﬁrst
               attributes not often found in the real world. The incorrupt-    widely adopted global decentralised transaction ledger.
               ibility of judgement, often diﬃcult to ﬁnd, comes naturally        Other projects built on Bitcoin’s success; the alt-coins
               from a disinterested algorithmic interpreter. Transparency,     introduced numerous other currencies through alteration
               or being able to see exactly how a state or judgement came      to the protocol. Some of the best known are Litecoin and
               aboutthroughthetransactionlogandrulesorinstructional            Primecoin, discussed by Sprankel [2013]. Other projects
               codes, never happens perfectly in human-based systems           sought to take the core value content mechanism of the pro-
               since natural language is necessarily vague, information        tocol and repurpose it; Aron [2012] discusses, for example,
                                                                            1
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 2
               the Namecoin project which aims to provide a decentralised     itself—that would be far too big). They also punctuate the
               name-resolution system.                                        transaction series with incentives for nodes to mine. This
                  Other projects still aim to build upon the Bitcoin net-     incentivisation takes place as a state-transition function,
               work itself, leveraging the large amount of value placed in    adding value to a nominated account.
               the system and the vast amount of computation that goes           Mining is the process of dedicating eﬀort (working) to
               into the consensus mechanism. The Mastercoin project,          bolster one series of transactions (a block) over any other
               ﬁrst proposed by Willett [2013], aims to build a richer        potential competitor block. It is achieved thanks to a
               protocol involving many additional high-level features on      cryptographically secure proof. This scheme is known as a
               top of the Bitcoin protocol through utilisation of a number    proof-of-work and is discussed in detail in section 11.5.
               of auxiliary parts to the core protocol. The Coloured Coins       Formally, we expand to:
               project, proposed by Rosenfeld et al. [2012], takes a similar  (2)          σ      ≡ Π(σ ,B)
               but more simpliﬁed strategy, embellishing the rules of a                      t+1           t
                                                                              (3)             B ≡ (...,(T ,T ,...),...)
               transaction in order to break the fungibility of Bitcoin’s                                    0  1
               base currency and allow the creation and tracking of tokens    (4)       Π(σ,B) ≡ Ω(B,Υ(Υ(σ,T0),T1)...)
               through a special “chroma-wallet”-protocol-aware piece of         Where Ω is the block-ﬁnalisation state transition func-
               software.                                                      tion (a function that rewards a nominated party); B is this
                  Additional work has been done in the area with discard-     block, which includes a series of transactions amongst some
               ing the decentralisation foundation; Ripple, discussed by      other components; and Π is the block-level state-transition
               Boutellier and Heinzen [2014], has sought to create a “fed-    function.
               erated” system for currency exchange, eﬀectively creating         This is the basis of the blockchain paradigm, a model
               a new ﬁnancial clearing system. It has demonstrated that       that forms the backbone of not only Ethereum, but all
               high eﬃciency gains can be made if the decentralisation        decentralised consensus-based transaction systems to date.
               premise is discarded.
                  Early work on smart contracts has been done by Szabo        2.1. Value. In order to incentivise computation within the
               [1997] and Miller [1997]. Around the 1990s it became clear     network, there needs to be an agreed method for transmit-
               that algorithmic enforcement of agreements could become a      ting value. To address this issue, Ethereum has an intrinsic
               signiﬁcant force in human cooperation. Though no speciﬁc       currency, Ether, known also as ETH and sometimes referred
               system was proposed to implement such a system, it was         to by the Old English D. The smallest subdenomination
                                                                                                     ¯
               proposed that the future of law would be heavily aﬀected       of Ether, and thus the one in which all integer values of
               by such systems. In this light, Ethereum may be seen as a      the currency are counted, is the Wei. One Ether is deﬁned
                                                                                         18
               general implementation of such a crypto-law system.            as being 10   Wei. There exist other subdenominations of
                  For a list of terms used in this paper, refer to Appendix   Ether:
               A.                                                                                Multiplier   Name
                                                                                                          0
                           2. The Blockchain Paradigm                                                   10    Wei
                                                                                                          12
                                                                                                       10     Szabo
                  Ethereum, taken as a whole, can be viewed as a                                          15
                                                                                                       10     Finney
               transaction-based state machine: we begin with a gen-                                      18
                                                                                                       10     Ether
               esis state and incrementally execute transactions to morph        Throughout the present work, any reference to value,
               it into some ﬁnal state. It is this ﬁnal state which we        in the context of Ether, currency, a balance or a payment,
               accept as the canonical “version” of the world of Ethereum.    should be assumed to be counted in Wei.
               The state can include such information as account bal-
               ances, reputations, trust arrangements, data pertaining        2.2. Which History? Since the system is decentralised
               to information of the physical world; in short, anything       and all parties have an opportunity to create a new block
               that can currently be represented by a computer is admis-      on some older pre-existing block, the resultant structure is
               sible. Transactions thus represent a valid arc between two     necessarily a tree of blocks. In order to form a consensus
               states; the ‘valid’ part is important—there exist far more     as to which path, from root (the genesis block) to leaf (the
               invalid state changes than valid state changes. Invalid state  block containing the most recent transactions) through
               changes might, e.g., be things such as reducing an account     this tree structure, known as the blockchain, there must
               balance without an equal and opposite increase elsewhere.      be an agreed-upon scheme. If there is ever a disagreement
               Avalid state transition is one which comes about through       between nodes as to which root-to-leaf path down the block
               a transaction. Formally:                                       tree is the ‘best’ blockchain, then a fork occurs.
               (1)                  σ    ≡Υ(σ ,T)                                This would mean that past a given point in time (block),
                                     t+1        t                             multiple states of the system may coexist: some nodes be-
                  where Υ is the Ethereum state transition function. In       lieving one block to contain the canonical transactions,
               Ethereum, Υ, together with σ are considerably more pow-        other nodes believing some other block to be canonical,
               erful than any existing comparable system; Υ allows com-       potentially containing radically diﬀerent or incompatible
               ponents to carry out arbitrary computation, while σ allows     transactions. This is to be avoided at all costs as the un-
               components to store arbitrary state between transactions.      certainty that would ensue would likely kill all conﬁdence
                  Transactions are collated into blocks; blocks are chained   in the entire system.
               together using a cryptographic hash as a means of refer-          The scheme we use in order to generate consensus is a
               ence. Blocks function as a journal, recording a series of      simpliﬁed version of the GHOST protocol introduced by
               transactions together with the previous block and an iden-     Sompolinsky and Zohar [2013]. This process is described
               tiﬁer for the ﬁnal state (though do not store the ﬁnal state   in detail in section 10.
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 3
                  Sometimes, a path follows a new protocol from a par-           assume that the unmodiﬁed ‘input’ value be denoted by
               ticular height. This document describes one version of the        the placeholder  then the modiﬁed and utilisable value is
                                                                                              ′                                       ∗    ∗∗
               protocol. In order to follow back the history of a path, one      denoted as  , and intermediate values would be  , 
               must reference multiple versions of this document.                &c. On very particular occasions, in order to maximise
                                                                                 readability and only if unambiguous in meaning, we may
                                    3. Conventions                               use alpha-numeric subscripts to denote intermediate values,
                  Weuse a number of typographical conventions for the            especially those of particular note.
               formal notation, some of which are quite particular to the           When considering the use of existing functions, given a
               present work:                                                     function f, the function f∗ denotes a similar, element-wise
                  The two sets of highly structured, ‘top-level’, state val-     version of the function mapping instead between sequences.
               ues, are denoted with bold lowercase Greek letters. They          It is formally deﬁned in section 4.3.
               fall into those of world-state, which are denoted σ (or a            Wedeﬁneanumberofusefulfunctionsthroughout. One
               variant thereupon) and those of machine-state, µ.                 of the more common is ℓ, which evaluates to the last item
                  Functions operating on highly structured values are            in the given sequence:
               denoted with an upper-case Greek letter, e.g. Υ, the
               Ethereum state transition function.                               (5)                  ℓ(x) ≡ x[kxk−1]
                  For most functions, an uppercase letter is used, e.g. C,
               the general cost function. These may be subscripted to                     4. Blocks, State and Transactions
               denote specialised variants, e.g. CSSTORE, the cost func-            Having introduced the basic concepts behind Ethereum,
               tion for the SSTORE operation. For specialised and possibly       we will discuss the meaning of a transaction, a block and
               externally deﬁned functions, we may format as typewriter          the state in more detail.
               text, e.g. the Keccak-256 hash function (as per the winning
               entry to the SHA-3 contest by Bertoni et al. [2017], rather       4.1. World State. The world state (state), is a map-
               than later releases), is denoted KEC (and generally referred      ping between addresses (160-bit identiﬁers) and account
               to as plain Keccak). Also KEC512 is referring to the Keccak       states (a data structure serialised as RLP, see Appendix
               512 hash function.                                                B). Though not stored on the blockchain, it is assumed
                  Tuples are typically denoted with an upper-case letter,        that the implementation will maintain this mapping in a
               e.g. T, is used to denote an Ethereum transaction. This           modiﬁed Merkle Patricia tree (trie, see Appendix D). The
               symbol may, if accordingly deﬁned, be subscripted to refer        trie requires a simple database backend that maintains a
               to an individual component, e.g. Tn, denotes the nonce            mapping of bytearrays to bytearrays; we name this under-
               of said transaction. The form of the subscript is used to         lying database the state database. This has a number of
               denote its type; e.g. uppercase subscripts refer to tuples        beneﬁts; ﬁrstly the root node of this structure is crypto-
               with subscriptable components.                                    graphically dependent on all internal data and as such its
                  Scalars and ﬁxed-size byte sequences (or, synonymously,        hash can be used as a secure identity for the entire system
               arrays) are denoted with a normal lower-case letter, e.g.         state. Secondly, being an immutable data structure, it
               n is used in the document to denote a transaction nonce.          allows any previous state (whose root hash is known) to
               Those with a particularly special meaning may be Greek,           be recalled by simply altering the root hash accordingly.
               e.g. δ, the number of items required on the stack for a           Since we store all such root hashes in the blockchain, we
               given operation.                                                  are able to trivially revert to old states.
                  Arbitrary-length sequences are typically denoted as a             The account state, σ[a], comprises the following four
               bold lower-case letter, e.g. o is used to denote the byte         ﬁelds:
               sequence given as the output data of a message call. For               nonce: A scalar value equal to the number of trans-
               particularly important values, a bold uppercase letter may                actions sent from this address or, in the case
               be used.                                                                  of accounts with associated code, the number of
                  Throughout, we assume scalars are non-negative inte-                   contract-creations made by this account. For ac-
               gers and thus belong to the set N. The set of all byte                    count of address a in state σ, this would be for-
               sequences is B, formally deﬁned in Appendix B. If such                    mally denoted σ[a] .
                                                                                                             n
               a set of sequences is restricted to those of a particular              balance: A scalar value equal to the number of Wei
               length, it is denoted with a subscript, thus the set of all               owned by this address. Formally denoted σ[a] .
                                                                                                                                          b
               byte sequences of length 32 is named B        and the set of           storageRoot: A 256-bit hash of the root node of a
                                                          32
               all non-negative integers smaller than 2256 is named N      .             Merkle Patricia tree that encodes the storage con-
                                                                        256
               This is formally deﬁned in section 4.3.                                   tents of the account (a mapping between 256-bit
                  Square brackets are used to index into and reference                   integer values), encoded into the trie as a mapping
               individual components or subsequences of sequences, e.g.                  from the Keccak 256-bit hash of the 256-bit integer
               µs[0] denotes the ﬁrst item on the machine’s stack. For                   keys to the RLP-encoded 256-bit integer values.
               subsequences, ellipses are used to specify the intended                   The hash is formally denoted σ[a] .
                                                                                                                             s
               range, to include elements at both limits, e.g. µ [0..31]              codeHash: The hash of the EVM code of this
                                                                   m
               denotes the ﬁrst 32 items of the machine’s memory.                        account—thisisthecodethatgetsexecutedshould
                  In the case of the global state σ, which is a sequence of              this address receive a message call; it is immutable
               accounts, themselves tuples, the square brackets are used                 and thus, unlike all other ﬁelds, cannot be changed
               to reference an individual account.                                       after construction. All such code fragments are
                  When considering variants of existing values, we follow                contained in the state database under their corre-
               the rule that within a given scope for deﬁnition, if we                   sponding hashes for later retrieval. This hash is
                ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 4
                       formally denoted σ[a]c, and thus the code may be           gasPrice: A scalar value equal to the number of
                       denoted as b, given that KEC(b) = σ[a] .                      Wei to be paid per unit of gas for all computation
                                                              c
                 Since we typically wish to refer not to the trie’s root             costs incurred as a result of the execution of this
                                                                                     transaction; formally T .
               hash but to the underlying set of key/value pairs stored                                     p
              within, we deﬁne a convenient equivalence:                          gasLimit: A scalar value equal to the maximum
                                      ∗                                             amount of gas that should be used in executing
               (6)             TRIE L (σ[a] ) ≡ σ[a]
                                      I     s         s                              this transaction. This is paid up-front, before any
                 The collapse function for the set of key/value pairs in             computation is done and may not be increased
                         ∗                                                           later; formally T .
               the trie, L , is deﬁned as the element-wise transformation                            g
                         I                                                        to: The 160-bit address of the message call’s recipi-
               of the base function LI, given as:                                    ent or, for a contract creation transaction, ∅, used
                                                       
               (7)           LI (k,v) ≡ KEC(k),RLP(v)                                here to denote the only member of B0 ; formally
                                                                                     T .
                 where:                                                               t
                                                                                  value: A scalar value equal to the number of Wei to
               (8)               k ∈ B     ∧ v∈N
                                       32                                            be transferred to the message call’s recipient or,
                 It shall be understood that σ[a] is not a ‘physical’                in the case of contract creation, as an endowment
                                                   s                                 to the newly created account; formally T .
               member of the account and does not contribute to its later                                                    v
               serialisation.                                                     v, r, s: Values corresponding to the signature of the
                 If the codeHash ﬁeld is the Keccak-256 hash of the                  transaction and used to determine the sender of
                                                                                    the transaction; formally T , T and T . This is
               emptystring, i.e. σ[a] = KEC () , then the node represents                                       w   r       s
                                    c                                                expanded in Appendix F.
               a simple account, sometimes referred to as a “non-contract”
               account.                                                        Additionally, a contract creation transaction contains:
                 Thus we may deﬁne a world-state collapse function LS:            init: An unlimited size byte array specifying the
               (9)            L (σ) ≡ {p(a) : σ[a] 6= ∅}                             EVM-codefortheaccount initialisation procedure,
                               S
                                                                                     formally Ti.
              where
                                                                             init is an EVM-code fragment; it returns the body,
               (10)  p(a) ≡ KEC(a),RLP (σ[a] ,σ[a] ,σ[a] ,σ[a] )            a second fragment of code that executes each time the
                                              n      b     s     c
                 This function, L , is used alongside the trie function     account receives a message call (either through a trans-
                                  S                                         action or due to the internal execution of code). init is
               to provide a short identity (hash) of the world state. We    executed only once at account creation and gets discarded
               assume:                                                      immediately thereafter.
               (11)      ∀a : σ[a] = ∅ ∨ (a ∈ B    ∧ v(σ[a]))                  In contrast, a message call transaction contains:
                                                20
              where v is the account validity function:                           data: An unlimited size byte array specifying the
                                                                                     input data of the message call, formally T .
               (12)   v(x) ≡ x ∈ N     ∧x ∈N ∧x ∈B ∧x ∈B                                                                      d
                               n    256   b    256   s    32   c     32
                                                                               Appendix F speciﬁes the function, S, which maps trans-
                 An account is empty when it has no code, zero nonce        actions to the sender, and happens through the ECDSA of
               and zero balance:                                            the SECP-256k1 curve, using the hash of the transaction
               (13)                                                        (excepting the latter three signature ﬁelds) as the datum
               EMPTY(σ,a)    ≡ σ[a]c =KEC () ∧σ[a]n = 0∧σ[a] = 0
                                                                  b         to sign. For the present we simply assert that the sender
               Even callable precompiled contracts can have an empty        of a given transaction T can be represented with S(T).
               account state. This is because their account states do not
               usually contain the code describing its behavior.            (15)       (
                                                                                         (T ,T ,T ,T ,T ,T ,T ,T ,T )      if T = ∅
                 Anaccountisdead whenitsaccountstateisnon-existent            L (T)≡       n   p  g   t  v  i  w r s          t
               or empty:                                                       T         (T ,T ,T ,T ,T ,T ,T ,T ,T )      otherwise
                                                                                           n   p  g   t  v  d   w r s
               (14)    DEAD(σ,a)    ≡ σ[a]=∅∨EMPTY(σ,a)                        Here, we assume all components are interpreted by the
               4.2. The Transaction. A transaction (formally, T) is a       RLPas integer values, with the exception of the arbitrary
                                                                            length byte arrays T and T .
               single cryptographically-signed instruction constructed by                        i      d
               an actor externally to the scope of Ethereum. While it is    (16)    T ∈N        ∧ T ∈N          ∧ T ∈N          ∧
                                                                                     n     256        v    256        p    256
               assumed that the ultimate external actor will be human in            T ∈N        ∧ T ∈N          ∧ T ∈N          ∧
                                                                                     g     256        w    5          r    256
               nature, software tools will be used in its construction and          Ts ∈ N256   ∧ T ∈B          ∧ T ∈B
                                                                                                      d               i
                            1
               dissemination . There are two types of transactions: those
              which result in message calls and those which result in       where
               the creation of new accounts with associated code (known     (17)           N ={P :P ∈N∧P <2n}
               informally as ‘contract creation’). Both types specify a                      n
               number of common ﬁelds:                                         The address hash T is slightly diﬀerent: it is either a
                                                                                                   t
                    nonce: A scalar value equal to the number of trans-     20-byte address hash or, in the case of being a contract-
                       actions sent by the sender; formally T .             creation transaction (and thus formally equal to ∅), it is
                                                            n
                 1
                  Notably, such ‘tools’ could ultimately become so causally removed from their human-based initiation—or humans may become so
               causally-neutral—that there could be a point at which they rightly be considered autonomous agents. e.g. contracts may oﬀer bounties to
               humans for being sent transactions to initiate their execution.
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 5
                the RLP empty byte sequence and thus the member of B :                  nonce: A64-bitvaluewhich, combinedwiththemix-
                                                                            0
                                                                                            hash, proves that a suﬃcient amount of computa-
                                       (B      if  T 6= ∅                                   tion has been carried out on this block; formally
                (18)              T ∈      20        t                                      H .
                                   t     B     otherwise                                      n
                                           0                                       The other two components in the block are simply a list
                                                                                   of ommer block headers (of the same format as above),
                                                                                   B andaseries of the transactions, B . Formally, we can
                                                                                     U                                     T
                4.3. The Block. The block in Ethereum is the collec-               refer to a block B:
                tion of relevant pieces of information (known as the block
                                                                                   (19)                B≡(B ,B ,B )
                header), H, together with information corresponding to                                          H   T    U
                the comprised transactions, T, and a set of other block
                headers U that are known to have a parent equal to the             4.3.1. Transaction Receipt. In order to encode information
                present block’s parent’s parent (such blocks are known as          about a transaction concerning which it may be useful
                        2                                                          to form a zero-knowledge proof, or index and search, we
               ommers ). The block header contains several pieces of
                information:                                                       encode a receipt of each transaction containing certain in-
                                                                                   formation from its execution. Each receipt, denoted BR[i]
                     parentHash: TheKeccak256-bithashoftheparent                   for the ith transaction, is placed in an index-keyed trie
                         block’s header, in its entirety; formally Hp.             and the root recorded in the header as H .
                                                                                                                               e
                     ommersHash: The Keccak 256-bit hash of the om-                   The transaction receipt, R, is a tuple of four items com-
                         mers list portion of this block; formally H .
                                                                      o            prising: the cumulative gas used in the block containing
                     beneﬁciary: The 160-bit address to which all fees             the transaction receipt as of immediately after the trans-
                         collected from the successful mining of this block        action has happened, Ru, the set of logs created through
                         be transferred; formally Hc.                              execution of the transaction, Rl and the Bloom ﬁlter com-
                     stateRoot: The Keccak 256-bit hash of the root                posed from information in those logs, Rb and the status
                         node of the state trie, after all transactions are        code of the transaction, Rz:
                         executed and ﬁnalisations applied; formally H .
                                                                          r
                     transactionsRoot: The Keccak 256-bit hash of the              (20)                R≡(Ru,Rb,Rl,Rz)
                         root node of the trie structure populated with each          The function L    trivially prepares a transaction receipt
                         transaction in the transactions list portion of the                          R
                         block; formally H .                                       for being transformed into an RLP-serialised byte array:
                                           t
                     receiptsRoot: The Keccak 256-bit hash of the root             (21)          L (R)≡(0∈B ,R ,R ,R)
                                                                                                   R              256   u   b   l
                         node of the trie structure populated with the re-
                         ceipts of each transaction in the transactions list       where 0 ∈ B     replaces the pre-transaction state root that
                                                                                               256
                         portion of the block; formally He.                        existed in previous versions of the protocol.
                     logsBloom: The Bloom ﬁlter composed from index-                  We assert that the status code Rz is a non-negative
                         able information (logger address and log topics)          integer.
                         contained in each log entry from the receipt of           (22)                       R ∈N
                         each transaction in the transactions list; formally                                    z
                         Hb.                                                          Weassert that R , the cumulative gas used, is a non-
                     diﬃculty: A scalar value corresponding to the dif-                                  u
                                                                                   negative integer and that the logs Bloom, Rb, is a hash of
                         ﬁculty level of this block. This can be calculated        size 2048 bits (256 bytes):
                         from the previous block’s diﬃculty level and the
                         timestamp; formally H .                                   (23)             R ∈N ∧ R ∈B
                                                 d                                                    u               b     256
                     number: A scalar value equal to the number of an-
                                                                                      The sequence R is a series of log entries, (O ,O ,...).
                         cestor blocks. The genesis block has a number of                              l                               0   1
                                                                                   A log entry, O, is a tuple of the logger’s address, O , a
                         zero; formally H .                                                                                                 a
                                          i                                        possibly empty series of 32-byte log topics, O and some
                     gasLimit: A scalar value equal to the current limit                                                            t
                                                                                   number of bytes of data, O :
                         of gas expenditure per block; formally H .                                             d
                                                                    l
                     gasUsed: A scalar value equal to the total gas used           (24)            O≡(O ,(O ,O ,...),O )
                         in transactions in this block; formally H .                                       a    t0   t1       d
                                                                    g
                     timestamp: A scalar value equal to the reasonable             (25)    O ∈B         ∧ ∀        : x ∈ B      ∧ O ∈B
                                                                                             a     20         x∈O          32         d
                         output of Unix’s time() at this block’s inception;                                       t
                         formally H .
                                    s                                                 Wedeﬁne the Bloom ﬁlter function, M, to reduce a log
                     extraData: Anarbitrarybytearraycontaining data                entry into a single 256-byte hash:
                         relevant to this block. This must be 32 bytes or                                _                         
                         fewer; formally Hx.                                       (26)        M(O)≡                    M       (x)
                                                                                                            x∈{O }∪O      3:2048
                     mixHash: A256-bit hash which, combined with the                                             a    t
                         nonce, proves that a suﬃcient amount of compu-               where M         is a specialised Bloom ﬁlter that sets
                                                                                                3:2048
                         tation has been carried out on this block; formally       three bits out of 2048, given an arbitrary byte sequence.
                         Hm.                                                       It does this through taking the low-order 11 bits of each of
                   2
                    ommer is a gender-neutral term to mean “sibling of parent”; see https://nonbinary.miraheze.org/wiki/Gender_neutral_language#Aunt.
                2FUncle
                   3          2048
                    11 bits = 2   , and the low-order 11 bits is the modulo 2048 of the operand, which is in this case is “each of the ﬁrst three pairs of
                bytes in a Keccak-256 hash of the byte sequence.”
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 6
               the ﬁrst three pairs of bytes in a Keccak-256 hash of the            where
               byte sequence.3 Formally:
                                                                                 (38)           B ={B:B∈B∧kBk=n}
               (27)M       (x : x ∈ B)   ≡ y:y∈B            where:                               n
                      3:2048                           256
               (28)                  y = (0,0,...,0) except:                        Wenowhave a rigorous speciﬁcation for the construc-
               (29)          ∀            :  B       (y) = 1                     tion of a formal block structure. The RLP function RLP
                              i∈{0,2,4}        m(x,i)                           (see Appendix B) provides the canonical method for trans-
               (30)            m(x,i)    ≡ KEC(x)[i,i+1] mod 2048                forming this structure into a sequence of bytes ready for
                  where B is the bit reference function such that B (x)          transmission over the wire or storage locally.
                                                                        j
               equals the bit of index j (indexed from 0) in the byte array
               x.                                                                4.3.4. Block Header Validity. We deﬁne P(BH) to be the
                                                                                 parent block of B, formally:
               4.3.2. Holistic Validity. We can assert a block’s validity
               if and only if it satisﬁes several conditions: it must be in-     (39)        P(H)≡B′:KEC(RLP(B′ ))=H
                                                                                                                      H        p
               ternally consistent with the ommer and transaction block
               hashes and the given transactions B      (as speciﬁed in sec         The block number is the parent’s block number incre-
                                                     T
               11), when executed in order on the base state σ (derived          mented by one:
               from the ﬁnal state of the parent block), result in a new         (40)                 H ≡P(H) +1
               state of the identity H :                                                                i        Hi
                                       r
               (31)        H ≡ TRIE(L (Π(σ,B)))                   ∧                 Thecanonical diﬃculty of a block of header H is deﬁned
                             r               S
                           Ho ≡ KEC(RLP(L∗ (B )))                 ∧              as D(H):
                                                H U
                           H ≡ TRIE({∀i<kB k,i∈N:                                (41)
                             t                       T                                     (
                                                                                             D                                  if  H =0
                                          p(i,LT(B [i]))})        ∧                            0                                      i
                                                    T                             D(H)≡                                      
                           H ≡ TRIE({∀i<kB k,i∈N:
                             e                       R                                       max D ,P(H)        +x×ς +ǫ otherwise
                                                                                                     0       Hd         2
                                          p(i,LR(B [i]))})        ∧
                                     W             R
                           H ≡                r                                  where:
                             b         r∈BR    b
               where p(k,v) is simply the pairwise RLP transformation,           (42)                   D ≡131072
                                                                                                          0
               in this case, the ﬁrst being the index of the transaction in
               the block and the second being the transaction receipt:                                               
                                                                                (43)                 x≡ P(H)Hd
               (32)             p(k,v) ≡ RLP(k),RLP(v)                                                         2048
                  Furthermore:
                                                                                                         H −P(H)               
               (33)             TRIE(L (σ)) = P(B )                                                           s        Hs
                                        S            H Hr                        (44)     ς2 ≡ max y−                       , −99
                                                                                                                  9
                  Thus TRIE(LS(σ)) is the root node hash of the Merkle
               Patricia tree structure containing the key-value pairs of                              (
               the state σ with values encoded using RLP, and P(B ) is                                  1  if kP(H)Uk = 0
                                                                      H                          y ≡
               the parent block of B, deﬁned directly.                                                  2  otherwise
                  The values stemming from the computation of transac-
               tions, speciﬁcally the transaction receipts, B , and that                              j     ′          k
                                                               R                                          H ÷100000 −2
               deﬁned through the transaction’s state-accumulation func-         (45)             ǫ ≡ 2⌊ i          ⌋
               tion, Π, are formalised later in section 11.4.                    (46)           H′ ≡max(Hi−3000000,0)
                                                                                                  i
               4.3.3. Serialisation. The function L       and L    are the
                                                       B        H                   Note that D0 is the diﬃculty of the genesis block. The
               preparation functions for a block and block header re-            Homestead diﬃculty parameter, ς2, is used to aﬀect a dy-
               spectively. Much like the transaction receipt preparation         namic homeostasis of time between blocks, as the time
               function LR, we assert the types and order of the structure       between blocks varies, as discussed below, as implemented
               for when the RLP transformation is required:                      in EIP-2 by Buterin [2015]. In the Homestead release,
               (34) L (H) ≡ ( H ,H ,H ,H ,H ,H ,H ,H ,                           the exponential diﬃculty symbol, ǫ causes the diﬃculty to
                       H                p   o   c   r   t   e   b    d
                                      H,H,H ,H ,H ,H ,H )                        slowly increase (every 100,000 blocks) at an exponential
                                        i   l   g   s   x   m    n
                                                 ∗        ∗                     rate, and thus increasing the block time diﬀerence, and
               (35)   L (B) ≡        L (B ),L (B ),L (B )
                       B               H H T T H U                               putting time pressure on transitioning to proof-of-stake.
                          ∗        ∗                                             This eﬀect, known as the “diﬃculty bomb”, or “ice age”,
                  With L and L being element-wise sequence transfor-
                          T        H
               mations, thus:                                                    was explained in EIP-649 by Schoedon and Buterin [2017]
               (36)                                                              and delayed and implemented earlier in EIP-2. ς2 was also
                  ∗                                                            modiﬁed in EIP-100 with the use of x, the adjustment
                f   (x ,x ,...) ≡ f(x ),f(x ),...      for any function f
                      0   1             0      1
                  The component types are deﬁned thus:                           factor above, and the denominator 9, in order to target
                                                                                 the mean block time including uncle blocks by Buterin
               (37)    H ∈B         ∧ H ∈B           ∧ H ∈B           ∧          [2016]. Finally, in the Byzantium release, with EIP-649,
                         p     32         o     32         c     20
                       H ∈B         ∧ H ∈B           ∧ H ∈B           ∧          the ice age was delayed by creating a fake block number,
                         r    32          t     32         e     32
                       H ∈B         ∧ H ∈N           ∧ H ∈N           ∧          H′, which is obtained by subtracting three million from
                         b     256        d                i                       i
                       H ∈N         ∧ Hg∈N           ∧ Hs∈N256 ∧                 the actual block number, which in other words reduced ǫ
                         l
                       H ∈B         ∧ H ∈B           ∧ H ∈B                      and the time diﬀerence between blocks, in order to allow
                         x                m      32        n     8
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 7
               more time to develop proof-of-stake and preventing the                              5. Gas and Payment
               network from “freezing” up.                                          In order to avoid issues of network abuse and to sidestep
                  The canonical gas limit H of a block of header H must
                                             l                                   the inevitable questions stemming from Turing complete-
               fulﬁl the relation:                                             ness, all programmable computation in Ethereum is subject
                                                  P(H)
               (47)            H <P(H) +                Hl     ∧                 to fees. The fee schedule is speciﬁed in units of gas (see Ap-
                                 l         Hl       1024
                                                                               pendix G for the fees associated with various computation).
                                                  P(H)                           Thus any given fragment of programmable computation
                               H >P(H) −                Hl     ∧
                                 l         Hl       1024                        (this includes creating contracts, making message calls,
                               H >5000                                           utilising and accessing account storage and executing op-
                                 l
                                                                                 erations on the virtual machine) has a universally agreed
                  H is the timestamp (in Unix’s time()) of block H and
                    s                                                            cost in terms of gas.
               must fulﬁl the relation:                                             Every transaction has a speciﬁc amount of gas associ-
               (48)                   H >P(H)                                    ated with it: gasLimit. This is the amount of gas which
                                        s         Hs
                  This mechanism enforces a homeostasis in terms of the          is implicitly purchased from the sender’s account balance.
               time between blocks; a smaller period between the last two        The purchase happens at the according gasPrice, also
               blocks results in an increase in the diﬃculty level and thus      speciﬁed in the transaction. The transaction is consid-
               additional computation required, lengthening the likely           ered invalid if the account balance cannot support such
               next period. Conversely, if the period is too large, the          a purchase. It is named gasLimit since any unused gas
               diﬃculty, and expected time to the next block, is reduced.        at the end of the transaction is refunded (at the same
                  The nonce, H , must satisfy the relations:                     rate of purchase) to the sender’s account. Gas does not
                                 n                                               exist outside of the execution of a transaction. Thus for
                                       256
               (49)             n62          ∧ m=H                               accounts with trusted code associated, a relatively high
                                      H                  m                       gas limit may be set and left alone.
                                        d
               with (n,m) = PoW(Hn,Hn,d).                                           In general, Ether used to purchase gas that is not re-
                  WhereHn is the new block’s header H, but without the           funded is delivered to the beneﬁciary address, the address
               nonce and mix-hash components, d being the current DAG,           of an account typically under the control of the miner.
               a large data set needed to compute the mix-hash, and PoW          Transactors are free to specify any gasPrice that they
               is the proof-of-work function (see section 11.5): this evalu-     wish, however miners are free to ignore transactions as
               ates to an array with the ﬁrst item being the mix-hash, to        they choose. A higher gas price on a transaction will there-
               prove that a correct DAG has been used, and the second            fore cost the sender more in terms of Ether and deliver
               item being a pseudo-random number cryptographically               a greater value to the miner and thus will more likely be
               dependent on H and d. Given an approximately uniform              selected for inclusion by more miners. Miners, in general,
                                             64                                  will choose to advertise the minimum gas price for which
               distribution in the range [0,2  ), the expected time to ﬁnd
               a solution is proportional to the diﬃculty, Hd.                   they will execute transactions and transactors will be free
                  This is the foundation of the security of the blockchain       to canvas these prices in determining what gas price to
               and is the fundamental reason why a malicious node can-           oﬀer. Since there will be a (weighted) distribution of min-
               not propagate newly created blocks that would otherwise           imum acceptable gas prices, transactors will necessarily
               overwrite (“rewrite”) history. Because the nonce must sat-        have a trade-oﬀ to make between lowering the gas price
               isfy this requirement, and because its satisfaction depends       and maximising the chance that their transaction will be
               on the contents of the block and in turn its composed             mined in a timely manner.
               transactions, creating new, valid, blocks is diﬃcult and,
               over time, requires approximately the total compute power                       6. Transaction Execution
               of the trustworthy portion of the mining peers.                      The execution of a transaction is the most complex part
                  Thus we are able to deﬁne the block header validity            of the Ethereum protocol: it deﬁnes the state transition
               function V(H):                                                    function Υ. It is assumed that any transactions executed
                                         256                                     ﬁrst pass the initial tests of intrinsic validity. These include:
               (50)   V(H) ≡ n6 2            ∧m=H ∧
                                        H             m                              (1) The transaction is well-formed RLP, with no addi-
                                          d
                                   H =D(H) ∧                                             tional trailing bytes;
                                     d
                                   H ≤H ∧                                            (2) the transaction signature is valid;
                                     g     l                 
                                                      P(H)                           (3) the transaction nonce is valid (equivalent to the
                                   H <P(H) +                Hl     ∧                     sender account’s current nonce);
                                     l         Hl       1024
                                                                                   (4) the gas limit is no smaller than the intrinsic gas,
                                                      P(H)
                                                            Hl                           g , used by the transaction; and
                                   H >P(H) −                       ∧                      0
                                     l         Hl       1024                         (5) the sender account balance contains at least the
                                   H >5000 ∧                                             cost, v , required in up-front payment.
                                     l                                                          0
                                   H >P(H)          ∧                               Formally, we consider the function Υ, with T being a
                                     s         Hs
                                   H =P(H) +1 ∧                                  transaction and σ the state:
                                     i         Hi
                                   kHxk≤32                                       (51)                   σ′ = Υ(σ,T)
               where (n,m) = PoW(H ,H ,d)                                           Thus σ′ is the post-transactional state. We also deﬁne
                                      n    n
                                                                                  g
                  Noting additionally that extraData must be at most            Υ to evaluate to the amount of gas used in the execution
                                                                                                    l
               32 bytes.                                                         of a transaction, Υ to evaluate to the transaction’s accrued
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 8
                                 z
                log items and Υ to evaluate to the status code resulting          or a message call, results in an eventual state (which may
                from the transaction. These will be formally deﬁned later.        legally be equivalent to the current state), the change to
                                                                                  which is deterministic and never invalid: there can be no
                6.1. Substate. Throughout transaction execution, we ac-           invalid transactions from this point.
                crue certain information that is acted upon immediately              Wedeﬁne the checkpoint state σ :
                following the transaction. We call this transaction substate,                                            0
                and represent it as A, which is a tuple:                          (59)                 σ0   ≡ σ except:
                                                                                  (60)         σ [S(T)]     ≡ σ[S(T)] −T T
                (52)                A≡(A ,A,A ,A )                                               0       b               b     g p
                                           s   l   t   r
                                                                                  (61)         σ [S(T)]     ≡ σ[S(T)] +1
                   The tuple contents include A , the self-destruct set: a                       0       n               n
                                                  s
                set of accounts that will be discarded following the trans-          Evaluating σP from σ0 depends on the transaction
                action’s completion. A is the log series: this is a series of     type; either contract creation or message call; we deﬁne
                                        l
                archived and indexable ‘checkpoints’ in VM code execu-            the tuple of post-execution provisional state σP, remaining
                tion that allow for contract-calls to be easily tracked by        gas g′, substate A and status code z:
                onlookers external to the Ethereum world (such as decen-          (62)             
                tralised application front-ends). A is the set of touched
                                                     t                                                Λ (σ ,S(T),T ,g,
                                                                                                    4 0             o
                                                                                                   
                accounts, of which the empty ones are deleted at the end                           
                                                                                                          T ,T ,T ,0,⊤)           if  T =∅
                of a transaction. Finally there is A , the refund balance,         (σ ,g′,A,z) ≡            p   v  i                     t
                                                      r                              P             
                                                                                                      Θ (σ ,S(T),T ,T ,T ,
                                                                                                    4 0             o   t  t
                increased through using the SSTORE instruction in order                            
                                                                                                          g,T ,T ,T ,T ,0,⊤) otherwise
                to reset contract storage to zero from some non-zero value.                                   p   v   v  d
               Thoughnotimmediately refunded, it is allowed to partially             where g is the amount of gas remaining after deducting
                oﬀset the total execution costs.                                  the basic amount required to pay for the existence of the
                                                         0
                   We deﬁne the empty substate A to have no self-                 transaction:
                destructs, no logs, no touched accounts and a zero refund
                                                                                  (63)                     g ≡ T −g
                balance:                                                                                         g    0
                                       0                                          and T is the original transactor, which can diﬀer from the
                (53)                 A ≡(∅,(),∅,0)                                      o
                                                                                  sender in the case of a message call or contract creation
                6.2. Execution. We deﬁne intrinsic gas g0, the amount of          not directly triggered by a transaction but coming from
                gas this transaction requires to be paid prior to execution,      the execution of EVM-code.
                as follows:                                                          Note we use Θ and Λ to denote the fact that only the
                                      (                                                              4       4
                                 X G                     if  i = 0                ﬁrst four components of the functions’ values are taken;
                (54)     g ≡              txdatazero
                          0             G                otherwise                the ﬁnal represents the message-call’s output value (a byte
                               i∈T ,T     txdatanonzero
                                  i  d                                            array) and is unused in the context of transaction evalua-
                                  (                                               tion.
                                    G          if  T =∅
                (55)           +      txcreate      t
                                    0          otherwise                             After the message call or contract creation is processed,
                (56)           +G                                                 the refund counter has to be incremented for the accounts
                                    transaction                                   that were self-destructed throughout its invocation.
                   where Ti,Td means the series of bytes of the trans-                              ′         X
                                                                                  (64)            A ≡A +           R
                action’s associated data and initialisation EVM-code, de-                           r     r          selfdestruct
                                                                                                              i∈A
                pending on whether the transaction is for contract-creation                                      s
                or message-call. G           is added if the transaction is          Then the state is ﬁnalised by determining the amount
                                     txcreate
                contract-creating, but not if a result of EVM-code. G is          to be refunded, g∗ from the remaining gas, g′, plus some
                fully deﬁned in Appendix G.                                       allowance from the refund counter, to the sender at the
                   The up-front cost v0 is calculated as:                         original rate.
                                                                                                                               
                (57)                  v ≡T T +T                                                                  jT −g′k
                                       0     g p     v                            (65)          g∗ ≡ g′ +min        g       , A′
                                                                                                                      2        r
                   The validity is determined as:
                (58)              S(T) 6= ∅ ∧                                        The total refundable amount is the legitimately remain-
                                                                                  ing gas g′, added to A , with the latter component being
                               σ[S(T)]    6= ∅ ∧                                                          r
                                     T    = σ[S(T)]        ∧                      capped up to a maximum of half (rounded down) of the
                                      n                n                          total amount used T −g′. Therefore, g∗ is the total gas
                                     g    6 T ∧                                                         g
                                      0         g                                 that remains after the transaction has been executed.
                                     v    6 σ[S(T)]        ∧
                                      0                b                             The Ether for the gas is given to the miner, whose
                                     T    6 B −ℓ(B )
                                      g         Hl        R u                     address is speciﬁed as the beneﬁciary of the present block
                   Note the ﬁnal condition; the sum of the transaction’s          B. So we deﬁne the pre-ﬁnal state σ∗ in terms of the
                gas limit, Tg, and the gas utilised in this block prior, given    provisional state σP:
                by ℓ(B ) , must be no greater than the block’s gasLimit,
                       R u                                                                            ∗
                B .                                                               (66)              σ    ≡ σP except
                 Hl
                   The execution of a valid transaction begins with an            (67)      σ∗[S(T)]     ≡ σ [S(T)] +g∗T
                                                                                                      b         P       b       p
                irrevocable change made to the state: the nonce of the            (68)         σ∗[m]     ≡ σ [m] +(T −g∗)T
                                                                                                      b         P    b      g       p
                account of the sender, S(T), is incremented by one and the        (69)               m ≡ B
                balance is reduced by part of the up-front cost, T T . The                                      Hc
                                                                   g p
                gas available for the proceeding computation, g, is deﬁned           The ﬁnal state, σ′, is reached after deleting all accounts
                as T −g . The computation, whether contract creation              that either appear in the self-destruct list or are touched
                    g    0
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-28 9
               and empty:                                                         Finally, the account is initialised through the execution
               (70)                 σ′   ≡ σ∗ except                           of the initialising EVM code i according to the execution
               (71)     ∀i ∈ A : σ′[i]   = ∅                                   model (see section 9). Code execution can eﬀect several
                               s                                               events that are not internal to the execution state: the
                                    ′                        ∗
               (72)     ∀i ∈ A : σ [i]   = ∅ if DEAD(σ,i)
                               t                                               account’s storage can be altered, further accounts can be
                                            g                                  created and further message calls can be made. As such,
                  And ﬁnally, we specify Υ , the total gas used in this
               transaction Υl, the logs created by this transaction and        the code execution function Ξ evaluates to a tuple of the re-
               Υz, the status code of this transaction:                        sultant state σ∗∗, available gas remaining g∗∗, the accrued
               (73)             Υg(σ,T) ≡ T −g∗                                substate A and the body code of the account o.
                                                  g
               (74)              Υl(σ,T)    ≡ A
                                                  l
               (75)              Υz(σ,T) ≡ z
                                                                               (83)       (σ∗∗,g∗∗,A,o) ≡ Ξ(σ∗,g,I,{s,a})
                  These are used to help deﬁne the transaction receipt
               and are also used later for state and nonce validation.
                               7. Contract Creation                           where I contains the parameters of the execution environ-
                                                                               ment, that is:
                  There are a number of intrinsic parameters used when
               creating an account: sender (s), original transactor (o),
               available gas (g), gas price (p), endowment (v) together        (84)                    I   ≡ a
                                                                                                        a
               with an arbitrary length byte array, i, the initialisation      (85)                    I   ≡ o
               EVMcode, the present depth of the message-call/contract-                                 o
                                                                               (86)                    I   ≡ p
               creation stack (e) and ﬁnally the permission to make mod-                                p
                                                                               (87)                   I    ≡ ()
               iﬁcations to the state (w).                                                             d
                  Wedeﬁnethecreation function formally as the function         (88)                    Is  ≡ s
               Λ, which evaluates from these values, together with the         (89)                    Iv  ≡ v
               state σ to the tuple containing the new state, remaining        (90)                   I    ≡ i
               gas, accrued transaction substate and an error message                                  b
                 ′  ′                                                          (91)                    I   ≡ e
               (σ ,g ,A,o), as in section 6:                                                            e
               (76)     (σ′,g′,A,z,o) ≡ Λ(σ,s,o,g,p,v,i,e,w)                   (92)                   Iw   ≡ w
                  The address of the new account is deﬁned as being the
               rightmost 160 bits of the Keccak hash of the RLP encoding          Id evaluates to the empty tuple as there is no input data
               of the structure containing only the sender and the account     to this call. IH has no special treatment and is determined
               nonce. Thus we deﬁne the resultant address for the new          from the blockchain.
               account a:                                                     Code execution depletes gas, and gas may not go below
                                                                              zero, thus execution may exit before the code has come
               (77)     a ≡ B        KEC RLP (s,σ[s] −1)
                             96..255                  n
                                                                               to a natural halting state. In this (and several other) ex-
                  where KEC is the Keccak 256-bit hash function, RLP is        ceptional cases we say an out-of-gas (OOG) exception has
               the RLP encoding function, B     (X) evaluates to a binary
                                             a..b                              occurred: The evaluated state is deﬁned as being the empty
               value containing the bits of indices in the range [a,b] of      set, ∅, and the entire create operation should have no eﬀect
               the binary data X, and σ[x] is the address state of x, or       on the state, eﬀectively leaving it as it was immediately
               ∅if none exists. Note we use one fewer than the sender’s        prior to attempting the creation.
               nonce value; we assert that we have incremented the sender         If the initialization code completes successfully, a ﬁnal
               account’s nonce prior to this call, and so the value used       contract-creation cost is paid, the code-deposit cost, c,
               is the sender’s nonce at the beginning of the responsible       proportional to the size of the created contract’s code:
               transaction or VM operation.
                  The account’s nonce is initially deﬁned as one, the bal-
               ance as the value passed, the storage as empty and the          (93)              c ≡ Gcodedeposit × |o|
               code hash as the Keccak 256-bit hash of the empty string;
               the sender’s balance is also reduced by the value passed.
               Thus the mutated state becomes σ∗:                                 If there is not enough gas remaining to pay this, i.e.
               (78)                 σ∗ ≡σ except:                              g∗∗ < c, then we also declare an out-of-gas exception.
                                                                                The gas remaining will be zero in any such exceptional
               (79)    σ∗[a]   = 1,v+v′,TRIE(∅),KEC ()                         condition, i.e. if the creation was conducted as the recep-
                                    (                                          tion of a transaction, then this doesn’t aﬀect payment of
               (80)    σ∗[s]   =     ∅ if σ[s] = ∅ ∧ v = 0                     the intrinsic cost of contract creation; it is paid regardless.
                                     a∗   otherwise                            However, the value of the transaction is not transferred to
               (81)       a∗   ≡ (σ[s] ,σ[s] −v,σ[s] ,σ[s] )                   the aborted contract’s address when we are out-of-gas.
                                         n     b         s     c
                  where v′ is the account’s pre-existing value, in the event      If such an exception does not occur, then the remaining
               it was previously in existence:                                 gas is refunded to the originator and the now-altered state
                                   (                                           is allowed to persist. Thus formally, we may specify the re-
               (82)           v′ ≡   0       if  σ[a] = ∅                      sultant state, gas, substate and status code as (σ′,g′,A,z)
                                     σ[a]    otherwise                        where:
                                         b
                ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2810
                                                                              We deﬁne σ1, the ﬁrst transitional state as the orig-
              (94)                                                         inal state but with the value transferred from sender to
                                                                           recipient:
                       (                                                   (99)     σ1[r] ≡ σ[r] +v     ∧ σ1[s] ≡σ[s] −v
                         0        if F                                                  b       b                b       b
                  g′ ≡    ∗∗                                               unless s = r.
                         g  −c otherwise                                      Throughout the present work, it is assumed that if σ [r]
              (95)                                                                                                              1
                                                                          was originally undeﬁned, it will be created as an account
                       
                         σ                  if  F
                                                                          with no code or state and zero balance and nonce. Thus
                       
                        ∗∗
                       
                       
                         σ     except:                                     the previous equation should be taken to mean:
                  σ′ ≡  σ′[a] = ∅          if  DEAD(σ∗∗,a)                                          ′
                                                                          (100)              σ1 ≡σ1 except:
                        ∗∗
                       
                         σ     except:
                       
                       
                       
                        σ′[a] =KEC(o) otherwise                                             (
                                c                                                              ∅ if σ′[s] = ∅ ∧ v = 0
                                                                           (101)     σ [s] ≡           1
              (96)     (                                                               1       a   otherwise
                         0  if  σ∗∗ = ∅∨g∗∗ <c                                                  1
                   z ≡   1  otherwise                                                         ′      ′          ′      ′   
                                                                           (102)       a ≡ σ [s] ,σ [s] −v,σ [s] ,σ [s]
                                                                                        1     1   n  1   b      1   s  1  c
              where
              (97)                                                        (103)            and σ′ ≡σ except:
                  F ≡ (σ∗∗ =∅ ∧ o=∅)∨ g∗∗ <c ∨ |o|>24576                                           1
                                                        ′                  (104)
                 The exception in the determination of σ dictates that       ′
                                                                            
                                                                              σ1[r] ≡ (0,v,TRIE(∅),KEC(()))   if  σ[r] = ∅∧v 6= 0
              o, the resultant byte sequence from the execution of the       ′
              initialisation code, speciﬁes the ﬁnal body code for the        σ1[r] ≡ ∅                       if  σ[r] = ∅∧v = 0
                                                                            
                                                                             ′        ′
                                                                              σ [r] ≡ a                       otherwise
              newly-created account.                                            1      1
                 Note that intention is that the result is either a success-
              fully created new contract with its endowment, or no new     (105)      a′ ≡ (σ[r] ,σ[r] +v,σ[r] ,σ[r] )
              contract with no transfer of value.                                      1        n     b         s     c
                                                                              The account’s associated code (identiﬁed as the frag-
              7.1. Subtleties. Note that while the initialisation code     ment whose Keccak hash is σ[c] ) is executed according to
                                                                                                         c
              is executing, the newly created address exists but with      the execution model (see section 9). Just as with contract
                                    4
              no intrinsic body code . Thus any message call received      creation, if the execution halts in an exceptional fashion
              by it during this time causes no code to be executed. If     (i.e. due to an exhausted gas supply, stack underﬂow, in-
              the initialisation execution ends with a SELFDESTRUCT        valid jump destination or invalid instruction), then no gas
              instruction, the matter is moot since the account will be    is refunded to the caller and the state is reverted to the
              deleted before the transaction is completed. For a normal    point immediately prior to balance transfer (i.e. σ).
              STOPcode,orifthecodereturnedisotherwiseempty, then
              the state is left with a zombie account, and any remaining                              (
              balance will be locked into the account forever.             (106)              σ′  ≡     σ     if σ∗∗ = ∅
                                                                                                        σ∗∗   otherwise
                                 8. Message Call                                                                  ∗∗
                                                                                                      
                                                                                                        0     if σ =∅∧
                 In the case of executing a message call, several param-   (107)              g′  ≡            o=∅
                                                                                                      
              eters are required: sender (s), transaction originator (o),                              ∗∗
                                                                                                        g     otherwise
              recipient (r), the account whose code is to be executed (c,                             (
              usually the same as recipient), available gas (g), value (v)                     z  ≡     0  if  σ∗∗ = ∅
              and gas price (p) together with an arbitrary length byte                                  1  otherwise
              array, d, the input data of the call, the present depth of   (108) (σ∗∗,g∗∗,A,o)    ≡ Ξ
              the message-call/contract-creation stack (e) and ﬁnally the
                                                                           (109)              I   ≡ r
              permission to make modiﬁcations to the state (w).                                a
                 Aside from evaluating to a new state and transaction      (110)              I   ≡ o
                                                                                               o
              substate, message calls also have an extra component—the     (111)              I   ≡ p
                                                                                               p
              output data denoted by the byte array o. This is ignored     (112)              I   ≡ d
              when executing transactions, however message calls can be                        d
                                                                           (113)              I   ≡ s
              initiated due to VM-code execution and in this case this                         s
              information is used.                                         (114)              I   ≡ v˜
                                                                                               v
              (98)   (σ′,g′,A,z,o) ≡ Θ(σ,s,o,r,c,g,p,v,v˜,d,e,w)           (115)              Ie  ≡ e
              Note that we need to diﬀerentiate between the value that     (116)             Iw   ≡ w
              is to be transferred, v, from the value apparent in the      (117)               t  ≡ {s,r}
              execution context, v˜, for the DELEGATECALL instruction.     (118)
                 4
                  During initialization code execution, EXTCODESIZE on the address should return zero, which is the length of the code of the account while
              CODESIZE should return the length of the initialization code (as deﬁned in H.2).
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2811
                where                                                             the transaction processor or, recursively, the spawning
                                                                                  execution environment) which will deal with it separately.
                                   ΞECREC(σ1,g,I,t)     if  r = 1
                                
                                
                                
                                
                                
                                   ΞSHA256(σ1,g,I,t)    if  r = 2                  9.2. Fees Overview. Fees (denominated in gas) are
                                
                                
                                
                                                                                  charged under three distinct circumstances, all three as
                                
                                   ΞRIP160(σ1,g,I,t)    if  r = 3
                                
                                
                                                                                  prerequisite to the execution of an operation. The ﬁrst
                                
                                
                                   ΞID(σ1,g,I,t)        if  r = 4
                (119)      Ξ≡                                                     and most common is the fee intrinsic to the computation
                                   ΞEXPMOD(σ1,g,I,t)    if  r = 5                  of the operation (see Appendix G). Secondly, gas may be
                                
                                
                                
                                   Ξ     (σ ,g,I,t)     if  r = 6
                                 BN ADD    1                                      deducted in order to form the payment for a subordinate
                                
                                
                                
                                
                                   Ξ     (σ ,g,I,t)     if  r = 7                  message call or contract creation; this forms part of the
                                 BN MUL    1
                                
                                
                                                                                  payment for CREATE, CALL and CALLCODE. Finally, gas
                                
                                   Ξ     (σ ,g,I,t)     if  r = 8
                                 SNARKV    1
                                
                                
                                                                                  maybepaidduetoanincrease in the usage of the memory.
                                   Ξ(σ1,g,I,t)          otherwise
                                                                                      Over an account’s execution, the total fee for memory-
                                                                                   usage payable is proportional to smallest multiple of 32
                (120)               Let KEC(I ) = σ[c]
                                              b         c                          bytes that are required such that all memory indices
                   It is assumed that the client will have stored the pair         (whether for read or write) are included in the range. This
               (KEC(I ),I ) at some point prior in order to make the               is paid for on a just-in-time basis; as such, referencing an
                      b    b
                determination of I feasible.                                       area of memory at least 32 bytes greater than any previ-
                                    b
                   As can be seen, there are eight exceptions to the usage         ously indexed memory will certainly result in an additional
                of the general execution framework Ξ for evaluation of             memory usage fee. Due to this fee it is highly unlikely
                the message call: these are eight so-called ‘precompiled’          addresses will ever go above 32-bit bounds. That said,
                contracts, meant as a preliminary piece of architecture            implementations must be able to manage this eventuality.
                that may later become native extensions. The eight con-               Storage fees have a slightly nuanced behaviour—to in-
                tracts in addresses 1 to 8 execute the elliptic curve public       centivise minimisation of the use of storage (which corre-
                key recovery function, the SHA2 256-bit hash scheme, the           sponds directly to a larger state database on all nodes),
                RIPEMD160-bit hash scheme, the identity function, ar-              the execution fee for an operation that clears an entry in
                bitrary precision modular exponentiation, elliptic curve           the storage is not only waived, a qualiﬁed refund is given;
                addition, elliptic curve scalar multiplication and an elliptic     in fact, this refund is eﬀectively paid up-front since the
                curve pairing check respectively.                                  initial usage of a storage location costs substantially more
                   Their full formal deﬁnition is in Appendix E.                   than normal usage.
                                                                                      See Appendix H for a rigorous deﬁnition of the EVM
                                  9. Execution Model                               gas cost.
                   The execution model speciﬁes how the system state is            9.3. Execution Environment. In addition to the sys-
                altered given a series of bytecode instructions and a small        tem state σ, and the remaining gas for computation g,
                tuple of environmental data. This is speciﬁed through a            there are several pieces of important information used in
                formal model of a virtual state machine, known as the              the execution environment that the execution agent must
                Ethereum Virtual Machine (EVM). It is a quasi-Turing-              provide; these are contained in the tuple I:
                complete machine; the quasi qualiﬁcation comes from the                   • I , the address of the account which owns the code
                fact that the computation is intrinsically bounded through                   a
                a parameter, gas, which limits the total amount of compu-                   that is executing.
                                                                                          • I , the sender address of the transaction that orig-
                tation done.                                                                 o
                                                                                            inated this execution.
                                                                                          • I , the price of gas in the transaction that origi-
                9.1. Basics. The EVM is a simple stack-based architec-                       p
                ture. The word size of the machine (and thus size of stack                  nated this execution.
                                                                                          • I , the byte array that is the input data to this
                items) is 256-bit. This was chosen to facilitate the Keccak-                 d
                256 hash scheme and elliptic-curve computations. The                        execution; if the execution agent is a transaction,
                memory model is a simple word-addressed byte array. The                     this would be the transaction data.
                                                                                          • I , the address of the account which caused the
                stack has a maximum size of 1024. The machine also has                       s
                an independent storage model; this is similar in concept                    code to be executing; if the execution agent is a
                to the memory but rather than a byte array, it is a word-                   transaction, this would be the transaction sender.
                                                                                          • I , the value, in Wei, passed to this account as
                addressable word array. Unlike memory, which is volatile,                    v
                storage is non volatile and is maintained as part of the                    part of the same procedure as execution; if the
                system state. All locations in both storage and memory                      execution agent is a transaction, this would be the
                are well-deﬁned initially as zero.                                          transaction value.
                                                                                          • I , the byte array that is the machine code to be
                   The machine does not follow the standard von Neu-                         b
                mann architecture. Rather than storing program code                         executed.
                                                                                          • I , the block header of the present block.
                in generally-accessible memory or storage, it is stored                      H
                                                                                          • I , the depth of the present message-call or
                separately in a virtual ROM interactable only through                        e
                a specialised instruction.                                                  contract-creation (i.e. the number of CALLs or
                   The machine can have exceptional execution for several                   CREATEs being executed at present).
                                                                                          • I , the permission to make modiﬁcations to the
                reasons, including stack underﬂows and invalid instruc-                      w
                tions. Like the out-of-gas exception, they do not leave                     state.
                state changes intact. Rather, the machine halts immedi-               The execution model deﬁnes the function Ξ, which can
                ately and reports the issue to the execution agent (either         compute the resultant state σ′, the remaining gas g′, the
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2812
               accrued substate A and the resultant output, o, given these     9.4.1. Machine State. The machine state µ is deﬁned as
               deﬁnitions. For the present context, we will deﬁne it as:       the tuple (g,pc,m,i,s) which are the gas available, the
               (121)            (σ′,g′,A,o) ≡ Ξ(σ,g,I)                         program counter pc ∈ N256 , the memory contents, the
                                                                               active number of words in memory (counting continuously
                                                                               from position 0), and the stack contents. The memory
                  where we will remember that A, the accrued substate          contents µ    are a series of zeroes of size 2256.
               is deﬁned as the tuple of the selfdestructs set s, the log                 m
                                                                                  For the ease of reading, the instruction mnemonics,
               series l, the touched accounts t and the refunds r:             written in small-caps (e.g. ADD), should be interpreted as
                                                                               their numeric equivalents; the full table of instructions and
               (122)                  A≡(s,l,t,r)                              their speciﬁcs is given in Appendix H.
                                                                                  For the purposes of deﬁning Z, H and O, we deﬁne w
                                                                               as the current operation to be executed:
               9.4. Execution Overview. We must now deﬁne the Ξ                                  (
               function. In most practical implementations this will be                            I [µ ] if µ <kI k
                                                                               (136)         w≡ b pc              pc      b
               modelled as an iterative progression of the pair comprising                         STOP      otherwise
               the full system state, σ and the machine state, µ. For-
               mally, we deﬁne it recursively with a function X. This             Wealsoassumetheﬁxedamountsofδ andα, specifying
               uses an iterator function O (which deﬁnes the result of a       the stack items removed and added, both subscriptable
               single cycle of the state machine) together with functions      on the instruction and an instruction cost function C eval-
               Z which determines if the present state is an exceptional       uating to the full cost, in gas, of executing the given
               halting state of the machine and H, specifying the output       instruction.
               data of the instruction if and only if the present state is a
               normal halting state of the machine.                            9.4.2. Exceptional Halting. The exceptional halting func-
                  The empty sequence, denoted (), is not equal to the          tion Z is deﬁned as:
               empty set, denoted ∅; this is important when interpreting       (137)
               the output of H, which evaluates to ∅ when execution is to      Z(σ,µ,I) ≡ µ <C(σ,µ,I) ∨
               continue but a series (potentially empty) when execution                        g
                                                                                              δ  =∅ ∨
                                                                                               w
               should halt.                                                                   kµ k < δw    ∨
                                                                                                 s
                                                                                              (w = JUMP      ∧ µ[0]∈/ D(I )) ∨
                                                  ′  ′                                                             s         b
               (123)        Ξ(σ,g,I,T)     ≡ (σ,µg,A,o)                                       (w = JUMPI     ∧ µ[1]6=0 ∧
                            ′  ′                           0                                                       s
               (124)     (σ ,µ,A,...,o)    ≡ X (σ,µ,A,I)                                        µ [0] ∈/ D(I ))   ∨
                                                                                                  s         b
               (125)                  µ    ≡ g                                                (w = RETURNDATACOPY∧
                                        g                                                       µ [1] +µ [2] > kµ k)     ∨
               (126)                 µ     ≡ 0                                                    s       s        o
                                       pc                                                     kµ k−δw+αw >1024∨(¬Iw∧W(w,µ))
               (127)                 µ     ≡ (0,0,...)                                           s
                                       m
               (128)                  µ ≡ 0                                    where
                                        i                                      (138)
               (129)                  µ    ≡ ()
                                        s                                         W(w,µ)≡ w∈{CREATE,SSTORE,
               (130)                  µ    ≡ ()                                                SELFDESTRUCT} ∨
                                       o
               (131)                                                                           LOG0≤w∧w≤LOG4 ∨
                                                                                              w∈{CALL,CALLCODE}∧µ [2]6=0
                                           0                                                                                 s
                                   ∅,µ,A ,I,∅          if  Z(σ,µ,I)
                                  
                                                   
                                  
                                        ′  0                                    This states that the execution is in an exceptional halt-
               X (σ,µ,A,I) ≡         ∅,µ,A ,I,o         if  w=REVERT
                                                                              ing state if there is insuﬃcient gas, if the instruction is
                                    O(σ,µ,A,I)·o        if  o6= ∅
                                  
                                                                             invalid (and therefore its δ subscript is undeﬁned), if there
                                  
                                    X O(σ,µ,A,I)        otherwise              are insuﬃcient stack items, if a JUMP/JUMPI destination
                  where                                                        is invalid, the new stack size would be larger than 1024 or
                                                                               state modiﬁcation is attempted during a static call. The as-
               (132)                  o ≡ H(µ,I)                               tute reader will realise that this implies that no instruction
               (133)       (a,b,c,d)·e    ≡ (a,b,c,d,e)                        can, through its execution, cause an exceptional halt.
                                      ′
               (134)                 µ ≡ µexcept:                              9.4.3. Jump Destination Validity. We previously used D
                                      ′
               (135)                µ     ≡ µ −C(σ,µ,I)                        as the function to determine the set of valid jump desti-
                                      g         g
                                                                               nations given the code that is being run. We deﬁne this
                  Note that, when we evaluate Ξ, we drop the fourth            as any position in the code occupied by a JUMPDEST
                         ′                                     ′
               element I and extract the remaining gas µ from the
                                                               g               instruction.
                                          ′
               resultant machine state µ .                                        All such positions must be on valid instruction bound-
                  Xis thus cycled (recursively here, but implementations       aries, rather than sitting in the data portion of PUSH
               are generally expected to use a simple iterative loop) until    operations and must appear within the explicitly deﬁned
               either Z becomes true indicating that the present state is      portion of the code (rather than in the implicitly deﬁned
               exceptional and that the machine must be halted and any         STOP operations that trail it).
               changes discarded or until H becomes a series (rather than         Formally:
               the empty set) indicating that the machine has reached a
               controlled halt.                                                (139)                D(c) ≡ DJ(c,0)
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2813
                   where:                                                         heaviest path is the block number of the leaf, equivalent
                (140)                                                            to the number of blocks, not counting the unmined genesis
                                 {}                            if  i > |c|        block, in the path. The longer the path, the greater the
                              
                              
                              
                                                                                 total mining eﬀort that must have been done in order to
                                 {i}∪D (c,N(i,c[i]))
                   D (c,i) ≡             J
                     J              if  c[i] = JUMPDEST                          arrive at the leaf. This is akin to existing schemes, such as
                              
                                                                                 that employed in Bitcoin-derived protocols.
                              
                                 D (c,N(i,c[i]))               otherwise
                                   J                                                 Since a block header includes the diﬃculty, the header
                   where N is the next valid instruction position in the          alone is enough to validate the computation done. Any
                code, skipping the data of a PUSH instruction, if any:            block contributes toward the total computation or total
                (141)                                                            diﬃculty of a chain.
                                                                                    Thus we deﬁne the total diﬃculty of block B recursively
                               i +w−PUSH1+2
                 N(i,w) ≡         if  w∈[PUSH1,PUSH32]                           as:
                            
                            
                               i +1                              otherwise        (153)                B ≡ B′+B
                                                                                                         t         t     d
                9.4.4. Normal Halting. The normal halting function H is           (154)                 B′   ≡ P(B )
                                                                                                                      H
                deﬁned:
                (142)                                                               As such given a block B, B is its total diﬃculty, B′ is
                                                                                                                 t
                             HRETURN(µ) if     w∈{RETURN,REVERT}
                                                                                 its parent block and B is its diﬃculty.
                                                                                                          d
                H(µ,I)≡ ()           if  w∈{STOP,SELFDESTRUCT}
                           
                           
                             ∅       otherwise
                   The data-returning halt operations, RETURN and
                REVERT, have a special function H               . Note also                        11. Block Finalisation
                                                        RETURN
                the diﬀerence between the empty sequence and the empty               The process of ﬁnalising a block involves four stages:
                set as discussed here.
                9.5. The Execution Cycle. Stack items are added or                     (1) Validate (or, if mining, determine) ommers;
                removed from the left-most, lower-indexed portion of the               (2) validate (or, if mining, determine) transactions;
                series; all other items remain unchanged:                              (3) apply rewards;
                                                                                      (4) verify (or, if mining, compute a valid) state and
                                                           ′   ′  ′
                (143)            O (σ,µ,A,I)        ≡ (σ,µ,A,I)                            block nonce.
                (144)                          ∆ ≡ α −δ
                                                          w    w
                                               ′
                (145)                       kµ k    ≡ kµ k+∆
                                               s           s
                                      ′      ′                                    11.1. Ommer Validation. The validation of ommer
                (146)    ∀x∈[αw,kµ k):µ [x] ≡ µ [x−∆]
                                      s      s            s                       headers means nothing more than verifying that each om-
                   The gas is reduced by the instruction’s gas cost and           mer header is both a valid header and satisﬁes the relation
                for most instructions, the program counter increments on          of Nth-generation ommertothepresentblockwhereN ≤ 6.
                each cycle, for the three exceptions, we assume a function        The maximum of ommer headers is two. Formally:
                J, subscripted by one of two instructions, which evaluates
                to the according value:                                           (155)      kB k62 ^ V(U) ∧ k(U,P(B ) ,6)
                            ′                                                                   U                                  H H
                (147)      µ    ≡ µ −C(σ,µ,I)                                                           U∈B
                            g          g                                                                    U
                                     
                                     
                                       JJUMP(µ)      if  w=JUMP
                           ′                                                        where k denotes the “is-kin” property:
                (148)     µ     ≡      JJUMPI(µ) if w =JUMPI
                           pc                                                    (156)
                                                                                                   
                                       N(µ ,w) otherwise
                                            pc                                                      
                                                                                                      false                       if n=0
                   In general, we assume the memory, self-destruct set and            k(U,H,n) ≡ 
                                                                                                      s(U,H)
                system state don’t change:                                                          
                                                                                                     ∨k(U,P(H) ,n−1) otherwise
                                         ′                                                                            H
                (149)                  µ     ≡ µ
                                         m          m
                                          ′
                (150)                   µ ≡ µ                                        and s denotes the “is-sibling” property:
                                          i         i
                                          ′                                       (157)
                (151)                   A ≡ A
                (152)                   σ′   ≡ σ                                     s(U,H) ≡ (P(H) = P(U) ∧ H 6= U ∧ U ∈/ B(H)U)
                   However, instructions do typically alter one or several        where B(H) and P(H) are the block and the parent block
                components of these values. Altered components listed by          of the corresponding header H respectively.
                instruction are noted in Appendix H, alongside values for
                α and δ and a formal description of the gas requirements.
                            10. Blocktree to Blockchain                           11.2. Transaction Validation. The given gasUsed
                                                                                  must correspond faithfully to the transactions listed: B     ,
                   The canonical blockchain is a path from root to leaf                                                                     Hg
                through the entire block tree. In order to have consensus         the total gas used in the block, must be equal to the
                over which path it is, conceptually we identify the path          accumulated gas used according to the ﬁnal transaction:
                that has had the most computation done upon it, or, the
                                                                                  (158)                   B =ℓ(R)
               heaviest path. Clearly one factor that helps determine the                                   Hg         u
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2814
               11.3. Reward Application. The application of rewards               such transaction):
               to a block involves raising the balance of the accounts of                            (Γ(B)                    if  n<0
               the beneﬁciary address of the block and each ommer by a            (170)       σ[n] =
               certain amount. We raise the block’s beneﬁciary account                                 Υ(σ[n−1],BT[n]) otherwise
               by Rblock; for each ommer, we raise the block’s beneﬁciary            In the case of B [n] , we take a similar approach deﬁn-
               by an additional 1 of the block reward and the beneﬁ-                                 R u
                                   32                                             ing each item as the gas used in evaluating the correspond-
               ciary of the ommer gets rewarded depending on the block            ing transaction summed with the previous item (or zero,
               number. Formally we deﬁne the function Ω:                          if it is the ﬁrst), giving us a running total:
               (159)                                                                                
                                                                                                    
                                                                                                      0                          if n<0
                       Ω(B,σ) ≡ σ′:σ′ =σ except:                                  (171)    R[n] = Υg(σ[n−1],B [n])
                                                                                              u                     T
                                                         kB k                                       
               (160)σ′[B     ]    = σ[B ] + 1+              U    R                                        +R[n−1]u               otherwise
                          Hc b             Hc b           32       block
                                                                                     For R[n] , we utilise the Υl function that we conve-
               (161)∀         :                                                               l
                       U∈BU           (                                           niently deﬁned in the transaction execution function.
                                        ∅ if σ[U ] = ∅ ∧ R = 0
                        σ′[U ]    =                c                              (172)          R[n] =Υl(σ[n−1],B [n])
                             c           ′                                                            l                   T
                                        a    otherwise
                                                                                     Wedeﬁne R[n] in a similar manner.
                              ′                                                                      z
               (162)         a    ≡ (σ[U ] ,σ[U ] +R,σ[U ] ,σ[U ] )
                                           c n     c b          c s     c c
                                                                                (173)          R[n] =Υz(σ[n−1],B [n])
                                            1                                                         z                   T
               (163)         R ≡        1+ (U −B ) R
                                            8    i    Hi      block                  Finally, we deﬁne Π as the new state given the block re-
                   If there are collisions of the beneﬁciary addresses be-        ward function Ω applied to the ﬁnal transaction’s resultant
               tween ommers and the block (i.e. two ommers with the               state, ℓ(σ):
               same beneﬁciary address or an ommer with the same bene-            (174)              Π(σ,B)≡Ω(B,ℓ(σ))
               ﬁciary address as the present block), additions are applied           Thus the complete block-transition mechanism is de-
               cumulatively.                                                      ﬁned, except for PoW, the proof-of-work function.
                   Wedeﬁne the block reward as 3 Ether:
                                                        18                        11.5. Mining Proof-of-Work. The mining proof-of-
               (164)              Let   Rblock = 3×10                             work (PoW) exists as a cryptographically secure nonce
                                                                                  that proves beyond reasonable doubt that a particular
               11.4. State & Nonce Validation. We may now deﬁne                   amount of computation has been expended in the deter-
               the function, Γ, that maps a block B to its initiation state:      mination of some token value n. It is utilised to enforce
               (165)      (                                                       the blockchain security by giving meaning and credence
                            σ kern10pc if    P(B )=∅
                 Γ(B) ≡      0                    H                               to the notion of diﬃculty (and, by extension, total dif-
                            σ : TRIE(L (σ )) = P(B )          otherwise           ﬁculty). However, since mining new blocks comes with
                             i          S   i         H Hr
                                                                                  an attached reward, the proof-of-work not only functions
                   Here, TRIE(L (σ )) means the hash of the root node of
                                S    i                                            as a method of securing conﬁdence that the blockchain
               a trie of state σi; it is assumed that implementations will        will remain canonical into the future, but also as a wealth
               store this in the state database, which is trivial and eﬃcient     distribution mechanism.
               since the trie is by nature an immutable data structure.              For both reasons, there are two important goals of the
                   And ﬁnally we deﬁne Φ, the block transition function,          proof-of-work function; ﬁrstly, it should be as accessible as
               which maps an incomplete block B to a complete block               possible to as many people as possible. The requirement
               B′:                                                                of, or reward from, specialised and uncommon hardware
               (166) Φ(B)     ≡ B′: B′=B∗ except:                                 should be minimised. This makes the distribution model
                                                                                  as open as possible, and, ideally, makes the act of mining a
                                             2256
               (167)    B′    = n: x6                                             simple swap from electricity to Ether at roughly the same
                          n                   H                                   rate for anyone around the world.
                                                d
               (168)    B′    = m with(x,m)=PoW(B∗,n,d)                              Secondly, it should not be possible to make super-linear
                          m                                  n
               (169)    B∗ ≡ B except: B∗=r(Π(Γ(B),B))                            proﬁts, and especially not so with a high initial barrier.
                                                   r                              Such a mechanism allows a well-funded adversary to gain
                   With d being a dataset as speciﬁed in appendix J.              a troublesome amount of the network’s total mining power
                   As speciﬁed at the beginning of the present work, Π is         and as such gives them a super-linear reward (thus skewing
               the state-transition function, which is deﬁned in terms of         distribution in their favour) as well as reducing the network
               Ω, the block ﬁnalisation function and Υ, the transaction-          security.
               evaluation function, both now well-deﬁned.                            One plague of the Bitcoin world is ASICs. These are
                   As previously detailed, R[n] , R[n] and R[n] are the           specialised pieces of compute hardware that exist only to
                                                z       l          u
               nth corresponding status code, logs and cumulative gas             do a single task (Smith [1997]). In Bitcoin’s case the task is
               used after each transaction (R[n]b, the fourth component           the SHA256 hash function (Courtois et al. [2014]). While
               in the tuple, has already been deﬁned in terms of the logs).       ASICs exist for a proof-of-work function, both goals are
               Wealso deﬁne the nth state σ[n], which is deﬁned simply            placed in jeopardy. Because of this, a proof-of-work func-
               as the state resulting from applying the corresponding             tion that is ASIC-resistant (i.e. diﬃcult or economically
               transaction to the state resulting from the previous trans-        ineﬃcient to implement in specialised compute hardware)
               action (or the block’s initial state in the case of the ﬁrst       has been identiﬁed as the proverbial silver bullet.
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2815
                   Two directions exist for ASIC resistance; ﬁrstly make          utilises the data feed—to determine how much trust can
                it sequential memory-hard, i.e. engineer the function such        be placed in any single data feed.
                that the determination of the nonce requires a lot of mem-           The general pattern involves a single contract within
                ory and bandwidth such that the memory cannot be used             Ethereum which, when given a message call, replies with
                in parallel to discover multiple nonces simultaneously. The       some timely information concerning an external phenome-
                second is to make the type of computation it would need to        non. An example might be the local temperature of New
                do general-purpose; the meaning of “specialised hardware”         York City. This would be implemented as a contract that
                for a general-purpose task set is, naturally, general purpose     returned that value of some known point in storage. Of
                hardware and as such commodity desktop computers are              course this point in storage must be maintained with the
                likely to be pretty close to “specialised hardware” for the       correct such temperature, and thus the second part of the
                task. For Ethereum 1.0 we have chosen the ﬁrst path.              pattern would be for an external server to run an Ethereum
                   More formally, the proof-of-work function takes the            node, and immediately on discovery of a new block, creates
                form of PoW:                                                      a new valid transaction, sent to the contract, updating said
                (175)                                                             value in storage. The contract’s code would accept such
                                     2256                                         updates only from the identity contained on said server.
                m=Hm ∧ n6 H                 with   (m,n) = PoW(Hn,Hn,d)
                                       d                                          12.2. Random Numbers. Providing random numbers
                   Where Hn is the new block’s header but without the             within a deterministic system is, naturally, an impossible
                nonce and mix-hash components; H is the nonce of the
                                                       n                          task. However, we can approximate with pseudo-random
                header; d is a large data set needed to compute the mix-          numbers by utilising data which is generally unknowable
                Hash and H is the new block’s diﬃculty value (i.e. the
                             d                                                    at the time of transacting. Such data might include the
                block diﬃculty from section 10). PoW is the proof-of-work         block’s hash, the block’s timestamp and the block’s beneﬁ-
                function which evaluates to an array with the ﬁrst item           ciary address. In order to make it hard for malicious miners
                being the mixHash and the second item being a pseudo-             to control those values, one should use the BLOCKHASH
                random number cryptographically dependent on H and d.             operation in order to use hashes of the previous 256 blocks
               The underlying algorithm is called Ethash and is described         as pseudo-random numbers. For a series of such numbers,
                below.                                                            a trivial solution would be to add some constant amount
                11.5.1. Ethash. Ethash is the PoW algorithm for Ethereum          and hashing the result.
               1.0. It is the latest version of Dagger-Hashimoto, intro-
                duced by Buterin [2013b] and Dryja [2014], although it                             13. Future Directions
                can no longer appropriately be called that since many of             The state database won’t be forced to maintain all past
                the original features of both algorithms were drastically         state trie structures into the future. It should maintain
                changed with R&D from February 2015 until May 4 2015              an age for each node and eventually discard nodes that
               (Jentzsch [2015]). The general route that the algorithm            are neither recent enough nor checkpoints. Checkpoints,
                takes is as follows:                                              or a set of nodes in the database that allow a particular
                   There exists a seed which can be computed for each             block’s state trie to be traversed, could be used to place a
                block by scanning through the block headers up until that         maximum limit on the amount of computation needed in
                point. From the seed, one can compute a pseudorandom              order to retrieve any state throughout the blockchain.
                cache, Jcacheinit bytes in initial size. Light clients store         Blockchain consolidation could be used in order to re-
                the cache. From the cache, we can generate a dataset,             duce the amount of blocks a client would need to download
                Jdatasetinit bytes in initial size, with the property that        to act as a full, mining, node. A compressed archive of the
                each item in the dataset depends on only a small number           trie structure at given points in time (perhaps one in every
                of items from the cache. Full clients and miners store the        10,000th block) could be maintained by the peer network,
                dataset. The dataset grows linearly with time.                    eﬀectively recasting the genesis block. This would reduce
                   Mining involves grabbing random slices of the dataset          the amount to be downloaded to a single archive plus a
                and hashing them together. Veriﬁcation can be done with           hard maximum limit of blocks.
                low memory by using the cache to regenerate the speciﬁc              Finally, blockchain compression could perhaps be con-
                pieces of the dataset that you need, so you only need to          ducted: nodes in state trie that haven’t sent/received a
                store the cache. The large dataset is updated once every          transaction in some constant amount of blocks could be
                Jepoch blocks, so the vast majority of a miner’s eﬀort will       thrown out, reducing both Ether-leakage and the growth
                be reading the dataset, not making changes to it. The             of the state database.
                mentioned parameters as well as the algorithm is explained
                in detail in appendix J.                                          13.1. Scalability. Scalability remains an eternal concern.
                                                                                  With a generalised state transition function, it becomes dif-
                             12. Implementing Contracts                           ﬁcult to partition and parallelise transactions to apply the
                   There are several patterns of contracts engineering that       divide-and-conquer strategy. Unaddressed, the dynamic
                allow particular useful behaviours; two of these that we          value-range of the system remains essentially ﬁxed and as
               will brieﬂy discuss are data feeds and random numbers.             the average transaction value increases, the less valuable of
                                                                                  them become ignored, being economically pointless to in-
                12.1. Data Feeds. A data feed contract is one which pro-          clude in the main ledger. However, several strategies exist
               vides a single service: it gives access to information from        that may potentially be exploited to provide a considerably
                the external world within Ethereum. The accuracy and              more scalable protocol.
                timeliness of this information is not guaranteed and it is           Some form of hierarchical structure, achieved by either
                the task of a secondary contract author—the contract that         consolidating smaller lighter-weight chains into the main
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2816
               block or building the main block through the incremen-           Vitalik Buterin.     EIP-100:    Change diﬃculty adjust-
               tal combination and adhesion (through proof-of-work) of            ment to target mean block time including uncles,
               smaller transaction sets may allow parallelisation of trans-       April 2016. URL https://github.com/ethereum/EIPs/
               action combination and block-building. Parallelism could           blob/master/EIPS/eip-100.md.
               also come from a prioritised set of parallel blockchains,        Nicolas T. Courtois, Marek Grajek, and Rahul Naik.
               consolidating each block and with duplicate or invalid             Optimizing SHA256 in Bitcoin Mining, pages 131–
               transactions thrown out accordingly.                               144.     Springer Berlin Heidelberg, Berlin, Heidel-
                  Finally, veriﬁable computation, if made generally avail-        berg, 2014.      ISBN 978-3-662-44893-9.        doi:   10.
               able and eﬃcient enough, may provide a route to allow the          1007/978-3-662-44893-9 12. URL https://doi.org/10.
               proof-of-work to be the veriﬁcation of ﬁnal state.                 1007/978-3-662-44893-9_12.
                                                                                B.A. Davey and H.A. Priestley. Introduction to lattices
                                    14. Conclusion                                and order. 2nd ed. Cambridge: Cambridge University
                                                                                  Press, 2nd ed. edition, 2002. ISBN 0-521-78451-4/pbk.
                  Wehave introduced, discussed and formally deﬁned the          Thaddeus Dryja.       Hashimoto:     I/O bound proof of
               protocol of Ethereum. Through this protocol the reader             work, 2014. URL http://diyhpl.us/ bryan/papers2/
                                                                                                                          ~
               may implement a node on the Ethereum network and join              bitcoin/meh/hashimoto.pdf.
               others in a decentralised secure social operating system.        Cynthia Dwork and Moni Naor.              Pricing via pro-
               Contracts may be authored in order to algorithmically              cessing or combatting junk mail.         In In 12th An-
               specify and autonomously enforce rules of interaction.             nual International Cryptology Conference, pages 139–
                                                                                  147, 1992. URL http://www.wisdom.weizmann.ac.il/
                                                                                   naor/PAPERS/pvp.pdf.
                               15. Acknowledgements                               ~
                                                                                Phong Vo Glenn Fowler, Landon Curt Noll. FowlerNol-
                  Many thanks to Aeron Buchanan for authoring the                 lVo hash function, 1991. URL http://www.isthe.com/
               Homestead revisions, Christoph Jentzsch for authoring the          chongo/tech/comp/fnv/index.html.
               Ethash algorithm and Yoichi Hirai for doing most of the          Nils Gura, Arun Patel, Arvinderpal Wander, Hans Eberle,
               EIP-150 changes. Important maintenance, useful correc-             and Sheueling Chang Shantz. Comparing elliptic curve
               tions and suggestions were provided by a number of others          cryptography and RSA on 8-bit CPUs. In Cryptographic
               from the Ethereum DEV organisation and Ethereum com-               Hardware and Embedded Systems-CHES 2004, pages
               munity at large including Gustav Simonsson, Pawe l Bylica,         119–132. Springer, 2004. URL https://www.iacr.org/
               Jutta Steiner, Nick Savers, Viktor Tr´on, Marko Simovic,           archive/ches2004/31560117/31560117.pdf.
               Giacomo Tazzari and, of course, Vitalik Buterin.                 Christoph Jentzsch. Commit date for ethash, 2015. URL
                                                                                  https://github.com/ethereum/yellowpaper/commit/
                                    16. Availability                              77a8cf2428ce245bf6e2c39c5e652ba58a278666#
                  The source of this paper is maintained at https:                commitcomment-24644869.
               //github.com/ethereum/yellowpaper/.              An auto-        Don Johnson,       Alfred   Menezes,     and Scott Van-
               generated PDF is located at https://ethereum.github.               stone.        The    Elliptic   Curve    Digital    Signa-
               io/yellowpaper/paper.pdf.                                          ture Algorithm (ECDSA), 2001.               URL https:
                                                                                  //web.archive.org/web/20170921160141/http://
                                                                                  cs.ucsb.edu/ koc/ccs130h/notes/ecdsa-cert.pdf.
                                                                                                 ~
                                      References                                  Accessed 21 September 2017, but the original link was
               Jacob Aron. BitCoin software ﬁnds new life. New Scientist,         inaccessible on 19 October 2017. Refer to section 6.2 for
                 213(2847):20, 2012. URL http://www.sciencedirect.                ECDSAPUBKEY,andsection 7 for ECDSASIGN and
                  com/science/article/pii/S0262407912601055.                      ECDSARECOVER.
               Adam Back. Hashcash - Amortizable Publicly Auditable             Sergio Demian Lerner. Strict Memory Hard Hashing Func-
                  Cost-Functions, 2002. URL http://www.hashcash.org/              tions, 2014. URL http://www.hashcash.org/papers/
                  papers/amortizable.pdf.                                         memohash.pdf.
               Guido Bertoni, Joan Daemen, Michal Peeters, Gilles Van           Mark Miller.         The Future of Law.             In   pa-
                 Assche, and Ronny Van Keer. KECCAK, 2017. URL                    per delivered at the Extro 3 Conference (August
                  https://keccak.team/keccak.html.                                9), 1997.    URL https://drive.google.com/file/d/
               Roman Boutellier and Mareike Heinzen. Pirates, Pio-                0Bw0VXJKBgYPMS0J2VGIyWWlocms/edit?usp=sharing.
                  neers, Innovators and Imitators. In Growth Through            Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash
                 Innovation, pages 85–96. Springer, 2014. URL https:              system, 2008. URL http://www.bitcoin.org/bitcoin.
                 //www.springer.com/gb/book/9783319040158.                        pdf.
               Vitalik Buterin. Ethereum: A Next-Generation Smart               Meni Rosenfeld, Yoni Assia, Vitalik Buterin, m li-
                  Contract and Decentralized Application Platform,                orhakiLior, Oded Leiba, Assaf Shomer, and Eli-
                 2013a.     URL https://github.com/ethereum/wiki/                 ran Zach.       Colored Coins Protocol Speciﬁcation,
                 wiki/White-Paper.                                                2012.      URL https://github.com/Colored-Coins/
               Vitalik Buterin. Dagger: A Memory-Hard to Compute,                 Colored-Coins-Protocol-Specification.
                  Memory-Easy to Verify Scrypt Alternative, 2013b. URL          Afri Schoedon and Vitalik Buterin. EIP-649: Metropo-
                  http://www.hashcash.org/papers/dagger.html.                     lis diﬃculty bomb delay and block reward reduction,
               Vitalik Buterin. EIP-2: Homestead hard-fork changes,               June 2017. URL https://github.com/ethereum/EIPs/
                 2015.      URL https://github.com/ethereum/EIPs/                 blob/master/EIPS/eip-649.md.
                  blob/master/EIPS/eip-2.md.
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2817
               Michael John Sebastian Smith.        Application-Speciﬁc      Nick Szabo.        Formalizing and securing relation-
                 Integrated Circuits.   Addison-Wesley, 1997.      ISBN        ships on public networks.        First Monday, 2(9),
                 0201500221.                                                   1997. URL http://firstmonday.org/ojs/index.php/
               Yonatan Sompolinsky and Aviv Zohar. Accelerating bit-           fm/article/view/548.
                 coin’s transaction processing. fast money grows on trees,   Vivek Vishnumurthy, Sangeeth Chandrakumar, and
                 not chains, 2013.    URL https://eprint.iacr.org/             Emin Gn Sirer. KARMA: A secure economic framework
                 2013/881.                                                     for peer-to-peer resource sharing, 2003. URL https://
               Simon Sprankel. Technical Basis of Digital Currencies,          www.cs.cornell.edu/people/egs/papers/karma.pdf.
                 2013.   URL http://www.coderblog.de/wp-content/             J. R. Willett. MasterCoin Complete Speciﬁcation, 2013.
                 uploads/technical-basis-of-digital-currencies.                URLhttps://github.com/mastercoin-MSC/spec.
                 pdf.
                                                            Appendix A. Terminology
                    External Actor: A person or other entity able to interface to an Ethereum node, but external to the world of
                       Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain
                       and associated state. Has one (or more) intrinsic Accounts.
                    Address: A 160-bit code used for identifying Accounts.
                    Account: Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state.
                       They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them.
                       Though homogenous, it makes sense to distinguish between two practical types of account: those with empty
                       associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with
                       non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a
                       single Address that identiﬁes it.
                    Transaction: A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous
                       Object. Transactions are recorded into each block of the blockchain.
                    Autonomous Object: A notional object existent only within the hypothetical state of Ethereum. Has an intrinsic
                       address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated
                       only as the Storage State of that account.
                    Storage State: The information particular to a given Account that is maintained between the times that the
                       Account’s associated EVM Code runs.
                    Message: Data (as a set of bytes) and Value (speciﬁed as Ether) that is passed between two Accounts, either
                       through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the
                       Transaction.
                    Message Call: The act of passing a message from one Account to another. If the destination account is associated
                       with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted
                       upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM
                       operation.
                    Gas: The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely to
                       and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price is
                       set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.
                    Contract: Informal term used to mean both a piece of EVM Code that may be associated with an Account or an
                       Autonomous Object.
                    Object: Synonym for Autonomous Object.
                    App: An end-user-visible application hosted in the Ethereum Browser.
                    Ethereum Browser: (aka Ethereum Reference Client) A cross-platform GUI of an interface similar to a simpliﬁed
                       browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum
                       protocol.
                    Ethereum Virtual Machine: (aka EVM) The virtual machine that forms the key part of the execution model
                       for an Account’s associated EVM Code.
                    Ethereum Runtime Environment: (aka ERE) The environment which is provided to an Autonomous Object
                       executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for
                       certain I/O instructions including CALL & CREATE.
                    EVMCode: The bytecode that the EVM can natively execute. Used to formally specify the meaning and
                       ramiﬁcations of a message to an Account.
                    EVMAssembly: The human-readable form of EVM-code.
                    LLL: The Lisp-like Low-level Language, a human-writable language used for authoring simple contracts and general
                       low-level language toolkit for trans-compiling to.
                                                     Appendix B. Recursive Length Prefix
                  This is a serialisation method for encoding arbitrarily structured binary data (byte arrays).
                    ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2818
                      Wedeﬁne the set of possible structures T:
                  (176)                                     T ≡ L∪B
                  (177)                                     L ≡ {t:t=(t[0],t[1],...) ∧ ∀                      t[n] ∈ T}
                                                                                                      n<ktk
                  (178)                                     B ≡ {b:b=(b[0],b[1],...) ∧ ∀                        b[n] ∈ O}
                                                                                                        n<kbk
                      Where O is the set of (8-bit) bytes. Thus B is the set of all sequences of bytes (otherwise known as byte-arrays, and a
                  leaf if imagined as a tree), L is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if imagined
                  as a tree) and T is the set of all byte-arrays and such structural sequences.
                      Wedeﬁne the RLP function as RLP through two sub-functions, the ﬁrst handling the instance when the value is a byte
                  array, the second when it is a sequence of further values:
                                                                                      (
                  (179)                                                   RLP(x) ≡      Rb(x) if x∈B
                                                                                        Rl(x)     otherwise
                      If the value to be serialised is a byte-array, the RLP serialisation takes one of three forms:
                         • If the byte-array contains solely a single byte and that single byte is less than 128, then the input is exactly equal
                            to the output.
                         • If the byte-array contains fewer than 56 bytes, then the output is equal to the input preﬁxed by the byte equal to
                            the length of the byte array plus 128.
                         • Otherwise, the output is equal to the input preﬁxed by the minimal-length byte-array which when interpreted as
                            a big-endian integer is equal to the length of the input byte array, which is itself preﬁxed by the number of bytes
                            required to faithfully encode this length value plus 183.
                      Formally, we deﬁne Rb:
                                                                     
                                                                     
                                                                       x                                         if  kxk = 1∧x[0] < 128
                  (180)                              R (x)     ≡ 
                                                       b               (128+kxk)·x                               else if   kxk < 56
                                                                                         
                                                                                             
                                                                                         
                                                                         183+ BE(kxk)          · BE(kxk) · x     otherwise
                                                                                                   n<kbk
                                                                                                     X              kbk−1−n
                  (181)                               BE(x)    ≡ (b0,b1,...) : b0 6= 0 ∧ x =               bn · 256
                                                                                                     n=0
                  (182)                 (a) · (b,c) · (d,e)    = (a,b,c,d,e)
                      Thus BE is the function that expands a non-negative integer value to a big-endian byte array of minimal length and
                  the dot operator performs sequence concatenation.
                      If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:
                         • If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal
                            to that concatenation preﬁxed by the byte equal to the length of this byte array plus 192.
                         • Otherwise, the output is equal to the concatenated serialisations preﬁxed by the minimal-length byte-array which
                            when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte array, which
                            is itself preﬁxed by the number of bytes required to faithfully encode this length value plus 247.
                      Thus we ﬁnish by formally deﬁning Rl:
                                                              ((192+ks(x)k)·s(x)                                     if  ks(x)k < 56
                  (183)                        Rl(x)     ≡                              
                                                                                        
                                                                  247+ BE(ks(x)k)           · BE(ks(x)k) · s(x)      otherwise
                  (184)                          s(x)    ≡ RLP(x )·RLP(x )...
                                                                      0          1
                      If RLP is used to encode a scalar, deﬁned only as a non-negative integer (N or any x for Nx), it must be speciﬁed as
                  the shortest byte array such that the big-endian interpretation of it is equal. Thus the RLP of some non-negative integer
                  i is deﬁned as:
                  (185)                                                     RLP(i : i ∈ N) ≡ RLP(BE(i))
                      When interpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte
                  sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP data,
                  dismissing it completely.
                      There is no speciﬁc canonical encoding format for signed or ﬂoating-point values.
                                                                    Appendix C. Hex-Prefix Encoding
                      Hex-preﬁx encoding is an eﬃcient method of encoding an arbitrary number of nibbles as a byte array. It is able to
                  store an additional ﬂag which, when used in the context of the trie (the only context in which it is used), disambiguates
                  between node types.
                      It is deﬁned as the function HP which maps from a sequence of nibbles (represented by the set Y) together with a
                  boolean value to a sequence of bytes (represented by the set B):
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2819
               (186)          HP(x,t) : x ∈ Y   ≡ ((16f(t),16x[0]+x[1],16x[2]+x[3],...)                      if  kxk is even
                                                      (16(f(t) +1)+x[0],16x[1]+x[2],16x[3]+x[4],...)         otherwise
               (187)                     f(t)   ≡ (2 if t6=0
                                                      0   otherwise
                  Thus the high nibble of the ﬁrst byte contains two ﬂags; the lowest bit encoding the oddness of the length and the
               second-lowest encoding the ﬂag t. The low nibble of the ﬁrst byte is zero in the case of an even number of nibbles and the
               ﬁrst nibble in the case of an odd number. All remaining nibbles (now an even number) ﬁt properly into the remaining
               bytes.
                                                   Appendix D. Modified Merkle Patricia Tree
                  The modiﬁed Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary
               data (byte arrays). It is deﬁned in terms of a mutable data structure to map between 256-bit binary fragments and
               arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms
               of the protocol speciﬁcation is to provide a single value that identiﬁes a given set of key-value pairs, which may be either
               a 32-byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the
               structure of the trie in a manner that allows eﬀective and eﬃcient realisation of the protocol.
                  Formally, we assume the input value I, a set containing pairs of byte sequences with unique keys:
               (188)                                   I = {(k ∈ B,v ∈ B),(k ∈ B,v ∈ B),...}
                                                               0       0         1       1
                  When considering such a sequence, we use the common numeric subscript notation to refer to a tuple’s key or value,
               thus:
               (189)                                                 ∀    I ≡ (I ,I )
                                                                       I∈I      0   1
                  Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-speciﬁc notation; here we assume
               big-endian. Thus:
                                                                            ′                 ′
               (190)                                         y(I)   = {(k ∈Y,v ∈B),(k ∈Y,v ∈B),...}
                                                                        ( 0         0         1       1
                                                                          ⌊k [i÷2]÷16⌋          if i is even
               (191)                       ∀    ∀           k′ [i]  ≡       n
                                            n    i:i<2kk k    n
                                                       n                  k [⌊i÷2⌋] mod 16 otherwise
                                                                           n
                  We deﬁne the function TRIE, which evaluates to the root of the trie that represents this set when encoded in this
               structure:
               (192)                                              TRIE(I) ≡ KEC(c(I,0))
                  We also assume a function n, the trie’s node cap function. When composing a node, we use RLP to encode the
               structure. As a means of reducing storage complexity, for nodes whose composed RLP is fewer than 32 bytes, we store
               the RLP directly; for those larger we assert prescience of the byte array whose Keccak hash evaluates to our reference.
               Thus we deﬁne in terms of c, the node composition function:
                                                                 
                                                                 
                                                                   ()            if  I = ∅
               (193)                                    n(I,i) ≡ 
                                                                   c(I,i)        if  kc(I,i)k < 32
                                                                 
                                                                 
                                                                   KEC(c(I,i))   otherwise
                  In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value pair.
               The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a radix tree).
               Unlike a radix tree, in the case of multiple keys sharing the same preﬁx or in the case of a single key having a unique
               suﬃx, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles from each
               of the other two node types, extension and leaf. There are three kinds of nodes in the trie:
                     Leaf: A two-item structure whose ﬁrst item corresponds to the nibbles in the key not already accounted for by the
                        accumulation of keys and branches traversed from the root. The hex-preﬁx encoding method is used and the
                        second parameter to the function is required to be true.
                     Extension: A two-item structure whose ﬁrst item corresponds to a series of nibbles of size greater than one that
                        are shared by at least two distinct keys past the accumulation of the keys of nibbles and the keys of branches as
                        traversed from the root. The hex-preﬁx encoding method is used and the second parameter to the function is
                        required to be false.
                     Branch: A 17-item structure whose ﬁrst sixteen items correspond to each of the sixteen possible nibble values for
                        the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and
                        thus a key being ended at this point in its traversal.
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2820
                  Abranch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We
               may formally deﬁne this structure with the structural composition function c:
               (194)                                        
                                                            
                          RLP   HP(I [i..(kI k − 1)],true),I        if  kIk = 1   where ∃I : I ∈ I
                                    0      0               1
                                                              
                                                              
                        
                        
                        
                          RLP   HP(I [i..(j − 1)],false),n(I,j)     if  i 6= j where j = max{x : ∃l : klk = x∧∀        : I [0..(x − 1)] = l}
                                   0                                                                            I∈I   0
               c(I,i) ≡   RLP (u(0),u(1),...,u(15),v)               otherwise   where u(j)    ≡ n({I : I ∈ I∧I [i] = j},i+1)
                                                                                                  (              0
                        
                        
                        
                                                                                                    I   if  ∃I : I ∈ I ∧ kI k = i
                                                                                                     1                    0
                                                                                          v  =
                                                                                                    ()  otherwise
               D.1. Trie Database. Thus no explicit assumptions are made concerning what data is stored and what is not, since
               that is an implementation-speciﬁc consideration; we simply deﬁne the identity function mapping the key-value set I
               to a 32-byte hash and assert that only a single such hash exists for any I, which though not strictly true is accurate
               within acceptable precision given the Keccak hash’s collision resistance. In reality, a sensible implementation will not fully
               recompute the trie root hash for each set.
                  Areasonable implementation will maintain a database of nodes determined from the computation of various tries or,
               more formally, it will memoise the function c. This strategy uses the nature of the trie to both easily recall the contents of
               any previous key-value set and to store multiple such sets in a very eﬃcient manner. Due to the dependency relationship,
               Merkle-proofs may be constructed with an O(logN) space requirement that can demonstrate a particular leaf must exist
               within a trie of a given root hash.
                                                       Appendix E. Precompiled Contracts
                  For each precompiled contract, we make use of a template function, ΞPRE, which implements the out-of-gas checking.
                                                                      (        0
                                                                        (∅,0,A ,())        if  g < g
               (195)                                Ξ (σ,g,I,T)≡                                    r
                                                     PRE                            0
                                                                        (σ,g −gr,A ,o) otherwise
                  The precompiled contracts each use these deﬁnitions and provide speciﬁcations for the o (the output data) and gr, the
               gas requirements.
                  We deﬁne Ξ        as a precompiled contract for the elliptic curve digital signature algorithm (ECDSA) public key
                               ECREC
               recovery function (ecrecover). See Appendix F for the deﬁnition of the function ECDSARECOVER. We also deﬁne d to be
               the input data, well-deﬁned for an inﬁnite length by appending zeroes as required. In the case of an invalid signature
               (ECDSARECOVER(h,v,r,s) = ∅), we return no output.
               (196)                                Ξ       ≡ Ξ        where:
                                                     ECREC        PRE
               (197)                                   gr   = 3000
               (198)                                   |o|  = (0 if ECDSARECOVER(h,v,r,s)=∅
                                                                  32   otherwise
               (199)                        if  |o| = 32 :
               (200)                              o[0..11]  = 0                              
               (201)                             o[12..31]  = KEC ECDSARECOVER(h,v,r,s) [12..31]        where:
               (202)                       d[0..(|I | − 1)] = I
                                                  d              d
               (203)                              d[|I |..] = (0,0,...)
                                                     d
               (204)                                    h = d[0..31]
               (205)                                    v   = d[32..63]
               (206)                                    r   = d[64..95]
               (207)                                    s   = d[96..127]
                  Wedeﬁne Ξ         and Ξ       as precompiled contracts implementing the SHA2-256 and RIPEMD-160 hash functions
                              SHA256      RIP160
               respectively. Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2821
                (208)                                               ΞSHA256   ≡ ΞPRE where:
                                                                                           l|I |m
                (209)                                                    g    = 60+12 d
                                                                          r                   32
                (210)                                              o[0..31]   = SHA256(Id)
                (211)                                               ΞRIP160   ≡ ΞPRE where:
                                                                                              l|I |m
                (212)                                                    g    = 600+120          d
                                                                          r                     32
                (213)                                              o[0..11]   = 0
                (214)                                             o[12..31]   = RIPEMD160(I )
                                                                                                 d
                    For the purposes here, we assume we have well-deﬁned standard cryptographic functions for RIPEMD-160 and
                SHA2-256 of the form:
                (215)                                                 SHA256(i ∈ B)     ≡ o∈B
                                                                                                   32
                (216)                                             RIPEMD160(i ∈ B)      ≡ o∈B
                                                                                                   20
                    The fourth contract, the identity function Ξ        simply deﬁnes the output as the input:
                                                                     ID
                (217)                                                  Ξ     ≡ Ξ         where:
                                                                        ID          PRE
                                                                                         l|I |m
                (218)                                                   g    = 15+3 d
                                                                         r                 32
                (219)                                                    o = I
                                                                                   d
                                                                                                                  0
                    The ﬁfth contract performs arbitrary-precision exponentiation under modulo. Here, 0 is taken to be one, and x mod 0
                is zero for all x. The ﬁrst word in the input speciﬁes the number of bytes that the ﬁrst non-negative integer B occupies.
                The second word in the input speciﬁes the number of bytes that the second non-negative integer E occupies. The third
                word in the input speciﬁes the number of bytes that the third non-negative integer M occupies. These three words are
                followed by B, E and M. The rest of the input is discarded. Whenever the input is too short, the missing bytes are
                considered to be zero. The output is encoded big-endian into the same format as M’s.
                (220)     ΞEXPMOD   ≡ ΞPRE except:
                                         $                         ′     %
                                           f max(ℓ ,ℓ ) max(ℓ ,1)
                (221)          g    =                M B            E
                                r                   G
                                                      quaddivisor
                                          2
                                         
                                           x                           if x ≤ 64
                                         
                                         
                                         
                                               
                                          2
                                         
                (222)       f(x)    ≡  x +96x−3072                    if 64 < x ≤ 1024
                                          4
                                         
                                               
                                          2
                                         
                                          x
                                         
                                          16 +480x−199680 otherwise
                                         
                                           0                                                   if ℓ  ≤32∧E=0
                                                                                                  E
                                         
                                         
                                         
                                ′          ⌊log2(E)⌋                                           if ℓE ≤ 32 ∧ E 6= 0
                (223)         ℓ     =
                                E        
                                           8(ℓ   −32)+⌊log (i[(96+ℓ )..(127+ℓ )])⌋ if 32 < ℓ ∧i[(96+ℓ )..(127+ℓ )] 6= 0
                                          E                  2           B            B                 E             B            B
                                         
                                         
                                           8(ℓ   −32)                                          otherwise
                                              E
                (224)           o = BEmodM∈N8ℓM
                (225)         ℓ     ≡ i[0..31]
                               B
                (226)         ℓ     ≡ i[32..63]
                                E
                (227)         ℓ     ≡ i[64..95]
                               M
                (228)          B ≡ i[96..(95+ℓ )]
                                                      B
                (229)          E ≡ i[(96+ℓ )..(95+ℓ +ℓ )]
                                                  B           B     E
                (230)         M ≡ i[(96+ℓ +ℓ )..(95+ℓ +ℓ +ℓ )]
                                         (        B     E           B     E     M
                                           I [x]   if x < |I |
                (231)        i[x]   ≡       d               d
                                           0       otherwise
                E.1. zkSNARK Related Precompiled Contracts. We choose two numbers, both of which are prime.
                (232)         p   ≡ 21888242871839275222246405745257275088696311157297823662689037894645226208583
                (233)         q   ≡ 21888242871839275222246405745257275088548364400416034343698204186575808495617
                Since p is a prime number, {0,1,...,p−1} forms a ﬁeld with addition and multiplication modulo p. We call this ﬁeld Fp.
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2822
                  Wedeﬁne a set C1 with
               (234)                                C ≡{(X,Y)∈F ×F |Y2=X3+3}∪{(0,0)}
                                                     1                p     p
               Wedeﬁne a binary operation + on C for distinct elements (X ,Y ),(X ,Y ) with
                                                      1                          1   1     2  2
                                                                                (
               (235)                                 (X ,Y )+(X ,Y ) ≡            (X,Y) if X1 6= X2
                                                        1  1       2   2          (0,0)    otherwise
                                                                                 Y −Y
                                                                       λ ≡        2    1
                                                                                X −X
                                                                                  2     1
                                                                                 2
                                                                       X ≡ λ −X −X
                                                                                       1     2
                                                                       Y   ≡ λ(X1−X)−Y1
                  In the case where (X ,Y ) = (X ,Y ), we deﬁne + on C with
                                        1   1       2   2                    1
                                                                                 (
                                                                                   (X,Y) if Y 6= 0
               (236)                                  (X ,Y )+(X ,Y ) ≡                        1
                                                         1  1       2   2          (0,0)    otherwise
                                                                                 3X2
                                                                        λ ≡         1
                                                                                 2Y
                                                                                    1
                                                                                  2
                                                                       X ≡ λ −2X1
                                                                        Y   ≡ λ(X −X)−Y
                                                                                     1          1
                  (C1,+) is known to form a group. We deﬁne scalar multiplication · with
               (237)                                            n·P ≡(0,0)+P +···+P
                                                                                |    {z    }
                                                                                      n
               for a natural number n and a point P in C1.
                  Wedeﬁne P to be a point (1,2) on C . Let G be the subgroup of (C ,+) generated by P . G is known to be a
                               1                           1         1                        1                     1    1
               cyclic group of order q. For a point P in G , we deﬁne log    (P) to be the smallest natural number n satisfying n·P = P.
                                                           1               P1                                                          1
               logP (P) is at most q −1.
                    1
                  Let F    be a ﬁeld F [i]/(i2 + 1). We deﬁne a set C with
                         2             p                                2
                        p
               (238)                          C2 ≡{(X,Y)∈F 2 ×F 2 |Y2 =X3+3(i+9)−1}∪{(0,0)}
                                                                 p     p
               Wedeﬁne a binary operation + and scalar multiplication · with the same equations (235), (236) and (237). (C2,+) is also
               known to be a group. We deﬁne P in C with
                                                   2      2
               (239)     P    ≡ (11559732032986387107991004021392285783925812861821192530917403151452391805634×i
                          2
                                  +10857046999023057135944570762232829481370756359578518086990519993285655852781,
                                  4082367875863433681332203403145435568316851327593401208105741076214120093531×i
                                  +8495653923123431417604973247489272438418190587263600148770280649306958101930)
               Wedeﬁne G to be the subgroup of (C ,+) generated by P . G is known to be the only cyclic group of order q on C .
                            2                           2                     2   2                                                         2
               For a point P in G , we deﬁne log      (P) be the smallest natural number n satisfying n·P = P. With this deﬁnition,
                                    2               P2                                                         2
               logP (P) is at most q −1.
                    2
                  Let G     be the multiplicative abelian group underlying F 12. It is known that a non-degenerate bilinear map
                         T                                                        q
               e : G ×G →G exists. This bilinear map is a type three pairing. There are several such bilinear maps, it does not
                    1     2      T
               matter which is chosen to be e. Let P      =e(P ,P ), a be a set of k points in G , and b be a set of k points in G . It
                                                        T        1  2                               1                                   2
               follows from the deﬁnition of a pairing that the following are equivalent
               (240)                       log  (a ) ×log    (b ) + ··· + log  (a )×log (b )       ≡ 1 modq
                                              P    1       P   1             P   k       P    k
                                               1            2                 1            2
                                                                                     k
               (241)                                                                Ye(a,b) = P
                                                                                           i  i          T
                                                                                    i=0
               Thus the pairing operation provides a method to verify (240).
                  A32byte number x ∈ P256 might and might not represent an element of Fp.
                                                                          (
               (242)                                             δ (x) ≡    x if x < p
                                                                   p        ∅ otherwise
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2823
                   A64byte data x ∈ B          might and might not represent an element of G .
                                           512                          (                         1
                (243)                                       δ1(x)   ≡     g1   if g1 ∈ G1
                                                                          ∅ otherwise
                                                                        (
                (244)                                          g1   ≡     (x,y)    if x 6= ∅ ∧ y 6= ∅
                                                                          ∅        otherwise
                (245)                                           x ≡ δ (x[0..31])
                                                                          p
                (246)                                           y   ≡ δ (x[32..63])
                                                                          p
                   A128 byte data x ∈ B          might and might not represent an element of G .
                                            1024    (                                               2
                (247)                  δ2(x)   ≡      g2   if g2 ∈ G2
                                                      ∅ otherwise
                                                    (
                                                      ((x i +y ),(x i+y ))       if x 6= ∅∧y 6= ∅∧x 6= ∅∧y 6= ∅
                (248)                     g    ≡         0     0     1     1        0          0         1         1
                                           2          ∅                          otherwise
                (249)                     x    ≡ δ (x[0..31])
                                           0         p
                (250)                     y    ≡ δ (x[32..63])
                                           0         p
                (251)                     x    ≡ δ (x[64..95])
                                           1         p
                (252)                     y    ≡ δ (x[96..127])
                                           1         p
                   Wedeﬁne ΞSNARKV as a precompiled contract which checks if (240) holds, for intended use in zkSNARK veriﬁcation.
                (253)          Ξ        ≡ Ξ         except:
                                SNARKV        PRE        
                                                     0
                (254) ΞSNARKV(σ,g,I)    = ∅,0,A ,()          if F
                (255)               F ≡ (|I |mod1926=0∨(∃j. a =∅∨b =∅))
                                                d                        j         j
                                             |I |
                (256)               k   =      d
                                             192
                (257)               gr  = 60000k+40000
                (258)         o[0..31]  ≡ (0x0000000000000000000000000000000000000000000000000000000000000001 if v∧¬F
                                               0x0000000000000000000000000000000000000000000000000000000000000000 if ¬v ∧¬F
                (259)               v   ≡ (logP (a1)×logP (b1)+···+logP (ak)×logP (bk) ≡ 1 mod q)
                                                  1            2                  1            2
                (260)              a1   ≡ δ1(I [0..63])
                                                 d
                (261)               b1  ≡ δ2(I [64..191])
                                                 d
                                     .
                                     .
                                     .
                (262)              a    ≡ δ1(I [(|I |−192)..(|I |−129)])
                                    k            d    d             d
                (263)              b    ≡ δ2(I [(|I |−128)..(|I |−1)])
                                    k            d    d             d
                   Wedeﬁne a precompiled contract for addition on G .
                                                                           1
                (264)                             ΞBN ADD   ≡ ΞBNPRE except:
                                                                         0   
                (265)                     ΞBN ADD(σ,g,I)    = ∅,0,A ,()          if x = ∅∨y = ∅
                (266)                                  gr   = 500
                (267)                                   o ≡ δ−1(x+y) where + is the group operation in G1
                                                                  1          
                                                                    ¯
                (268)                                   x ≡ δ I [0..63]
                                                                  1   d         
                                                                    ¯
                (269)                                   y   ≡ δ I [64..127]
                                                                  1  d
                                                                (
                                                                  I [x]   if x < |I |
                                                    ¯              d               d
                (270)                               I [x]   ≡
                                                     d            0       otherwise
                                                                                                  ¯
                   Wedeﬁne a precompiled contract for scalar multiplication on G , where I is deﬁned in (270).
                                                                                        1          d
                (271)                            ΞBN MUL   ≡ ΞPRE except:
                                                                       0    
                (272)                    ΞBN MUL(σ,g,I)    = ∅,0,A ,()          if x = ∅
                (273)                                 gr   = 40000
                (274)                                 o ≡ δ−1(n·x) where · is the scalar multiplication in G
                                                                1                                                      1
                                                               ¯
                (275)                                 n ≡ I [0..31]
                                                                d            
                                                                   ¯
                (276)                                 x ≡ δ I [32..95]
                                                                1   d
                   ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2824
                                                                Appendix F. Signing Transactions
                    Transactions are signed using recoverable ECDSA signatures. This method utilises the SECP-256k1 curve as described
                 by Courtois et al. [2014], and is implemented similarly to as described by Gura et al. [2004] on p. 9 of 15, para. 3.
                    It is assumed that the sender has a valid private key p , which is a randomly selected positive integer (represented as a
                                                                                   r
                 byte array of length 32 in big-endian form) in the range [1,secp256k1n−1].
                    Weassume the existence of functions ECDSAPUBKEY, ECDSASIGN and ECDSARECOVER. These are formally deﬁned in the
                 literature, e.g. by Johnson et al. [2001].
                 (277)                                               ECDSAPUBKEY(p ∈ B )           ≡ p ∈B
                                                                                       r     32          u      64
                 (278)                                        ECDSASIGN(e ∈ B ,p ∈ B )             ≡ (v∈B ,r∈B ,s∈B )
                                                                                  32   r     32                1        32        32
                 (279)                   ECDSARECOVER(e ∈ B ,v ∈ B ,r ∈ B ,s ∈ B )                 ≡ p ∈B
                                                                 32       1        32        32          u      64
                    Where p is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive
                               u
                                      256
                 integers each < 2       ), pr is the private key, a byte array of size 32 (or a single positive integer in the aforementioned
                 range) and e is the hash of the transaction, h(T). It is assumed that v is the ‘recovery identiﬁer’. The recovery identiﬁer
                 is a 1 byte value specifying the parity and ﬁniteness of the coordinates of the curve point for which r is the x-value; this
                 value is in the range of [27,30], however we declare the upper two possibilities, representing inﬁnite values, invalid. The
                 value 27 represents an even y value and 28 represents an odd y value.
                                                                                                                              5
                    Wedeclare that an ECDSA signature is invalid unless all the following conditions are true :
                 (280)                                                 0 < r < secp256k1n
                 (281)                                                 0 < s < secp256k1n÷2+1
                 (282)                                                     v ∈ {27,28}
                 where:
                 (283)       secp256k1n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
                    For a given private key, p , the Ethereum address A(p ) (a 160-bit value) to which it corresponds is deﬁned as the
                                                   r                                 r
                 right most 160-bits of the Keccak hash of the corresponding ECDSA public key:
                                                                                                            
                 (284)                                          A(p ) = B          KEC ECDSAPUBKEY(p )
                                                                    r      96..255                        r
                    The message hash, h(T), to be signed is the Keccak hash of the transaction. Two diﬀerent ﬂavors of signing schemes
                 are available. One operates without the latter three signature components, formally described as T , T and T . The
                                                                                                                                        r   s        w
                 other operates on nine elements:
                 (285)                         L (T) ≡ ((Tn,Tp,Tg,Tt,Tv,p)                                    if v ∈ {27,28}
                                                 S               (T ,T ,T ,T ,T ,p,chain id,(),())            otherwise
                                                                    n   p   g   t  v
                                                where          (
                                                                 T     if Tt = 0
                                                     p ≡          i
                                                                 T     otherwise
                                                                  d
                 (286)                           h(T)     ≡ KEC(LS(T))
                    The signed transaction G(T,p ) is deﬁned as:
                                                        r
                 (287)                                                        G(T,p ) ≡ T       except:
                                                                                      r
                 (288)                                          (T ,T ,T ) = ECDSASIGN(h(T),p )
                                                                   w r s                              r
                    Reiterating from previously:
                 (289)                                                          T =r
                                                                                  r
                 (290)                                                          T =s
                                                                                  s
                 Tw is either the recovery identiﬁer or ‘chain identiﬁer doubled plus 35 or 36’. In the second case, where v is the chain
                 identiﬁer doubled plus 35 or 36, the values 35 and 36 assume the role of the ‘recovery identiﬁer’ by specifying the parity
                 of y, with the value 35 representing an even value and 36 representing an odd value.
                    Wemaythen deﬁne the sender function S of the transaction as:
                                                                                                                      
                 (291)                                S(T) ≡ B               KEC ECDSARECOVER(h(T),v ,T ,T )
                                                                     96..255                                0   r   s
                                                                   (
                                                                      T                     if T  ∈{27,28}
                 (292)                                   v    ≡        w                        w
                                                          0           28−(T mod2) otherwise
                                                                              w
                    The assertion that the sender of a signed transaction equals the address of the signer should be self-evident:
                 (293)                                                ∀T : ∀p : S(G(T,p )) ≡ A(p )
                                                                              r             r          r
                    5
                      Asignature of a transaction can be valid not only with a recovery identiﬁer but with some other numbers. See how the component Tw
                 of a transaction is interpreted.
                ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2825
                                                           Appendix G. Fee Schedule
                 The fee schedule G is a tuple of 31 scalar values corresponding to the relative costs, in gas, of a number of abstract
              operations that a transaction may eﬀect.
                   Name            Value   Description*
                   G                    0  Nothing paid for operations of the set W    .
                    zero                                                           zero
                   G                    2  Amount of gas to pay for operations of the set W    .
                    base                                                                    base
                   G                    3  Amount of gas to pay for operations of the set W        .
                    verylow                                                                 verylow
                   G                    5  Amount of gas to pay for operations of the set W    .
                    low                                                                     low
                   G                    8  Amount of gas to pay for operations of the set W    .
                    mid                                                                     mid
                   G                  10   Amount of gas to pay for operations of the set W    .
                    high                                                                    high
                   G                 700   Amount of gas to pay for operations of the set W       .
                    extcode                                                                 extcode
                   G                 400   Amount of gas to pay for a BALANCE operation.
                    balance
                   G                 200   Paid for a SLOAD operation.
                    sload
                   G                    1  Paid for a JUMPDEST operation.
                    jumpdest
                   G               20000   Paid for an SSTORE operation when the storage value is set to non-zero from zero.
                    sset
                   G                5000   Paid for an SSTORE operation when the storage value’s zeroness remains unchanged or
                    sreset
                                           is set to zero.
                   Rsclear         15000   Refund given (added into refund counter) when the storage value is set to zero from
                                           non-zero.
                   Rselfdestruct   24000   Refund given (added into refund counter) for self-destructing an account.
                   G                5000   Amount of gas to pay for a SELFDESTRUCT operation.
                    selfdestruct
                   G               32000   Paid for a CREATE operation.
                    create
                   G                 200   Paid per byte for a CREATE operation to succeed in placing code into state.
                    codedeposit
                   G                 700   Paid for a CALL operation.
                    call
                   G                9000   Paid for a non-zero value transfer as part of the CALL operation.
                    callvalue
                   G                2300   Astipend for the called contract subtracted from G          for a non-zero value transfer.
                    callstipend                                                               callvalue
                   G               25000   Paid for a CALL or SELFDESTRUCT operation which creates an account.
                    newaccount
                   G                  10   Partial payment for an EXP operation.
                    exp
                   G                  50   Partial payment when multiplied by ⌈log    (exponent)⌉ for the EXP operation.
                    expbyte                                                         256
                   G                    3  Paid for every additional word when expanding memory.
                    memory
                   G               32000   Paid by all contract-creating transactions after the Homestead transition.
                    txcreate
                   G                    4  Paid for every zero byte of data or code for a transaction.
                    txdatazero
                   G                  68   Paid for every non-zero byte of data or code for a transaction.
                    txdatanonzero
                   G               21000   Paid for every transaction.
                    transaction
                   G                 375   Partial payment for a LOG operation.
                    log
                   G                    8  Paid for each byte in a LOG operation’s data.
                    logdata
                   G                 375   Paid for each topic of a LOG operation.
                    logtopic
                   G                  30   Paid for each SHA3 operation.
                    sha3
                   G                    6  Paid for each word (rounded up) for input data to a SHA3 operation.
                    sha3word
                   G                    3  Partial payment for *COPY operations, multiplied by words copied, rounded up.
                    copy
                   G                  20   Payment for BLOCKHASH operation.
                    blockhash
                   G                 100   The quadratic coeﬃcient of the input sizes of the exponentiation-over-modulo precompiled
                    quaddivisor
                                           contract.
                                                 Appendix H. Virtual Machine Specification
                 When interpreting 256-bit binary values as integers, the representation is big-endian.
                 When a 256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE)
              20 bytes are used and the left most 12 are discarded or ﬁlled with zeroes, thus the integer values (when the bytes are
              interpreted as big-endian) are equivalent.
              H.1. Gas Cost. The general gas cost function, C, is deﬁned as:
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2826
               (294)                                   
                                                       
                                                         CSSTORE(σ,µ)                               if w=SSTORE
                                                       
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w=EXP∧µ[1]=0
                                                        exp                                                         s
                                                       
                                                       
                                                       
                                                       
                                                         G +G             ×(1+⌊log      (µ [1])⌋)   if w=EXP∧µ[1]>0
                                                        exp       expbyte           256   s                         s
                                                       
                                                       
                                                       
                                                       
                                                         G        +G       ×⌈µ [2]÷32⌉              if w=CALLDATACOPY∨
                                                        verylow      copy      s
                                                       
                                                       
                                                                                                     CODECOPY∨RETURNDATACOPY
                                                       
                                                       
                                                       
                                                       
                                                       
                                                         G        +G      ×⌈µ [3]÷32⌉               if w=EXTCODECOPY
                                                        extcode      copy      s
                                                       
                                                       
                                                       
                                                       
                                                         G +G            ×µ[1]                      if w=LOG0
                                                        log      logdata    s
                                                       
                                                       
                                                       
                                                       
                                                         G +G            ×µ[1]+G                    if w=LOG1
                                                        log      logdata    s       logtopic
                                                       
                                                       
                                                       
                                                       
                                                         G +G            ×µ[1]+2G                   if w=LOG2
                                                        log      logdata    s         logtopic
                                                       
                                                       
                                                       
                                                       
                                                         G +G            ×µ[1]+3G                   if w=LOG3
                                                        log      logdata    s         logtopic
                                                       
                                                       
                                                       
                                                       
                                                         G +G            ×µ[1]+4G                   if w=LOG4
                                                        log      logdata    s         logtopic
                                                       
                                                       
                                                       
                                                       
                                                         CCALL(σ,µ)                                 if w=CALL∨CALLCODE∨
                                                       
                                                       
                                                       
                                                       
                                                                                                     DELEGATECALL
                                      ′                
               C(σ,µ,I) ≡ Cmem(µ )−Cmem(µ)+ CSELFDESTRUCT(σ,µ)                                      if w=SELFDESTRUCT
                                      i           i    
                                                       
                                                       
                                                         G                                          if w=CREATE
                                                        create
                                                       
                                                       
                                                       
                                                       
                                                         G     +G           ⌈s[1] ÷ 32⌉             if w=SHA3
                                                        sha3       sha3word
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w=JUMPDEST
                                                        jumpdest
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w=SLOAD
                                                        sload
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        zero                                                 zero
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        base                                                 base
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        verylow                                              verylow
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        low                                                  low
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        mid                                                  mid
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        high                                                 high
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w∈W
                                                        extcode                                              extcode
                                                       
                                                       
                                                       
                                                       
                                                         G                                          if w=BALANCE
                                                        balance
                                                       
                                                       
                                                       
                                                         G                                          if w=BLOCKHASH
                                                           blockhash
                                                                  (
                                                                    Ib[µ ] if µ <kIbk
               (295)                                         w≡          pc        pc
                                                                    STOP      otherwise
                  where:
                                                                                         2 
               (296)                                        C     (a) ≡ G         · a +   a
                                                              mem          memory         512
                  with CCALL, CSELFDESTRUCT and CSSTORE as speciﬁed in the appropriate section below. We deﬁne the following subsets
               of instructions:
                  Wzero = {STOP, RETURN, REVERT}
                  Wbase = {ADDRESS, ORIGIN, CALLER, CALLVALUE, CALLDATASIZE, CODESIZE, GASPRICE, COINBASE,
                       TIMESTAMP, NUMBER, DIFFICULTY, GASLIMIT, RETURNDATASIZE, POP, PC, MSIZE, GAS}
                  Wverylow = {ADD, SUB, NOT, LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, BYTE, CALLDATALOAD,
                       MLOAD, MSTORE, MSTORE8, PUSH*, DUP*, SWAP*}
                  Wlow = {MUL, DIV, SDIV, MOD, SMOD, SIGNEXTEND}
                  Wmid = {ADDMOD, MULMOD, JUMP}
                  Whigh = {JUMPI}
                  Wextcode = {EXTCODESIZE}
                  Note the memory cost component, given as the product of G             and the maximum of 0 & the ceiling of the number
                                                                                memory
               of words in size that the memory must be over the current number of words, µ in order that all accesses reference valid
                                                                                                 i
               memory whether for read or write. Such accesses must be for non-zero number of bytes.
                  Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory
               to be extended to the beginning of the range. µ′ is deﬁned as this new maximum number of words of active memory;
                                                                  i
               special-cases are given where these two are not equal.
                  Note also that Cmem is the memory cost function (the expansion function being the diﬀerence between the cost before
               and after). It is a polynomial, with the higher-order coeﬃcient divided and ﬂoored, and thus linear up to 724B of memory
               used, after which it costs substantially more.
                  While deﬁning the instruction set, we deﬁned the memory-expansion for range function, M, thus:
               ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2827
                                                        (
             (297)                           M(s,f,l) ≡  s                     if l = 0
                                                         max(s,⌈(f +l)÷32⌉) otherwise
                Another useful function is “all but one 64th” function L deﬁned as:
             (298)                                        L(n) ≡ n−⌊n/64⌋
             H.2. Instruction Set. As previously speciﬁed in section 9, these deﬁnitions take place in the ﬁnal context there. In
             particular we assume O is the EVM state-progression function and deﬁne the terms pertaining to the next cycle’s state
               ′  ′
             (σ ,µ ) such that:
                                                         ′  ′  ′
             (299)                       O(σ,µ,A,I)≡(σ ,µ,A,I) with exceptions, as noted
                Here given are the various exceptions to the state transition rules given in section 9 speciﬁed for each instruction,
             together with the additional instruction-speciﬁc deﬁnitions of J and C. For each instruction, also speciﬁed is α, the
             additional items placed on the stack and δ, the items removed from stack, as deﬁned in section 9.
                ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2828
                                                    0s: Stop and Arithmetic Operations
                                             256                                                    0
                   All arithmetic is modulo 2   unless otherwise noted. The zero-th power of zero 0 is deﬁned to be one.
                   Value Mnemonic           δ   α Description
                    0x00   STOP             0   0  Halts execution.
                    0x01   ADD              2   1  Addition operation.
                                                     ′
                                                   µ [0] ≡ µ [0] +µ [1]
                                                     s       s       s
                    0x02   MUL              2   1  Multiplication operation.
                                                     ′
                                                   µ [0] ≡ µ [0] ×µ [1]
                                                     s       s       s
                    0x03   SUB              2   1  Subtraction operation.
                                                     ′
                                                   µ [0] ≡ µ [0] −µ [1]
                                                     s       s       s
                    0x04   DIV              2   1  Integer division operation.
                                                           (
                                                             0                if  µ [1] = 0
                                                     ′                             s
                                                   µ [0] ≡
                                                     s       ⌊µ [0] ÷µ [1]⌋   otherwise
                                                                s      s
                    0x05   SDIV             2   1  Signed integer division operation (truncated).
                                                           
                                                           
                                                             0                                    if µ [1] = 0
                                                                                                    s
                                                     ′          255                                           255
                                                   µ [0] ≡   −2                                   if µ [0] = −2   ∧ µ [1] = −1
                                                     s                                              s                s
                                                           
                                                             sgn(µ [0]÷µ [1])⌊|µ [0]÷µ [1]|⌋      otherwise
                                                                    s      s       s      s
                                                   Where all values are treated as two’s complement signed 256-bit integers.
                                                   Note the overﬂow semantic when −2255 is negated.
                    0x06   MOD              2   1  Modulo remainder operation.
                                                           (
                                                             0                 if µ [1] = 0
                                                     ′                              s
                                                   µ [0] ≡
                                                     s       µ [0] mod µ [1]   otherwise
                                                               s         s
                    0x07   SMOD             2   1  Signed modulo remainder operation.
                                                           (
                                                             0                                if µ [1] = 0
                                                     ′                                             s
                                                   µ [0] ≡
                                                     s       sgn(µ [0])(|µ [0]| mod |µ [1]|)  otherwise
                                                                   s       s          s
                                                   Where all values are treated as two’s complement signed 256-bit integers.
                    0x08   ADDMOD           3   1  Modulo addition operation.
                                                           (
                                                     ′       0                           if  µs[2] = 0
                                                   µ [0] ≡
                                                     s       (µ [0] +µ [1]) mod µ [2]    otherwise
                                                                s      s            s
                                                                                                                         256
                                                   All intermediate calculations of this operation are not subject to the 2
                                                   modulo.
                    0x09   MULMOD           3   1  Modulo multiplication operation.
                                                           (
                                                     ′       0                           if  µs[2] = 0
                                                   µ [0] ≡
                                                     s       (µ [0] ×µ [1]) mod µ [2]    otherwise
                                                                s      s            s
                                                                                                                         256
                                                   All intermediate calculations of this operation are not subject to the 2
                                                   modulo.
                    0x0a   EXP              2   1  Exponential operation.
                                                     ′          µ [1]
                                                   µ [0] ≡ µ [0] s
                                                     s       s
                    0x0b   SIGNEXTEND 2 1 Extend length of two’s complement signed integer.
                                                                          (µ [1]t   if i 6 t  where t = 256−8(µ [0]+1)
                                                                   ′         s                                    s
                                                   ∀i ∈ [0..255] : µ [0] ≡
                                                                   s  i     µ [1]   otherwise
                                                                             s  i
                   µ [x]i gives the ith bit (counting from zero) of µ [x]
                    s                                              s
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2829
                                                   10s: Comparison & Bitwise Logic Operations
                    Value Mnemonic δ α Description
                      0x10   LT              2   1   Less-than comparison.
                                                             (1 if µ [0] < µ [1]
                                                      ′                 s        s
                                                     µ [0] ≡
                                                      s        0   otherwise
                      0x11   GT              2   1   Greater-than comparison.
                                                             (1 if µ [0] > µ [1]
                                                      ′                 s        s
                                                     µ [0] ≡
                                                      s        0   otherwise
                      0x12   SLT             2   1   Signed less-than comparison.
                                                             (1 if µ [0] < µ [1]
                                                      ′                 s        s
                                                     µ [0] ≡
                                                      s        0   otherwise
                                                     Where all values are treated as two’s complement signed 256-bit integers.
                      0x13   SGT             2   1   Signed greater-than comparison.
                                                             (1 if µ [0] > µ [1]
                                                      ′                 s        s
                                                     µ [0] ≡
                                                      s        0   otherwise
                                                     Where all values are treated as two’s complement signed 256-bit integers.
                      0x14   EQ              2   1   Equality comparison.
                                                             (1 if µ [0] = µ [1]
                                                      ′                 s        s
                                                     µ [0] ≡
                                                      s        0   otherwise
                      0x15   ISZERO          1   1   Simple not operator.
                                                             (1 if µ [0] = 0
                                                      ′                 s
                                                     µ [0] ≡
                                                      s        0   otherwise
                      0x16   AND             2   1   Bitwise AND operation.
                                                     ∀i ∈ [0..255] : µ′[0] ≡ µ [0] ∧ µ [1]
                                                                     s  i     s   i    s  i
                      0x17   OR              2   1   Bitwise OR operation.
                                                     ∀i ∈ [0..255] : µ′[0] ≡ µ [0] ∨ µ [1]
                                                                     s  i     s   i    s  i
                      0x18   XOR             2   1   Bitwise XOR operation.
                                                     ∀i ∈ [0..255] : µ′[0] ≡ µ [0] ⊕ µ [1]
                                                                     s  i     s   i    s  i
                      0x19   NOT             1   1   Bitwise NOT operation.
                                                                            (
                                                                              1   if  µ [0] = 0
                                                     ∀i ∈ [0..255] : µ′[0] ≡           s   i
                                                                     s  i     0   otherwise
                      0x1a   BYTE            2   1   Retrieve single byte from word.
                                                                            (
                                                                              µ [1]            if  i < 8 ∧ µ [0] < 32
                                                     ∀i ∈ [0..255] : µ′[0] ≡    s   (i+8µs[0])               s
                                                                     s  i     0                otherwise
                                                     For the Nth byte, we count from the left (i.e. N=0 would be the most signiﬁcant
                                                     in big endian).
                                                       20s: SHA3
                    Value Mnemonic δ α Description
                      0x20   SHA3            2   1   Compute Keccak-256 hash.
                                                      ′
                                                     µ [0] ≡ Keccak(µ [µ [0]...(µ [0]+µ [1]−1)])
                                                      s                m s           s       s
                                                      ′
                                                     µ ≡M(µ,µ [0],µ [1])
                                                      i        i   s     s
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2830
                                                           30s: Environmental Information
                    Value Mnemonic                    δ   α Description
                      0x30   ADDRESS                  0   1   Get address of currently executing account.
                                                               ′
                                                              µ [0] ≡ I
                                                               s       a
                      0x31   BALANCE                  1   1   Get balance of the given account.
                                                                      (                                 160
                                                                        σ[µ [0]]    if  σ[µ [0] mod 2      ] 6= ∅
                                                               ′            s   b           s
                                                              µ [0] ≡
                                                               s        0           otherwise
                      0x32   ORIGIN                   0   1   Get execution origination address.
                                                               ′
                                                              µ [0] ≡ I
                                                               s       o
                                                              This is the sender of original transaction; it is never an account with
                                                              non-empty associated code.
                      0x33   CALLER                   0   1   Get caller address.
                                                               ′
                                                              µ [0] ≡ I
                                                               s       s
                                                              This is the address of the account that is directly responsible for
                                                              this execution.
                      0x34   CALLVALUE                0   1   Get deposited value by the instruction/transaction responsible for
                                                              this execution.
                                                               ′
                                                              µ [0] ≡ I
                                                               s       v
                      0x35   CALLDATALOAD             1   1   Get input data of current environment.
                                                               ′
                                                              µ [0] ≡ I [µ [0]...(µ [0] + 31)]    with   I [x] = 0  if  x>kI k
                                                               s       d   s         s                    d                    d
                                                              This pertains to the input data passed with the message call
                                                              instruction or transaction.
                      0x36   CALLDATASIZE             0   1   Get size of input data in current
                                                              environment.
                                                               ′
                                                              µ [0] ≡ kI k
                                                               s        d
                                                              This pertains to the input data passed with the message call
                                                              instruction or transaction.
                      0x37   CALLDATACOPY             3   0   Copy input data in current environment to memory.
                                                                                              (I [µ [1]+i] if µ [1]+i < kI k
                                                                              ′                  d  s               s            d
                                                              ∀i∈{0...µ [2]−1}µ [µ [0] + i] ≡
                                                                      s       m s               0              otherwise
                                                                                                                   256
                                                              The additions in µ [1] +i are not subject to the 2      modulo.
                                                                                  s
                                                               ′
                                                              µ ≡M(µ,µ [0],µ [2])
                                                               i         i  s     s
                                                              This pertains to the input data passed with the message call instruction
                                                              or transaction.
                      0x38   CODESIZE                 0   1   Get size of code running in current environment.
                                                               ′
                                                              µ [0] ≡ kI k
                                                               s        b
                      0x39   CODECOPY                 3   0   Copy code running in current environment to memory.
                                                                                              (I [µ [1]+i] if µ [1]+i < kI k
                                                                              ′                  b  s               s            b
                                                              ∀i∈{0...µ [2]−1}µ [µ [0] + i] ≡
                                                                      s       m s               STOP           otherwise
                                                               ′
                                                              µ ≡M(µ,µ [0],µ [2])
                                                               i         i  s     s
                                                                                                                   256
                                                              The additions in µ [1] +i are not subject to the 2      modulo.
                                                                                  s
                      0x3a   GASPRICE                 0   1   Get price of gas in current environment.
                                                               ′
                                                              µ [0] ≡ I
                                                               s       p
                                                              This is gas price speciﬁed by the originating transaction.
                     0x3b    EXTCODESIZE              1   1   Get size of an account’s code.
                                                               ′                       160
                                                              µ [0] ≡ kσ[µ [0] mod 2      ]ck
                                                               s           s
                      0x3c   EXTCODECOPY              4   0   Copy an account’s code to memory.
                                                                                              (c[µ [2]+i] if µ [2]+i < kck
                                                                              ′                    s               s
                                                              ∀i∈{0...µ [3]−1}µ [µ [1] + i] ≡
                                                                      s       m s               STOP          otherwise
                                                                                         160
                                                              where c ≡ σ[µ [0] mod 2       ]
                                                                             s               c
                                                               ′
                                                              µ ≡M(µ,µ [1],µ [3])
                                                               i         i  s     s
                                                                                                                   256
                                                              The additions in µ [2] +i are not subject to the 2      modulo.
                                                                                  s
                     0x3d    RETURNDATASIZE           0   1   Get size of output data from the previous call from the current
                                                              environment.
                                                               ′
                                                              µ [0] ≡ kµ k
                                                               s         o
                      0x3e   RETURNDATACOPY 3 0 Copyoutput data from the previous call to memory.
                                                                                              (µ [µ [1]+i] if µ [1]+i < kµ k
                                                                              ′                  o   s               s            o
                                                              ∀i∈{0...µ [2]−1}µ [µ [0] + i] ≡
                                                                      s       m s               0              otherwise
                                                                                                                   256
                                                              The additions in µ [1] +i are not subject to the 2      modulo.
                                                                                  s
                                                               ′
                                                              µ ≡M(µ,µ [0],µ [2])
                                                               i         i  s     s
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2831
                                                                       40s: Block Information
                   Value Mnemonic            δ   α Description
                     0x40    BLOCKHASH 1 1 Getthehash of one of the 256 most recent complete blocks.
                                                     µ′[0] ≡ P(IH ,µ [0],0)
                                                       s           p   s
                                                     where P is the hash of a block of a particular number, up to a maximum
                                                     age. 0 is left on the stack if the looked for block number is greater than
                                                     the current block number or more than 256 blocks behind the current block.
                                                                  
                                                                  
                                                                    0                 if  n>Hi∨a=256∨h=0
                                                     P(h,n,a) ≡ 
                                                                    h                 if  n=Hi
                                                                  
                                                                  
                                                                    P(Hp,n,a+1) otherwise
                                                     and we assert the header H can be determined from its hash h unless as its hash is the parent
                                                     h is zero.
                     0x41    COINBASE        0   1   Get the block’s beneﬁciary address.
                                                     µ′[0] ≡ I
                                                       s      Hc
                     0x42    TIMESTAMP 0 1 Gettheblock’s timestamp.
                                                     µ′[0] ≡ I
                                                       s      Hs
                     0x43    NUMBER          0   1   Get the block’s number.
                                                     µ′[0] ≡ I
                                                       s      Hi
                     0x44    DIFFICULTY      0   1   Get the block’s diﬃculty.
                                                     µ′[0] ≡ I
                                                       s      Hd
                     0x45    GASLIMIT        0   1   Get the block’s gas limit.
                                                     µ′[0] ≡ I
                                                       s      Hl
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2832
                                            50s: Stack, Memory, Storage and Flow Operations
                    Value Mnemonic δ α Description
                      0x50    POP            1    0   Remove item from stack.
                      0x51    MLOAD          1    1   Load word from memory.
                                                       ′
                                                      µ [0] ≡ µ [µ [0]...(µ [0]+31)]
                                                       s        m s           s
                                                       ′
                                                      µ ≡max(µ,⌈(µ [0]+32)÷32⌉)
                                                       i           i    s
                                                                                            ′                         256
                                                      The addition in the calculation of µ is not subject to the 2        modulo.
                                                                                            i
                      0x52    MSTORE         2    0   Save word to memory.
                                                       ′
                                                      µ [µ [0]...(µ [0]+31)] ≡ µ [1]
                                                       m s            s              s
                                                       ′
                                                      µ ≡max(µ,⌈(µ [0]+32)÷32⌉)
                                                       i           i    s
                                                                                            ′                         256
                                                      The addition in the calculation of µ is not subject to the 2        modulo.
                                                                                            i
                      0x53    MSTORE8        2    0   Save byte to memory.
                                                       ′
                                                      µ [µ [0]] ≡ (µ [1] mod 256)
                                                       m s            s
                                                       ′
                                                      µ ≡max(µ,⌈(µ [0]+1)÷32⌉)
                                                       i           i    s
                                                                                            ′                         256
                                                      The addition in the calculation of µ is not subject to the 2        modulo.
                                                                                            i
                      0x54    SLOAD          1    1   Load word from storage.
                                                       ′
                                                      µ [0] ≡ σ[I ] [µ [0]]
                                                       s          a s  s
                      0x55    SSTORE         2    0   Save word to storage.
                                                      σ′[Ia]s[µ [0]] ≡ µ [1]
                                                               s        s
                                                                         (G          if  µ [1] 6= 0 ∧ σ[I ] [µ [0]] = 0
                                                      C        (σ,µ) ≡       sset          s               a s  s
                                                        SSTORE             G         otherwise
                                                                   (         sreset
                                                                     R        if  µ [1] = 0 ∧ σ[I ] [µ [0]] 6= 0
                                                        ′             sclear        s               a s  s
                                                      A ≡A +
                                                        r     r      0        otherwise
                      0x56    JUMP           1    0   Alter the program counter.
                                                      J     (µ) ≡ µ [0]
                                                       JUMP          s
                                                      This has the eﬀect of writing said value to µ . See section 9.
                                                                                                      pc
                      0x57    JUMPI          2    0   Conditionally alter the program counter.
                                                                    (µ [0]      if  µ [1] 6= 0
                                                      J      (µ) ≡     s              s
                                                       JUMPI          µ +1 otherwise
                                                                       pc
                                                      This has the eﬀect of writing said value to µ . See section 9.
                                                                                                      pc
                      0x58    PC             0    1   Get the value of the program counter prior to the increment
                                                      corresponding to this instruction.
                                                       ′
                                                      µ [0] ≡ µ
                                                       s        pc
                      0x59    MSIZE          0    1   Get the size of active memory in bytes.
                                                       ′
                                                      µ [0] ≡ 32µ
                                                       s          i
                      0x5a    GAS            0    1   Get the amount of available gas, including the corresponding reduction
                                                      for the cost of this instruction.
                                                       ′
                                                      µ [0] ≡ µ
                                                       s        g
                      0x5b    JUMPDEST 0 0 Markavalid destination for jumps.
                                                      This operation has no eﬀect on machine state during execution.
               ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2833
                                                   60s & 70s: Push Operations
                 Value Mnemonic δ α Description
                  0x60   PUSH1        0  1  Place 1 byte item on stack.
                                              ′
                                            µ [0] ≡ c(µ  +1)
                                              s       pc  (
                                                           I [x]  if x<kI k
                                            where c(x) ≡    b              b
                                                           0      otherwise
                                            The bytes are read in line from the program code’s bytes array.
                                            The function c ensures the bytes default to zero if they extend past the limits.
                                            The byte is right-aligned (takes the lowest signiﬁcant place in big endian).
                  0x61   PUSH2        0  1  Place 2-byte item on stack.
                                              ′                          
                                            µ [0] ≡ c (µ  +1)...(µ +2)
                                              s         pc         pc
                                            with c(x) ≡ (c(x0),...,c(xkxk−1)) with c as deﬁned as above.
                                            The bytes are right-aligned (takes the lowest signiﬁcant place in big endian).
                   .          .       .  .                                     .
                   .          .       .  .                                     .
                   .          .       .  .                                     .
                   0x7f  PUSH32       0  1  Place 32-byte (full word) item on stack.
                                              ′                           
                                            µ [0] ≡ c (µ  +1)...(µ +32)
                                              s         pc         pc
                                            where c is deﬁned as above.
                                            The bytes are right-aligned (takes the lowest signiﬁcant place in big endian).
                            80s: Duplication Operations
                 Value Mnemonic        δ  α Description
                  0x80   DUP1          1   2  Duplicate 1st stack item.
                                               ′
                                              µ [0] ≡ µ [0]
                                               s       s
                  0x81   DUP2          2   3  Duplicate 2nd stack item.
                                               ′
                                              µ [0] ≡ µ [1]
                                               s       s
                   .          .        .   .             .
                   .          .        .   .             .
                   .          .        .   .             .
                   0x8f  DUP16        16  17  Duplicate 16th stack item.
                                               ′
                                              µ [0] ≡ µ [15]
                                               s       s
                                 90s: Exchange Operations
                 Value Mnemonic        δ  α Description
                  0x90   SWAP1         2   2  Exchange 1st and 2nd stack items.
                                               ′
                                              µ [0] ≡ µ [1]
                                               s       s
                                               ′
                                              µ [1] ≡ µ [0]
                                               s       s
                  0x91   SWAP2         3   3  Exchange 1st and 3rd stack items.
                                               ′
                                              µ [0] ≡ µ [2]
                                               s       s
                                               ′
                                              µ [2] ≡ µ [0]
                                               s       s
                   .          .        .   .                 .
                   .          .        .   .                 .
                   .          .        .   .                 .
                   0x9f  SWAP16       17  17  Exchange 1st and 17th stack items.
                                               ′
                                              µ [0] ≡ µ [16]
                                               s       s
                                               ′
                                              µ [16] ≡ µ [0]
                                               s        s
               ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2834
                                                     a0s: Logging Operations
                 For all logging operations, the state change is to append an additional log entry on to the substate’s log series:
                                                                           ′
                                                                       AlA ≡A ·(I ,t,µ [µ [0]...(µ [0]+µ [1]−1)])
                                                                           l    l   a    m s         s      s
                 and to update the memory consumption counter:
                  ′
                 µ ≡M(µ,µ [0],µ [1])
                  i       i  s    s
                 The entry’s topic series, t, diﬀers accordingly:
                 Value Mnemonic δ α Description
                  0xa0   LOG0         2  0  Append log record with no topics.
                                            t ≡ ()
                  0xa1   LOG1         3  0  Append log record with one topic.
                                            t ≡ (µ [2])
                                                  s
                   .          .       .  .                                     .
                   .          .       .  .                                     .
                   .          .       .  .                                     .
                  0xa4   LOG4         6  0  Append log record with four topics.
                                            t ≡ (µ [2],µ [3],µ [4],µ [5])
                                                  s    s     s    s
                 ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2835
                                                                 f0s: System operations
                    Value Mnemonic δ α Description
                      0xf0   CREATE          3   1   Create a new account with associated code.
                                                     i ≡ µ [µ [1]...(µ [1]+µ [2]−1)]
                                                          m s           s        s
                                                                            ∗
                                                                       
                                                                         Λ(σ ,I ,I ,L(µ ),I ,µ [0],i,I +1,I )         if  µ [0] 6 σ[I ]
                                                                                a  o     g    p   s      e      w          s         a b
                                                       ′   ′   +
                                                     (σ ,µ ,A ,o) ≡                                                   ∧I <1024
                                                           g                                                             e
                                                                                   
                                                                        σ,µ ,∅                                       otherwise
                                                                               g
                                                     σ∗ ≡σ except σ∗[I ] =σ[I ] +1
                                                                             a n      a n
                                                      ′          +                       ′           +          ′         +
                                                     A ≡A⋒A whichabbreviates: A ≡A ∪A                     ∧ A ≡A ·A           ∧
                                                                                         s     s     s          l     l   l
                                                      ′           +       ′           +
                                                     A ≡A ∪A ∧ A ≡A +A
                                                      t     t     t       r     r     r
                                                      ′
                                                     µ [0] ≡ x
                                                      s
                                                     where x = 0 if the code execution for this operation failed due to an
                                                     exceptional halting (or for a REVERT) σ′ = ∅, or I = 1024
                                                                                                           e
                                                     (the maximum call depth limit is reached) or µ [0] > σ[Ia]b (balance of the caller
                                                                                                       s
                                                     is too low to fulﬁl the value transfer); and otherwise x = A(I ,σ[I ] ), the
                                                                                                                     a     a n
                                                     address of the newly created account.
                                                      ′
                                                     µ ≡M(µ,µ [1],µ [2])
                                                      i        i   s     s
                                                      ′
                                                     µ ≡()
                                                      o
                                                     Thus the operand order is: value, input oﬀset, input size.
                      0xf1   CALL            7   1   Message-call into an account.
                                                     i ≡ µ [µ [3]...(µ [3]+µ [4]−1)]
                                                          m s         s         s
                                                                       Θ(σ,I ,I ,t,t,C             (µ),      if µ [2] 6 σ[I ] ∧
                                                                               a  o       CALLGAS                 s         a b
                                                       ′  ′   +
                                                     (σ ,g ,A ,o) ≡         I ,µ [2],µ [2],i,I +1,I )             I <1024
                                                                            p   s     s       e      w            e
                                                                      
                                                                        (σ,g,∅,())                          otherwise
                                                     n≡min({µ [6],|o|})
                                                                 s
                                                      ′
                                                     µ [µ [5]...(µ [5]+n−1)] = o[0...(n−1)]
                                                      m s           s
                                                      ′
                                                     µ =o
                                                      o
                                                      ′           ′
                                                     µ ≡µ +g
                                                      g     g
                                                      ′
                                                     µ [0] ≡ x
                                                      s
                                                      ′          +
                                                     A ≡A⋒A           160
                                                     t ≡ µ [1] mod 2
                                                          s
                                                     where x = 0 if the code execution for this operation failed due to an
                                                     exceptional halting (or for a REVERT) σ′ = ∅ or if
                                                     µ [2] > σ[I ] (not enough funds) or I = 1024 (call depth limit reached); x = 1
                                                      s         a b                          e
                                                     otherwise.
                                                      ′
                                                     µ ≡M(M(µ,µ [3],µ [4]),µ [5],µ [6])
                                                      i            i  s      s      s     s
                                                     Thus the operand order is: gas, to, value, in oﬀset, in size, out oﬀset, out size.
                                                     CCALL(σ,µ) ≡ CGASCAP(σ,µ)+CEXTRA(σ,µ)
                                                                        (
                                                                          CGASCAP(σ,µ)+G                   if  µ [2] 6= 0
                                                     C         (σ,µ) ≡                         callstipend      s
                                                      CALLGAS             C        (σ,µ)                   otherwise
                                                                       ( GASCAP
                                                                         min{L(µ −CEXTRA(σ,µ)),µ [0]} if µ ≥CEXTRA(σ,µ)
                                                     C        (σ,µ) ≡              g                     s            g
                                                      GASCAP             µ [0]                                  otherwise
                                                                           s
                                                     CEXTRA(σ,µ) ≡ Gcall +CXFER(µ)+CNEW(σ,µ)
                                                                  (G            if  µ [2] 6= 0
                                                     C     (µ) ≡      callvalue       s
                                                      XFER          0           otherwise
                                                                    (                                          160
                                                                      G              if  DEAD(σ,µ [1] mod 2       ) ∧ µ [2] 6= 0
                                                     C     (σ,µ) ≡      newaccount                 s                   s
                                                      NEW             0              otherwise
                      0xf2   CALLCODE 7 1 Message-call into this account with an alternative account’s code.
                                                     Exactly equivalent to CALL except:
                                                                             ∗
                                                                       Θ(σ ,I ,I ,I ,t,C             (µ),     if  µ [2] 6 σ[I ] ∧
                                                                                a   o  a     CALLGAS                s         a b
                                                       ′  ′   +
                                                     (σ ,g ,A ,o) ≡         I ,µ [2],µ [2],i,I +1,I )               I <1024
                                                                            p   s     s       e      w              e
                                                                      
                                                                        (σ,g,∅,())                            otherwise
                                                     Note the change in the fourth parameter to the call Θ from the 2nd stack value
                                                     µ [1] (as in CALL) to the present address I . This means that the recipient is in
                                                      s                                           a
                                                     fact the same account as at present, simply that the code is overwritten.
                      0xf3   RETURN          2   0   Halt execution returning output data.
                                                     H        (µ) ≡ µ [µ [0]...(µ [0]+µ [1]−1)]
                                                       RETURN          m s           s       s
                                                     This has the eﬀect of halting the execution at this point with output deﬁned.
                                                     See section 9.
                                                      ′
                                                     µ ≡M(µ,µ [0],µ [1])
                                                      i        i   s     s
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2836
                    0xf4   DELEGATECALL          6   1   Message-call into this account with an alternative account’s code, but
                                                         persisting the current values for sender and value.
                                                         Compared with CALL, DELEGATECALL takes one fewer arguments. The
                                                         omitted argument is µ [2]. As a result, µ [3], µ [4], µ [5] and µ [6] in the
                                                                                 s                    s     s      s          s
                                                         deﬁnition of CALL should respectively be replaced with µ [2], µ [3], µ [4] and
                                                                                                                       s      s     s
                                                         µ [5]. Otherwise it is equivalent to CALL except:
                                                           s               
                                                                            Θ(σ∗,Is,Io,Ia,t,
                                                                                                                if I 6σ[I ] ∧
                                                                                                                     v      a b
                                                                            µ[0],I ,0,I ,i,I +1,I )
                                                         (σ′,g′,A+,o) ≡            s    p     v    e      w
                                                                           I <1024
                                                                            e
                                                                           
                                                                           
                                                                             (σ,g,∅,())                          otherwise
                                                         Note the changes (in addition to that of the fourth parameter) to the second
                                                         and ninth parameters to the call Θ.
                                                         This means that the recipient is in fact the same account as at present, simply
                                                         that the code is overwritten and the context is almost entirely identical.
                    0xfa   STATICCALL            6   1   Static message-call into an account.
                                                         Exactly equivalent to CALL except:
                                                         The argument µ [2] is replaced with 0.
                                                                           s
                                                         The deeper argument µ [3], µ [4], µ [5] and µ [6] are respectively replaced
                                                                                   s     s      s          s
                                                         with µ [2], µ [3], µ [4] and µ [5].
                                                                 s     s      s          s
                                                         The last argument of Θ is ⊥.
                    0xfd   REVERT                2   0   Halt execution reverting state changes but returning data and remaining gas.
                                                         The eﬀect of this operation is described in (131).
                                                         For the gas calculation, we use the memory expansion function,
                                                           ′
                                                         µ ≡M(µ,µ [0],µ [1])
                                                           i        i   s     s
                    0xfe   INVALID              ∅ ∅ Designated invalid instruction.
                     0xﬀ   SELFDESTRUCT          1   0   Halt execution and register account for later deletion.
                                                           ′
                                                         A ≡A ∪{I }
                                                           s     s     a
                                                                  
                                                                  
                                                                    ∅                                     if σ[r] = ∅ ∧ σ[I ] = 0
                                                                                                                             a b
                                                         σ′[r] ≡    (σ[r] ,σ[r] +σ[I ] ,σ[r] ,σ[r] )      if r 6= I
                                                                        n     b       a b     s      c           a
                                                                  
                                                                    (σ[r] ,0,σ[r] ,σ[r] )                 otherwise
                                                                         n        s     c
                                                         where r = µ [0] mod 2160
                                                                      s
                                                         σ′[I ] = 0
                                                              a b                                   (
                                                                                                      G              if  n
                                                          C               (σ,µ) ≡ G              +      newaccount
                                                            SELFDESTRUCT              selfdestruct    0              otherwise
                                                         n≡DEAD(σ,µ [0] mod 2160)∧σ[I ] 6= 0
                                                                        s                      a b
                                                               Appendix I. Genesis Block
                   The genesis block is 15 items, and is speciﬁed thus:
                                                                              17                                            
               (300)           0   , KEC RLP ()   , 0  , stateRoot,0,0,0      , 2 , 0, 0, 3141592,time,0,0    , KEC (42)  , (), ()
                                256                 160                   2048                             256
                   Where 0     refers to the parent hash, a 256-bit hash which is all zeroes; 0    refers to the beneﬁciary address, a 160-bit
                           256                                                                 160
                                                                                                17
               hash which is all zeroes; 0     refers to the log bloom, 2048-bit of all zeros; 2  refers to the diﬃculty; the transaction trie
                                           2048
               root, receipt trie root, gas used, block number and extradata are both 0, being equivalent to the empty byte array. The
                                                                                                             
               sequences of both ommers and transactions are empty and represented by (). KEC (42) refers to the Keccak hash of a
                                                                                                                       
               byte array of length one whose ﬁrst and only byte is of value 42, used for the nonce. KEC RLP ()            value refers to the
               hash of the ommer list in RLP, both empty lists.
                   The proof-of-concept series include a development premine, making the state root hash some value stateRoot. Also
               time will be set to the initial timestamp of the genesis block. The latest documentation should be consulted for those
               values.
                                                                   Appendix J. Ethash
               J.1. Deﬁnitions. We employ the following deﬁnitions:
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2837
                    Name              Value   Description
                    Jwordbytes          4     Bytes in word.
                    J                  230    Bytes in dataset at genesis.
                      datasetinit
                    J                  223    Dataset growth per epoch.
                      datasetgrowth
                    J                  224    Bytes in cache at genesis.
                      cacheinit
                    J                  217    Cache growth per epoch.
                      cachegrowth
                    Jepoch            30000   Blocks per epoch.
                    Jmixbytes          128    mix length in bytes.
                    Jhashbytes         64     Hash length in bytes.
                    Jparents           256    Number of parents of each dataset element.
                    Jcacherounds        3     Number of rounds in cache production.
                    Jaccesses          64     Number of accesses in hashimoto loop.
                J.2. Size of dataset and cache. The size for Ethash’s cache c ∈ B and dataset d ∈ B depend on the epoch, which in
                turn depends on the block number.
                (301)                                               E      (H)= Hi 
                                                                      epoch   i      J
                                                                                      epoch
                The size of the dataset growth by J                  bytes, and the size of the cache by J               bytes, every epoch. In
                                                       datasetgrowth                                         cachegrowth
                order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by a
                multiple of J         , for the dataset, and J           for the cache. Let d      =kdkbethe size of the dataset. Which is
                              mixbytes                         hashbytes                      size
                calculated using
                (302)                    d     =E       (J            +J               · E      −J          , J        )
                                           size    prime   datasetinit   datasetgrowth    epoch     mixbytes   mixbytes
                The size of the cache, csize, is calculated using
                (303)                      c    =E        (J         +J              · E      −J          , J        )
                                            size     prime  cacheinit    cachegrowth    epoch     hashbytes  hashbytes
                (304)                                 E      (x,y) = (x                       if  x/y ∈ N
                                                        prime           E      (x−2·y,y) otherwise
                                                                          prime
                J.3. Dataset generation. In order to generate the dataset we need the cache c, which is an array of bytes. It depends
                on the cache size c     and the seed hash s ∈ B .
                                    size                           32
                J.3.1. Seed hash. The seed hash is diﬀerent for every epoch. For the ﬁrst epoch it is the Keccak-256 hash of a series of 32
                bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:
                (305)                                                  s = Cseedhash(Hi)
                                                              (
                                                                0                                if  E      (H)=0
                (306)                       C         (H)=        32                                  epoch    i
                                              seedhash   i      KEC(C          (H −J        ))   otherwise
                                                                       seedhash   i    epoch
                With 0    being 32 bytes of zeros.
                       32
                J.3.2. Cache. The cache production process involves using the seed hash to ﬁrst sequentially ﬁlling up c                 bytes of
                                                                                                                                    size
                memory, then performing Jcacherounds passes of the RandMemoHash algorithm created by Lerner [2014]. The initial
                        ′
                cache c , being an array of arrays of single bytes, will be constructed as follows.
                   Wedeﬁne the array c , consisting of 64 single bytes, as the ith element of the initial cache:
                                          i                          (
                (307)                                          c = KEC512(s)           if  i = 0
                                                                 i     KEC512(c     )  otherwise
                                                                                i−1
                Therefore c′ can be deﬁned as
                                                                       ′
                (308)                                                 c [i] = ci  ∀ i<n
                                                                             c         
                (309)                                                  n=         size
                                                                              Jhashbytes
                                                                                                                                           ′
                The cache is calculated by performing Jcacherounds rounds of the RandMemoHash algorithm to the initial cache c :
                (310)                                          c = E             (c′,J           )
                                                                     cacherounds      cacherounds
                                                                    
                                                                    
                                                                       x                                 if  y = 0
                (311)                         E            (x,y) = 
                                                cacherounds            E     (x)                         if  y = 1
                                                                     RMH
                                                                    E              (E     (x),y −1)     otherwise
                                                                        cacherounds    RMH
                Where a single round modiﬁes each subset of the cache as follows:
                                                                                                             
                (312)                              E     (x) = E      (x,0),E      (x,1),...,E     (x,n−1)
                                                    RMH           rmh          rmh             rmh
                  ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2838
                                                ′                          ′  ′
               (313)    Ermh(x,i) = KEC512(x [(i−1+n) mod n]⊕x [x [i][0] mod n])
                                                                                            ′                  ′
                                                                                    with   x =x except x[j]=E              (x,j)   ∀ j <i
                                                                                                                       rmh
               J.3.3. Full dataset calculation. Essentially, we combine data from Jparents pseudorandomly selected cache nodes, and hash
               that to compute the dataset. The entire dataset is then generated by a number of items, each Jhashbytes bytes in size:
               (314)                                   d[i] = E            (c,i)  ∀ i< dsize 
                                                                datasetitem                 J
                                                                                             hashbytes
               In order to calculate the single item we use an algorithm inspired by the FNV hash (Glenn Fowler [1991]) in some cases
               as a non-associative substitute for XOR.
                                                                                                      32
               (315)                                  E     (x,y) = (x·(0x01000193⊕y)) mod 2
                                                        FNV
               The single item of the dataset can now be calculated as:
               (316)                                      E            (c,i) = E       (c,i,−1,∅)
                                                            datasetitem          parents
                                                         (E        (c,i,p +1,E      (m,c,i,p+1)) if p<J                −2
               (317)               E       (c,i,p,m) =       parents             mix                            parents
                                     parents               E     (m,c,i,p+1)                           otherwise
                                                             mix
                                              (
                                                KEC512(c[i   mod c      ] ⊕ i)                                                 if  p = 0
               (318)       E    (m,c,i,p) =                         size                                                   
                            mix                 E      m,c[E      (i ⊕ p,m[p   mod ⌊J           /J         ⌋])  mod c      ]   otherwise
                                                  FNV         FNV                      hashbytes  wordbytes            size
               J.4. Proof-of-work function. Essentially, we maintain a “mix” Jmixbytes bytes wide, and repeatedly sequentially fetch
               J          bytes from the full dataset and use the E       function to combine it with the mix. J           bytes of sequential
                 mixbytes                                            FNV                                          mixbytes
               access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside
               buﬀer misses which ASICs would theoretically be able to avoid.
                   If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application
               of KEC at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small
               amount of work was done; this quick outer PoW veriﬁcation can be used for anti-DDoS purposes. It also serves to provide
               statistical assurance that the result is an unbiased, 256 bit number.
                   The PoW-function returns an array with the compressed mix as its ﬁrst item and the Keccak-256 hash of the
               concatenation of the compressed mix with the seed hash as the second item:
               (319)
                 PoW(H ,H ,d) = {m (KEC(RLP(L (H ))),H ,d),KEC(s (KEC(RLP(L (H ))),H )+m (KEC(RLP(L (H ))),H ,d))}
                       n    n           c           H    n       n          h             H   n       n      c            H    n       n
               With Hn being the hash of the header without the nonce. The compressed mix mc is obtained as follows:
                                                                                  nmix
               (320)                       m(h,n,d)=E                (E       (d, X s (h,n),s (h,n),−1),−4)
                                             c              compress   accesses         h        h
                                                                                   i=0
                   The seed hash being:
               (321)                                         s (h,n) = KEC512(h+E            (n))
                                                              h                        revert
               E       (n) returns the reverted bytes sequence of the nonce n:
                 revert
               (322)                                             E       (n)[i] = n[knk −i]
                                                                   revert
               Wenote that the “+”-operator between two byte sequences results in the concatenation of both sequences.
                   The dataset d is obtained as described in section J.3.3.
                   The number of replicated sequences in the mix is:
               (323)                                                n     =Jmixbytes
                                                                      mix     J
                                                                                hashbytes
               In order to add random dataset nodes to the mix, the E              function is used:
                                                         (                 accesses
                                                           E           (d,m,s,i)                       if  i = Jaccesses − 2
               (324)              E        (d,m,s,i) =       mixdataset
                                    accesses               E        (E           (d,m,s,i),s,i+1) otherwise
                                                             accesses mixdataset
               (325)                               E           (d,m,s,i) = E       (m,E         (d,m,s,i)
                                                     mixdataset                FNV       newdata
               E          returns an array with n      elements:
                 newdata                           mix
               (326)                                                                                          
                                                                          J                      d    /J
                E        (d,m,s,i)[j] = d[E       (i ⊕ s[0],m[i   mod      mixbytes  ])   mod     size   hashbytes · n    +j] ∀ j<n
                  newdata                     FNV                        J                            n               mix                 mix
                                                                           wordbytes                    mix
               The mix is compressed as follows:
               (327)                   (
                   E         (m,i) =     m                                                                                if  i > kmk−8
                     compress            E         (E    (E     (E     (m[i+4],m[i+5]),m[i+6]),m[i+7]),i+8) otherwise
                                          compress    FNV   FNV    FNV
               ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER BYZANTIUM VERSION dbc2f9b - 2019-03-2839
                                           Appendix K. Anomalies on the Main Network
             K.1. Deletion of an Account Despite Out-of-gas. At block 2675119, in the transaction 0xcf416c536ec1a19ed1fb89e
             4ec7ffb3cf73aa413b3aa9b77d60e4fd81a4296ba, an account at address 0x03 was called and an out-of-gas occurred during
             the call. Against the equation (195), this added 0x03 in the set of touched addresses, and this transaction turned σ[0x03]
             into ∅.
                                             Appendix L. List of mathematical symbols
                 Symbol Latex Command Description
                   W         \bigvee      This is the least upper bound, supremum, or join of all elements operated on. Thus it
                                           is the greatest element of such elements (Davey and Priestley [2002]).
