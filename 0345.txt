                  Bulletproofs: Short Proofs for Conﬁdential Transactions and More
                                                         ∗1                    †2               ‡1
                                        Benedikt Bunz¨     , Jonathan Bootle , Dan Boneh ,
                                                        §3                 ¶3                       k
                                     Andrew Poelstra , Pieter Wuille , and Greg Maxwell
                                                         1Stanford University
                                                     2University College London
                                                             3Blockstream
                                                                            ∗∗
                                                              Full Version
                                                                Abstract
                          We propose Bulletproofs, a new non-interactive zero-knowledge proof protocol with very
                       short proofs and without a trusted setup; the proof size is only logarithmic in the witness size.
                       Bulletproofs are especially well suited for eﬃcient range proofs on committed values: they enable
                       proving that a committed value is in a range using only 2log2pnq`9 group and ﬁeld elements,
                       where n is the bit length of the range. Proof generation and veriﬁcation times are linear in n.
                          Bulletproofs greatly improve on the linear (in n) sized range proofs in existing proposals for
                       conﬁdential transactions in Bitcoin and other cryptocurrencies. Moreover, Bulletproofs supports
                       aggregation of range proofs, so that a party can prove that m commitments lie in a given range
                       by providing only an additive Oplogpmqq group elements over the length of a single proof. To
                       aggregate proofs from multiple parties, we enable the parties to generate a single proof without
                       revealing their inputs to each other via a simple multi-party computation (MPC) protocol for
                       constructing Bulletproofs. This MPC protocol uses either a constant number of rounds and
                       linear communication, or a logarithmic number of rounds and logarithmic communication. We
                       show that veriﬁcation time, while asymptotically linear, is very eﬃcient in practice. Moreover,
                       the veriﬁcation of multiple Bulletproofs can be batched for further speed-up. Concretely, the
                       marginal time to verify an aggregation of 16 range proofs is about the same as the time to
                       verify 16 ECDSA signatures.
                          Bulletproofs build on the techniques of Bootle et al. (EUROCRYPT 2016). Beyond range
                       proofs, Bulletproofs provide short zero-knowledge proofs for general arithmetic circuits while
                       only relying on the discrete logarithm assumption and without requiring a trusted setup. We
                       discuss many applications that would beneﬁt from Bulletproofs, primarily in the area of cryp-
                       tocurrencies. The eﬃciency of Bulletproofs is particularly well suited for the distributed and
                       trustless nature of blockchains.
                   ∗benedikt@cs.stanford.edu
                   †jonathan.bootle.14@ucl.ac.uk
                   ‡dabo@cs.stanford.edu
                   §apoelstra@blockstream.io
                   ¶pieter@blockstream.com
                   kgreg@xiph.org
                   ∗∗An extended abstract of this work appeared at IEEE S&P 2018 [BBB`18]
                                                                    1
                1     Introduction
                Blockchain-based cryptocurrencies enable peer-to-peer electronic transfer of value by maintaining
                a global distributed but synchronized ledger, the blockchain. Any independent observer can verify
                both the current state of the blockchain as well as the validity of all transactions on the ledger. In
                Bitcoin, this innovation requires that all details of a transaction are public: the sender, the receiver,
                and the amount transferred. In general, we separate privacy for payments into two properties: (1)
                anonymity, hidingtheidentities of sender and receiver in a transaction and (2) conﬁdentiality, hiding
                the amount transferred. While Bitcoin provides some weak anonymity through the unlinkability of
                Bitcoin addresses to real world identities, it lacks any conﬁdentiality. This is a serious limitation
                for Bitcoin and could be prohibitive for many use cases. Would employees want to receive their
                salaries in bitcoin if it meant that their salaries were published on the public blockchain?
                    To address the conﬁdentiality of transaction amounts, Maxwell [Max16] introduced conﬁdential
                transactions (CT), in which every transaction amount involved is hidden from public view using a
                commitment to the amount. This approach seems to prevent public validation of the blockchain;
                an observer can no longer check that the sum of transaction inputs is greater than the sum of
                transaction outputs, and that all transaction values are positive. This can be addressed by including
                in every transaction a zero-knowledge proof of validity of the conﬁdential transaction.
                    Current proposals for CT zero-knowledge proofs [PBF`] have either been prohibitively large
                or required a trusted setup. Neither is desirable. While one could use succinct zero-knowledge
                proofs (SNARKs) [BSCG`13,GGPR13], they require a trusted setup, which means that everyone
                needs to trust that the setup was performed correctly. One could avoid trusted setup by using a
                STARK[BSBTHR18], but the resulting range proofs while asymptotically eﬃcient are practically
                larger than even the currently proposed solutions.
                    Short non-interactive zero-knowledge proofs without a trusted setup, as described in this paper,
                have many applications in the realm of cryptocurrencies. In any distributed system where proofs
                are transmitted over a network or stored for a long time, short proofs reduce overall cost.
                1.1    Our Contributions
                                                                                            1
                We present Bulletproofs, a new zero-knowledge argument of knowledge system, to prove that a
                secret committed value lies in a given interval. Bulletproofs do not require a trusted setup. They
                rely only on the discrete logarithm assumption, and are made non-interactive using the Fiat-Shamir
                heuristic.
                    Bulletproofs builds on the techniques of Bootle et al. [BCC`16], which yield communication-
                eﬃcient zero-knowledge proofs. We present a replacement for their inner-product argument that
                reduces overall communication by a factor of 3. We make Bulletproofs suitable for proving state-
                ments on committed values. Examples include a range proof, a veriﬁable shuﬄe, and other appli-
                                                                                                     `
                cations discussed below. We note that a range proof using the protocol of [BCC 16] would have
                required implementing the commitment opening algorithm as part of the veriﬁcation circuit, which
                we are able to eliminate.
                Distributed Bulletproofs generation. WeshowthatBulletproofssupportasimpleandeﬃcient
                multi-party computation (MPC) protocol that allows multiple parties with secret committed values
                   1Proof systems with computational soundness like Bulletproofs are sometimes called argument systems. We will
                use the terms proof and argument interchangeably.
                                                                   2
                to jointly generate a single small range proof for all their values, without revealing their secret values
                to each other. One version of our MPC protocol is constant-round but with linear communication.
                Anothervariant requires only logarithmic communication, but uses a logarithmic number of rounds.
                When a conﬁdential transaction has inputs from multiple parties (as in the case of CoinJoin), this
                MPCprotocol can be used to aggregate all the proofs needed to construct the transaction into a
                single short proof.
                Proofs for arithmetic circuits. While we focus on conﬁdential transactions (CT), where our
                work translates to signiﬁcant practical savings, we stress that the improvements are not limited to
                CT. We present Bulletproofs for general NP languages. The proof size is logarithmic in the number
                of multiplication gates in the arithmetic circuit for verifying a witness. The proofs are much shorter
                than [BCC`16] and allow inputs to be Pedersen commitments to elements of the witness.
                Optimizations and evaluation. We provide a complete implementation of Bulletproofs that
                includes many further optimizations described in Section 6. For example, we show how to batch
                the veriﬁcation of multiple Bulletproofs so that the cost of verifying every additional proof is
                signiﬁcantly reduced. We also provide eﬃciency comparisons with the range proofs currently used
                for conﬁdential transactions [Max16, Poe] and with other proof systems.        Our implementation
                includes a general tool for constructing Bulletproofs for any NP language.       The tool reads in
                arithmetic circuits in the Pinocchio [PHGR13] format which lets users use their toolchain. This
                toolchain includes a compiler from C to the circuit format. We expect this to be of great use to
                implementers who want to use Bulletproofs.
                1.2   Applications
                We ﬁrst discuss several applications for Bulletproofs along with related work speciﬁc to these
                applications. Additional related work is discussed in Section 1.3.
                1.2.1   Conﬁdential Transactions and Mimblewimble
                Bitcoin and other similar cryptocurrencies use a transaction-output-based system where each trans-
                action fully spends the outputs of previously unspent transactions. These unspent transaction out-
                puts are called UTXOs. Bitcoin allows a single UTXO to be spent to many distinct outputs, each
                associated with a diﬀerent address. To spend a UTXO a user must provide a signature, or more
                precisely a scriptSig, that enables the transaction SCRIPT to evaluate to true [BMC`15]. Apart
                from the validity of the scriptSig, miners verify that the transaction spends previously unspent
                outputs, and that the sum of the inputs is greater than the sum of the outputs.
                    Maxwell[Max16]introducedthenotionofaconﬁdential transaction, wheretheinputandoutput
                                                                                  `
                amounts in a transaction are hidden in Pedersen commitments [P 91]. To enable public validation,
                the transaction contains a zero-knowledge proof that the sum of the committed inputs is greater
                than the sum of the committed outputs, and that all the outputs are positive, namely they lie in
                                 n          n
                the interval r0,2 s, where 2  is much smaller than the group size. All current implementations of
                                                              `      `
                conﬁdential transactions [Max16,MP15,PBF ,NM 16] use range proofs over committed values,
                where the proof size is linear in n. These range proofs are the main contributor to the size of a
                conﬁdential transaction. In current implementations [Max16], a conﬁdential transaction with only
                two outputs and 32 bits of precision is 5.4 KB bytes, of which 5 KB are allocated to the range
                proof. Even with recent optimizations the range proofs would still take up 3.8 KB.
                                                                 3
                  We show in Section 6 that Bulletproofs greatly improve on this, even for a single range proof
              while simultaneously doubling the range proof precision at marginal additional cost (64 bytes). The
              logarithmic proof size additionally enables the prover to aggregate multiple range proofs, e.g. for
              transactions with multiple outputs, into a single short proof. With Bulletproofs, m range proofs
              are merely Oplogpmqq additional group elements over a single range proof. This is already useful
              for conﬁdential transactions in their current form as most Bitcoin transactions have two or more
              outputs. It also presents an intriguing opportunity to aggregate multiple range proofs from diﬀerent
              parties into one proof, as would be needed, for example, in a CoinJoin transaction [Max13]. In
              Section 4.5, we present a simple and eﬃcient MPC protocol that allows multiple users to generate a
              single transaction with a single aggregate range proof. The users do not have to reveal their secret
              transaction values to any of the other participants.
                                                                                      `
                  Conﬁdentialtransactionimplementationsareavailableinside-chains[PBF ], privateblockchains
              [And17], and in the popular privacy-focused cryptocurrency Monero [NM`16]. All these implemen-
              tations would beneﬁt from Bulletproofs.
                  At the time of writing, Bitcoin has roughly 50 million UTXOs from 22 million transactions (see
              statoshi.info). Using a 52-bit representation of bitcoin that can cover all values from 1 satoshi up
              to 21 million bitcoins, this results in roughly 160GB of range proof data using the current systems.
              Using aggregated Bulletproofs, the range proofs for all UTXOs would take less than 17GB, about
              a factor 10 reduction in size.
              Mimblewimble. Recentlyanimprovementwasproposedtoconﬁdentialtransactions, called Mim-
              blewimble [Jed16,Poe], which provides further savings.
                  Jedusor [Jed16] realized that a Pedersen commitment to 0 can be viewed as an ECDSA pub-
              lic key, and that for a valid conﬁdential transaction the diﬀerence between outputs, inputs, and
              transaction fees must be 0. A prover constructing a conﬁdential transaction can therefore sign the
              transaction with the diﬀerence of the outputs and inputs as the public key. This small change
              removes the need for a scriptSig which greatly simpliﬁes the structure of conﬁdential transactions.
              Poelstra [Poe] further reﬁned and improved Mimblewimble and showed that these improvements
              enable a greatly simpliﬁed blockchain in which all spent transactions can be pruned and new nodes
              can eﬃciently validate the entire blockchain without downloading any old and spent transactions.
              Along with further optimizations, this results in a highly compressed blockchain. It consists only
              of a small subset of the block-headers as well as the remaining unspent transaction outputs and
              the accompanying range proofs plus an un-prunable 32 bytes per transaction. Mimblewimble also
              allows transactions to be aggregated before sending them to the blockchain.
                  AMimblewimble blockchain grows with the size of the UTXO set. Using Bulletproofs, it would
              only grow with the number of transactions that have unspent outputs, which is much smaller than
              the size of the UTXO set. Overall, Bulletproofs can not only act as a drop-in replacement for
              the range proofs in conﬁdential transactions, but it can also help make Mimblewimble a practical
              scheme with a blockchain that is signiﬁcantly smaller than the current Bitcoin blockchain.
              1.2.2   Provisions
              Dagher et al. [DBB`15] introduced the Provisions protocol which allows Bitcoin exchanges to prove
              that they are solvent without revealing any additional information. The protocol crucially relies
              on range proofs to prevent an exchange from inserting fake accounts with negative balances. These
              range proofs, which take up over 13GB, are the main contributors to the proof sizes of almost 18GB
                                                           4
               for a large exchange with 2 million customers. The proof size is in fact linear in the number of
               customers. Since in this protocol, one party (the exchange) has to construct many range proofs
               at once, the general Bulletproofs protocol from Section 4.3 is a natural replacement for the NIZK
               proof used in Provisions. With the proof size listed in Section 6, we obtain that the range proofs
               would take up less than 2 KB with our protocol. Additionally, the other parts of the proof could
               be similarly compressed using the protocol from Section 5. The proof would then be dominated by
               one commitment per customer, with size 62 MB. This is roughly 300 times smaller then the current
               implementation of Provisions.
               1.2.3   Veriﬁable shuﬄes
               Consider two lists of committed values x ,...,x  and y ,...,y . The goal is to prove that the
                                                       1      n       1      n
               second list is a permutation of the ﬁrst. This problem is called a veriﬁable shuﬄe. It has many
               applications in voting [FS01,Nef01], mix-nets [Cha82], and solvency proofs [DBB`15]. Neﬀ [Nef01]
               gave a practical implementation of a veriﬁable shuﬄe and later work improved on it [Gro03,GI08a].
               Currently the most eﬃcient shuﬄe [BG12] has size Op?nq.
                  Bulletproofs can be used to create a veriﬁable shuﬄe of size Oplognq. The two lists of commit-
               ments are given as inputs to the circuit protocol from Section 5. The circuit can implement a shuﬄe
               bysorting the two lists and then checking that they are equal. A sorting circuit can be implemented
               using Opn¨logpnqq multiplications which means that the proof size will be only Oplogpnqq. This is
               much smaller than previously proposed protocols. Given the concrete eﬃciency of Bulletproofs, a
               veriﬁable shuﬄe using Bulletproofs would be very eﬃcient in practice. Constructing the proof and
               verifying it takes linear time in n.
               1.2.4   NIZK Proofs for Smart Contracts
               The Ethereum [Woo14] system uses highly expressive smart contracts to enable complex trans-
               actions. Smart contracts, like any other blockchain transaction, are public and provide no inher-
               ent privacy. To bring privacy to smart contracts, non-interactive zero-knowledge (NIZK) proofs
               have been proposed as a tool to enable complex smart contracts that do not leak the user in-
                          `
               puts [KMS 16,MSH17,CGGN17]. However, these protocols are limited as the NIZK proof itself
               is not suitable for veriﬁcation by a smart contract. The reason is that communication over the
               blockchain with a smart contract is expensive, and the smart contract’s own computational power
               is highly limited. SNARKs, which have succinct proofs and eﬃcient veriﬁers, seem like a natural
                                                           `
               choice, but current practical SNARKs [BSCG 13] require a complex trusted setup. The resulting
               common reference strings (CRS) are long, speciﬁc to each application, and possess trapdoors. In
                           `
               Hawk [KMS 16], for instance, a diﬀerent CRS is needed for each smart contract, and either a
               trusted party is needed to generate it, or an expensive multi-party computation is needed to dis-
               tribute the trust among a few parties. On the other hand, for small applications like boardroom
               voting, one can use classical sigma protocols [MSH17], but the proof-sizes and expensive veriﬁca-
               tion costs are prohibitive for more complicated applications. Recently, Campanelli et al. [CGGN17]
               showed how to securely perform zero-knowledge contingent payments (ZKCPs) in Bitcoin, while
               attacking and ﬁxing a previously proposed protocol [Max]. ZKCPs enable the trustless, atomic and
               eﬃcient exchange of a cryptocurrency vs. some digital good. While ZKCPs support a wide area
               of applications they fundamentally work for only a single designated veriﬁer and do not allow for
               public veriﬁcation. For some smart contracts that have more than two users, public veriﬁcation is
                                                             5
              often crucial. In an auction, for example, all bidders need to be convinced that all bids are well
              formed.
                  Bulletproofs improves on this by enabling small proofs that do not require a trusted setup.
              The Bulletproofs veriﬁer is not cheap, but there are multiple ways to work around this. First,
              a smart contract may act optimistically and only verify a proof if some party challenges its va-
              lidity. Incentives can be used to ensure that rational parties never create an incorrect proof nor
              challenge a correct proof. This can be further improved by using an interactive referee delegation
              model [CRR11], previously proposed for other blockchain applications [BGB17,TR]. In this model,
              the prover provides a proof along with a succinct commitment to the veriﬁer’s execution trace. A
              challenger that disagrees with the computation also commits to his computation trace and the two
              parties engage in an interactive binary search to ﬁnd the ﬁrst point of divergence in the computa-
              tion. The smart contract can then execute this single computation step and punish the party which
              provided a faulty execution trace. The intriguing property of this protocol is that even when a proof
              is challenged, the smart contract only needs to verify a single computation step, i.e. a single gate
              of the veriﬁcation circuit. In combination with small Bulletproofs, this can enable more complex
              but privacy preserving smart contracts. Like in other applications, these NIZK proofs would ben-
              eﬁt from the MPC protocol that we present in Section 4.5 to generate Bulletproofs distributively.
              Consider an auction smart contract where bidders in the ﬁrst round submit commitments to bids
              and in the second round open them. A NIZK can be used to prove properties about the bids,
              e.g. they are in some range, without revealing them. Using Bulletproofs’ MPC multiple bidders
              can combine their Bulletproofs into a single proof. Furthermore, the proof will hide which bidder
              submitted which bid.
              1.2.5   Short Non-Interactive Proofs for Arithmetic Circuits without a Trusted Setup
              Non-interactive zero-knowledge protocols for general statements are not possible without using a
              commonreferencestring, which should be known by both the prover and the veriﬁer. Many eﬃcient
              non-interactive zero-knowledge proofs and arguments for arithmetic circuit satisﬁability have been
                                                          `
              developed [Mic94,KP95,GS08,GGPR13,BSCG 13,BSBTHR18], and highly eﬃcient protocols are
              known. However, aside from their performance, these protocols diﬀer in the complexity of their
              commonreferencestrings. Some, such as those in [BSCG`13], are highly structured, and sometimes
              feature a trapdoor, while some are simply chosen uniformly at random. Security proofs assume
              that the common reference string was honestly generated. In practice, the common reference string
              can be generated by a trusted third party, or using a secure multi-party computation protocol. The
              latter helps to alleviate concerns about embedded trapdoors, as with the trusted setup ceremony
              used to generate the public parameters for [BSCG`14].
                  Zero-knowledgeSNARKshavebeenthesubjectofextensiveresearch[Gro10,BCCT12,GGPR13,
              BCCT13,PHGR16,BSCG`13,Gro16]. They generate constant-sized proofs for any statement, and
              have extremely fast veriﬁcation time. However, they have highly complex common reference strings
              which require lengthy and computationally intensive protocols [BGG17] to generate distributively.
              They also rely on strong unfalsiﬁable assumptions such as the knowledge-of-exponent assumption.
                  Auniformly-random common reference string, on the other hand, can be derived from common
              randomstrings, like the digits of π or by assuming that hash functions behave like a random oracle.
                                                                                                     `
              Examples of non-interactive protocols that do not require a trusted setup include [Mic94,BCC 16,
              BCG`17b,BSBC`17,BSBTHR18].
                                                               `                               `
                  Ben-Sasson et al. present a proof system [BCG 17a] and implementation [BSBC 17] called
                                                           6
               Scalable Computational Integrity (SCI). While SCI has a simple setup, and relies only on collision-
               resistant hash functions, the system is not zero-knowledge and still experiences worse performance
               than [BSCG`13,BCC`16]. The proof sizes are roughly 42 MB large in practice for a reasonable
               circuit. In subsequent work Ben-Sasson et al. presented STARKs [BSBTHR18], which are zero-
               knowledge and more eﬃcient than SCI. However even with these improvements the proof size is
                                                                                                       17
               still over 200 KB (and grows logarithmically) at only 60-bit security for a circuit of size 2 . A
               Bulletproof for such a circuit at twice the security would be only about 1 KB. Constructing STARKs
               is also costly in terms of memory requirements because of the large FFT that is required to make
               proving eﬃcient.
                  Ames et al. [AHIV17] presented a proof system with linear veriﬁcation time but only square
                                                                                          `
               root proof size building on the MPC in the head technique. Wahby [WTs ] recently present
               a cryptographic zero-knowledge proof system which achieves square root veriﬁer complexity and
               proof size based on the proofs for muggles [GKR08] techniques in combination with a sub-linear
               polynomial commitment scheme.
               1.3   Additional Related Work
               Much of the research related to electronic payments that predates Bitcoin [Nak08] focused on
               eﬃcient anonymous and conﬁdential payments [CHL05,Cha82] . With the advent of blockchain-
               based cryptocurrencies, the question of privacy and conﬁdentiality in transactions has gained a
               new relevance.  While the original Bitcoin paper [Nak08] claimed that Bitcoin would provide
               anonymity through pseudonymous addresses early work on Bitcoin showed that the anonymity
               is limited [MPJ`13,AKR`13]. Given these limitations, various methods have been proposed to
               help improve the privacy of Bitcoin transactions. CoinJoin [Max13], proposed by Maxwell, allows
               users to hide information about the amounts of transactions by merging two or more transactions.
               This ensures that among the participants who join their transactions, it is impossible to tell which
               transaction inputs correspond to which transaction outputs. However, users do require some way
               of searching for other users, and furthermore, should be able to do so without relying on a trusted
               third party. CoinShuﬄe [RMSK14] tried to fulﬁll this requirement by taking developing the ideas
               of CoinJoin and proposing a new Bitcoin mixing protocol which is completely decentralized. Mon-
               ero [Mon] is a cryptocurrency which employs cryptographic techniques to achieve strong privacy
               guarantees. These include stealth addresses, ring-signatures [vS13], and ring conﬁdential transac-
                         `                     `
               tions [NM 16]. ZeroCash [BSCG 14] oﬀers optimal privacy guarantees but comes at the cost of
               expensive transaction generation and the requirement of a trusted setup.
               Rangeproofs. Rangeproofsareproofsthatasecretvalue,whichhasbeenencryptedorcommitted
               to, lies in a certain interval. Range proofs do not leak any information about the secret value, other
               than the fact that they lie in the interval. Lipmaa [Lip03] presents a range proof which uses integer
               commitments, and Lagrange’s four-square theorem which states that every positive integer y can
               be expressed as a sum of four squares. Groth [Gro05] notes that the argument can be optimized by
               considering 4y ` 1, since integers of this form only require three squares. The arguments require
               only a constant number of commitments. However, each commitment is large, as the security of
               the argument relies on the Strong RSA assumption. Additionally, a trusted setup is required to
               generate the RSA modulus or a prohibitively large modulus needs to be used [San99]. Camenisch
               et al. [CCs08] use a diﬀerent approach. The veriﬁer provides signatures on a small set of digits.
               The prover commits to the digits of the secret value, and then proves in zero-knowledge that the
                                                             7
               value matches the digits, and that each commitment corresponds to one of the signatures. They
               show that their scheme can be instantiated securely using both RSA accumulators [BdM93] and
               the Boneh-Boyen signature scheme [BB04]. However, these range proofs require a trusted setup.
               Approaches based on the n-ary digits of the secret value are limited to proving that the secret value
                                           “   k    ‰
               is in an interval of the form 0,n ´ 1 . One can produce range proofs for more general intervals by
               using homomorphic commitments to translate intervals, and by using a combination of two diﬀerent
               range proofs to conduct range proofs for intervals of diﬀerent widths. However, [CLas10] presented
               an alternative digital decomposition which enables an interval of general width to be handled using
               a single range proof.
               2    Preliminaries
               Before we present Bulletproofs, we ﬁrst review some of the underlying tools. In what follows, a
               PPTadversary A is a probabilistic interactive Turing Machine that runs in polynomial time in the
               security parameter λ. We will drop the security parameter λ from the notation when it is implicit.
               2.1    Assumptions
               Deﬁnition 1 (Discrete Log Relation). For all PPT adversaries A and for all n ě 2 there exists a
               negligible function µpλq such that
                               «                             $                   n        ﬀ
                                 G“Setupp1λq, g ,...,g ÐÝ G;                    ź a
                             P                     1      n          : Da ‰ 0^     g i “ 1  ďµpλq
                                 a ,...,a P Z Ð ApG,g ,...,g q          i           i
                                   1      n    p          1      n              i“1
                           ś
                             n    a
                   Wesay        g i “ 1 is a non trivial discrete log relation between g ,...,g . The Discrete Log
                             i“1 i                                                    1      n
               Relation assumption states that an adversary can’t ﬁnd a non-trivial relation between randomly
               chosen group elements. For n ě 1 this assumption is equivalent to the discrete-log assumption.
               2.2    Commitments
               Deﬁnition 2 (Commitment). A non-interactive commitment scheme consists of a pair of proba-
                                                                                                     λ
               bilistic polynomial time algorithms pSetup,Comq. The setup algorithm pp Ð Setupp1 q generates
               public parameters pp for the scheme, for security parameter λ. The commitment algorithm Compp
               deﬁnes a function M    ˆR ÑC formessagespaceM ,randomnessspaceR andcommitment
                                   pp    pp     pp                     pp                    pp
                                                                                              $
               space Cpp determined by pp. For a message x P Mpp, the algorithm draws r ÐÝ Rpp uniformly at
               random, and computes commitment com “ Com px;rq.
                                                                pp
                   For ease of notation we write Com “ Com .
                                                             pp
               Deﬁnition 3 (Homomorphic Commitments). A homomorphic commitment scheme is a non-
               interactive commitment scheme such that M ,R         and C     are all abelian groups, and for all
                                                             pp  pp        pp
               x ,x P M , r ,r P R , we have
                 1  2    pp   1  2    pp
                                       Compx ;r q`Compx ;r q “ Compx `x ;r `r q
                                             1  1           2  2           1    2  1   2
                                                               8
                        Deﬁnition 4 (Hiding Commitment). A commitment scheme is said to be hiding if for all PPT
                        adversaries A there exists a negligible function µpλq such that.
                                              ˇ   »          ˇ                        λ                                                 ﬁ         ˇ
                                              ˇ              ˇ pp Ð Setupp1 q;                                                                    ˇ
                                              ˇ              ˇ                                                                                 1ˇ
                                              ˇ   —         1ˇ                     2                       $                $           ﬃ         ˇ
                                              ˇP–b“bˇ px ,x q P M                      ÐApppq,bÐÝt0,1u,r ÐÝ R , ﬂ´ ˇďµpλq
                                              ˇ              ˇ     0     1         pp                                             pp           2ˇ
                                              ˇ              ˇ                                  1                                                 ˇ
                                                                com“Compx ;rq,b ÐAppp,comq
                                                                                       b
                        where the probability is over b,r,Setup and A. If µpλq “ 0 then we say the scheme is perfectly
                        hiding.
                        Deﬁnition 5 (Binding Commitment). A commitment scheme is said to be binding if for all PPT
                        adversaries A there exists a negligible function µ such that.
                                               „                                                             ˇ                      λ             
                                                                                                             ˇ pp Ð Setupp1 q,
                                            P Compx ;r q “ Compx ;r q^x ‰x ˇ                                                                         ďµpλq
                                                             0   0                  1    1        0        1ˇx ,x ,r ,r Ð Apppq
                                                                                                                0     1   0    1
                        where the probability is over Setup and A. If µpλq “ 0 then we say the scheme is perfectly binding.
                              In what follows, the order p of the groups used is implicitly dependent on the security parameter
                        λ to ensure that discrete log in these groups is intractable for PPT adversaries.
                        Deﬁnition 6 (Pedersen Commitment). M ,R                                         “Z , C          “Goforder p.
                                                                                            pp     pp         p     pp
                                            $
                        Setup : g,h ÐÝ G
                                                x r
                        Compx;rq “ pg h q
                                                                                                                  n
                        Deﬁnition 7 (Pedersen Vector Commitment). M                                         “Z , R           “Z , C           “Gwith G of order p
                                                                                                        pp        p      pp        p      pp
                                                                   $
                        Setup : g “ pg ,...,g q,h ÐÝ G
                                               1          n                          ś
                                                                      r x          r        xi
                        Compx“px ,...,x q;rq “ h g “ h                                    g     P G
                                            1          n                                i   i
                              The Pedersen vector commitment is perfectly hiding and computationally binding under the
                        discrete logarithm assumption. We will often set r “ 0, in which case the commitment is binding
                        but not hiding.
                        2.3        Zero-Knowledge Arguments of Knowledge
                        Bulletproofs are zero-knowledge arguments of knowledge. A zero-knowledge proof of knowledge is a
                        protocol in which a prover can convince a veriﬁer that some statement holds without revealing any
                        information about why it holds. A prover can for example convince a veriﬁer that a conﬁdential
                        transaction is valid without revealing why that is the case, i.e. without leaking the transacted
                        values. An argument is a proof which holds only if the prover is computationally bounded and
                        certain computational hardness assumptions hold. We now give formal deﬁnitions.
                              Wewill consider arguments consisting of three interactive algorithms pSetup,P,Vq, all running
                        in probabilistic polynomial time. These are the common reference string generator Setup, the prover
                                                                              λ
                        P, and the veriﬁer V. On input 1 , algorithm Setup produces a common reference string σ. The
                        transcript produced by P and V when interacting on inputs s and t is denoted by tr Ð xPpsq,Vptqy.
                        Wewrite xPpsq,Vptqy “ b depending on whether the veriﬁer rejects, b “ 0, or accepts, b “ 1.
                              Let R Ă t0,1u˚ ˆ t0,1u˚ ˆ t0,1u˚ be a polynomial-time-decidable ternary relation. Given σ,
                        we call w a witness for a statement u if pσ,u,wq P R, and deﬁne the CRS-dependent language
                                                                               Lσ “tx | Dw : pσ,x,wq P Ru
                        as the set of statements x that have a witness w in the relation R.
                                                                                                     9
               Deﬁnition 8 (Argument of Knowledge). The triple pSetup,P,Vq is called an argument of knowl-
               edge for relation R if it satisﬁes the following two deﬁnitions.
               Deﬁnition 9 (Perfect completeness). pSetup,P,Vq has perfect completeness if for all non-uniform
               polynomial time adversaries A
                               „                                        ˇ            λ 
                                                                        ˇ σ Ð Setupp1 q
                             P pσ,u,wqRR or xPpσ,u,wq,Vpσ,uqy “ 1 ˇ                       “1
                                                                        ˇ pu,wq Ð Apσq
               Deﬁnition 10 (Computational Witness-Extended Emulation). pSetup,P,Vq has witness-extended
               emulation if for all deterministic polynomial time P˚ there exists an expected polynomial time
               emulator E such that for all pairs of interactive adversaries A1,A2 there exists a negligible function
               µpλq such that
                         ˇ  „           ˇ            λ                                  ˇ
                         ˇ              ˇ σ Ð Setupp1 q,pu,sq Ð A2pσq,                   ˇ
                         ˇ              ˇ                                                ˇ
                          P A1ptrq “ 1           ˚                        ´
                         ˇ              ˇ tr Ð xP pσ,u,sq,Vpσ,uqy                        ˇ
                         ˇ                                                               ˇ
                         ˇ                                                               ˇ
                         ˇ  »                                      ˇ             λ     ﬁ ˇ ď µpλq
                         ˇ                                         ˇ σ Ð Setupp1 q,      ˇ
                         ˇ     A1ptrq “ 1                          ˇ                     ˇ
                         ˇ P–                                      ˇ pu,sq Ð A2pσq,    ﬂ ˇ
                         ˇ     ^ptr is accepting ùñ pσ,u,wq P Rq ˇ             O         ˇ
                         ˇ                      ˚                  ˇ ptr,wq Ð E pσ,uq    ˇ
               where the oracle is given by O “ xP pσ,u,sq,Vpσ,uqy, and permits rewinding to a speciﬁc point and
               resuming with fresh randomness for the veriﬁer from this point onwards. We can also deﬁne com-
               putational witness-extended emulation by restricting to non-uniform polynomial time adversaries
               A1 and A2.
                  We use witness-extended emulation to deﬁne knowledge-soundness as used for example in
               [BCC`16] and deﬁned in [GI08b,Lin03]. Informally, whenever an adversary produces an argu-
               ment which satisﬁes the veriﬁer with some probability, then there exists an emulator producing an
               identically distributed argument with the same probability, but also a witness. The value s can
               be considered to be the internal state of P˚, including randomness. The emulator is permitted
               to rewind the interaction between the prover and veriﬁer to any move, and resume with the same
               internal state for the prover, but with fresh randomness for the veriﬁer. Whenever P˚ makes a
               convincing argument when in state s, E can extract a witness, and therefore, we have an argument
               of knowledge of w such that pσ,u,wq P R.
               Deﬁnition 11 (Public Coin). An argument of knowledge pSetup,P,Vq is called public coin if all
               messages sent from the veriﬁer to the prover are chosen uniformly at random and independently of
               the prover’s messages, i.e., the challenges correspond to the veriﬁer’s randomness ρ.
                  Anargumentof knowledge is zero knowledge if it does not leak information about w apart from
               what can be deduced from the fact that pσ,x,wq P R. We will present arguments of knowledge that
               have special honest-veriﬁer zero-knowledge. This means that given the veriﬁer’s challenge values,
               it is possible to eﬃciently simulate the entire argument without knowing the witness.
               Deﬁnition 12 (Perfect Special Honest-Veriﬁer Zero-Knowledge). A public coin argument of knowl-
               edge pSetup,P,Vq is a perfect special honest veriﬁer zero knowledge (SHVZK) argument of knowl-
               edge for R if there exists a probabilistic polynomial time simulator S such that for all pairs of
                                                            10
              interactive adversaries A1,A2
                             „                            ˇ            λ                   
                                                          ˇ σ Ð Setupp1 q,pu,w,ρq Ð A2pσq,
                           Pr  pσ,u,wq P R and A ptrq “ 1 ˇ
                                                 1        ˇ tr Ð xPpσ,u,wq,Vpσ,u;ρqy
                             „                            ˇ            λ                   
                                                          ˇ σ Ð Setupp1 q,pu,w,ρq Ð A2pσq,
                         “Pr pσ,u,wqPR and A1ptrq“1 ˇ
                                                          ˇ tr Ð Spu,ρq
              where ρ is the public coin randomness used by the veriﬁer.
                 In this deﬁnition the adversary chooses a distribution over statements and witnesses but is
              still not able to distinguish between the simulated and the honestly generated transcripts for valid
              statements and witnesses.
                 We now deﬁne range proofs, which are proofs that the prover knows an opening to a commit-
              ment, such that the committed value is in a certain range. Range proofs can be used to show that
              an integer commitment is to a positive number or that two homomorphic commitments to elements
              in a ﬁeld of prime order will not overﬂow modulo the prime when they are added together.
              Deﬁnition 13 (Zero-Knowledge Range Proof). Given a commitment scheme pSetup,Comq over a
              message space M   which is a set with a total ordering, a Zero-Knowledge Range Proof is a SHVZK
                             pp
              argument of knowledge for the relation RRange:
                          RRange : ppp,pcom,l,rq,px,ρqq P RRange Ø com “ Compx;ρq^l ď x ă r
              2.4   Notation
              Let G denote a cyclic group of prime order p, and let Zp denote the ring of integers modulo p. Let
                n      n                                                                ‹
              G and Zp be vector spaces of dimension n over G and Zp respectively. Let Zp denote Zpzt0u.
              Generators of G are denoted by g,h,v,u P G. Group elements which represent commitments are
                                                                               a α
              capitalized and blinding factors are denoted by Greek letters, i.e. C “ g h P G is a Pedersen com-
              mitment to a. If not otherwise clear from context x,y,z P Z‹ are uniformly distributed challenges.
                                                                    p
                 $  ‹                                               ‹
              x ÐÝ Zp denotes the uniform sampling of an element from Zp. Throughout the paper, we will also
              be using vector notations deﬁned as follows. Bold font denotes vectors, i.e. a P Fn is a vector
              with elements a ,...,a P F. Capitalized bold font denotes matrices, i.e. A P Fnˆm is a matrix
                             1     n
              with n rows and m columns such that a  is the element of A in the ith row and jth column. For
                                                  i,j
              a scalar c P Zp and a vector a P Zn, we denote by b “ c ¨ a P Zn the vector where bi “ c ¨ ai.
                                      řn       p                           p
              Furthermore, let xa,by “    a ¨b denotes the inner product between two vectors a,b P Fn and
                                       i“1 i   i
              a˝b“pa ¨b ,...,a ¨b q P Fn the Hadamard product or entry wise multiplication of two vectors.
                       1  1      n  n                    ř
                 We also deﬁne vector polynomials ppXq “  d  p ¨ Xi P ZnrXs where each coeﬃcient p is a
                                                          i“0  i       p                          i
              vector in Zn. The inner product between two vector polynomials lpXq,rpXq is deﬁned as
                        p
                                                      d  i
                                       xlpXq,rpXqy “ ÿ ÿxl ,r y¨Xi`j P ZprXs                        (1)
                                                            i  j
                                                     i“0j“0
              Let tpXq “ xlpXq,rpXqy, then the inner product is deﬁned such that tpxq “ xlpxq,rpxqy holds for
              all x P Zp, i.e. evaluating the polynomials at x and then taking the inner product is the same as
              evaluating the inner product polynomial at x.
                                                         11
                                                                                                                                                                                ś
                                                                                                           n                       n                                   a             n        a
                                       For a vector g “ pg ,...,g q P G and a P Z we write C “ g “                                                                                          g i P G. This quantity
                                                                               1              n                                    p                                                 i“1 i
                                                                                                                                                                n
                                is a binding (but not hiding) commitment to the vector a P Z . Given such a commitment C and
                                                                                                                                                                p
                                a vector b P Zn with non-zero entries, we can treat C as a new commitment to a ˝ b. To so do,
                                                              p
                                                              ´1                                      ś
                                                1          pb     q                                       n          1  a ¨b
                                deﬁne g “ g i                         such that C “                              pg q i i. The binding property of this new commitment is
                                                i          i                                              i“1        i
                                inherited from the old commitment.
                                                                                                                                                              n                       m                                 n`m
                                       Let a}b denote the concatenation of two vectors: if a P Z and b P Z                                                                                 then a}b P Z                         . For
                                                                                                                                                              p                       p                                 p
                                0 ď ℓ ď n, we use Python notation to denote slices of vectors:
                                                                                                                        ℓ                                                              n´ℓ
                                                                           a        “pa ,...,a q P F ,                               a        “pa             , . . . , a    q P F            .
                                                                             r:ℓs            1              ℓ                           rℓ:s            ℓ`1                n
                                For k P Z‹ we use kn to denote the vector containing the ﬁrst n powers of k, i.e.
                                                   p
                                                                                                   kn “ p1,k,k2,...,kn´1q P pZ‹qn.
                                                                                                                                                               p
                                For example, 2n “ p1,2,4,...,2n´1q. Equivalently k´n “ pk´1qn “ p1,k´1,...,k´n`1q.
                                                                                                                                                   (
                                       Finally, we write pPublic Input;Witnessq : Relation to denote the relation Relation using the
                                speciﬁed Public Input and Witness.
                                3         Improved Inner-Product Argument
                                                                     `
                                Bootle et al. [BCC 16] introduced a communication eﬃcient inner-product argument and show how
                                it can be leveraged to construct zero-knowledge proofs for arithmetic circuit satisﬁability with low
                                communication complexity. The argument is an argument of knowledge that the prover knows the
                                openings of two binding Pedersen vector commitments that satisfy a given inner product relation.
                                       Wereduce the communication complexity of the argument from 6log2pnq in [BCC`16] to only
                                2log2pnq, where n is the dimension of the two vectors. We achieve this improvement by modifying
                                the relation being proved. Our argument is sound, but is not zero-knowledge. We then show that
                                this protocol gives a public-coin, communication eﬃcient, zero-knowledge range proof on a set of
                                committed values, and a zero-knowledge proof system for arbitrary arithmetic circuits (Sections 4
                                and 5). By applying the Fiat-Shamir heuristic we obtain short non-interactive proofs (Section 4.4).
                                                                                                                                                                                                                                  n
                                Overview. The inputs to the inner-product argument are independent generators g,h P G , a
                                scalar c P Zp, and P P G. The argument lets the prover convince a veriﬁer that the prover knows
                                two vectors a,b P Zn such that
                                                                         p
                                                                                                                a b
                                                                                                   P “g h                        and              c “ xa,by.
                                Werefer to P as a binding vector commitment to a,b. Throughout the section we assume that the
                                dimension n is a power of 2. If need be, one can easily pad the inputs to ensure that this holds.
                                       Moreprecisely, the inner product argument is an eﬃcient proof system for the following relation:
                                                                                     n                                                       n                       a b                              (
                                                                  pg,h P G , P P G, c P Zp ; a,b P Zpq :                                                P “g h ^c“xa,by .                                                           (2)
                                Thesimplest proof system for (2) is one where the prover sends the vectors a,b P Zn to the veriﬁer.
                                                                                                                                                                                                          p
                                The veriﬁer accepts if these vectors are a valid witness for (2). This is clearly sound, however, it
                                requires sending 2n elements to the veriﬁer. Our goal is to send only 2log2pnq elements.
                                                                                                                                   12
                             We show how to do this when the inner product c “ xa,by is given as part of the vector
                       commitment P. That is, for a given P P G, the prover proves that it has vectors a,b P Zn for
                                                                                                                                                                    p
                                           a b       xa,by
                       which P “ g h ¨u                    . More precisely, we design a proof system for the relation:
                                                                      n                                n                 a b       xa,by(
                                                         pg,h P G , u,P P G ; a,b P Zp q : P “ g h ¨u                                      .                           (3)
                       WeshowinProtocol 1 below that a proof system for (3) gives a proof system for (2) with the same
                       complexity. Hence, it suﬃces to give a proof system for (3).
                             To give some intuition for how the proof system for the relation (3) works let us deﬁne a hash
                                              2n`1                                              1                                                    n
                       function H : Zp               ÑGasfollows. First, set n “ n{2 and ﬁx generators g,h P G ,u P G. Then
                                                                                                         1
                       the hash function H takes as input a ,a ,b ,b1 P Zn and c P Z , and outputs
                                                                               1    2     1     2      p                 p
                                                                                                      1                   1
                                                                  1          1             a        a         b         b         c
                                                      Hpa ,a ,b ,b ,cq “ g 1 ¨g 2 ¨h 1 ¨h 2 ¨u                                        P G.
                                                             1     2    1     2               1        1         1         1
                                                                                           r:n s    rn :s     r:n s     rn :s
                                                                                                         `      1       1          1       1             ˘
                       Now, using the setup in (3), we can write P as P “ H a                                     , a      , b       , b      , xa,by . Note that
                       His additively homomorphic in its inputs, i.e.                                        r:n s    rn :s     r:n s    rn :s
                                    1          1                     1           1                                1       1                     1        1
                        Hpa ,a ,b ,b ,c q¨Hpa ,a ,b ,b ,c q “ Hpa `a , a `a , b `b , b `b , c `c q.
                               1     1    1     1    1          2     2     2     2   2             1       2      1       2      1       2      1        2    1       2
                       Consider the following protocol for the relation (3), where P P G is given as input:
                             • The prover computes L,R P G as follows:
                                                                                       `       1                             1                         ˘
                                                                            L “H 0n, a 1, b 1 , 0n, xa 1 ,b 1 y
                                                                                       `              r:n s     rn :s                 r:n s    rn :s   ˘
                                                                                                         1         1
                                                                           R “H a 1 , 0n,                       0n ,    b 1 , xa 1 ,b 1 y
                                                                                       `    rn :s                          r:n s      rn :s    r:n s   ˘
                                                  and recall that          P “H a 1, a 1 , b 1 , b 1 ,                                  xa,by            .
                                                                                            r:n s     rn :s     r:n s      rn :s
                                It sends L,R P G to the veriﬁer.
                                                                                   $
                             • The veriﬁer chooses a random x ÐÝ Zp and sends x to the prover.
                                                                                                             1                                                      1
                                                                     1            1       ´1      1        n                1       ´1       1            1       n
                             • The prover computes                 a “xa             `x a             P Z        and b “x b                    `xb           P Z
                                                                               r:n s            rn :s      p                             r:n s         rn :s      p
                                                               1
                                                  1    1     n
                                and sends a ,b P Zp to the veriﬁer.
                                                                                                            2               ´2
                                                     1    1                                       1       px q           px    q
                             • Given pL,R,a ,b q, the veriﬁer computes P “ L                                    ¨ P ¨ R          and outputs “accept” if
                                                                        1        ` ´1 1           1       1    ´1 1         1    1 ˘
                                                                     P “H x a, xa, xb, x b, xa,by .                                                                    (4)
                       It is easy to verify that a proof from an honest prover will always be accepted. Indeed, the left
                       hand side of (4) is
                          x2         x´2          `      1       ´2      1       2      1          1       2     1            1         1        ´2       1        1    1 ˘
                       L ¨P¨R             “H a             `x a , x a                      `a , x b                  `b , b                `x b , xa,by
                                                     r:n s            rn :s          r:n s      rn :s          rn :s      r:n s       rn :s            r:n s
                       which is the same as the right hand side of (4).
                                                                                                                                                 1   1
                             In this proof system, the proof sent from the prover is the four tuple pL,R,a ,b q and contains
                       only n `2 elements. This is about half the length of the trivial proof where the prover sends the
                       complete a,b P Zn to the veriﬁer.
                                                  p
                                                                                                13
                             To see why this protocol is a proof system for (3) we show how to extract a valid witness
                       a,b P Zn from a successful prover. After the prover sends L,R we rewind the prover three times
                                   p                             1     1
                       to obtain three tuples px ,a ,b q for i “ 1,...,3, where each tuple satisﬁes (4), namely
                                                            i     i    i
                                                        2              ´2             ´1                              ´1
                                                     px q            px   q                 1         1        1            1       1    1
                                                   L i ¨P ¨R i              “Hpx a , xa , x b , x b , xa ,b yq.                                                       (5)
                                                                                      i      i     i  i     i   i     i      i       i    i
                       Assuming x ‰ ˘x for 1 ď i ă j ď 3, we can ﬁnd ν ,ν ,ν P Z such that
                                         i         j                                                 1    2    3      p
                                                            3                             3                          3
                                                          ÿ 2                            ÿ                          ÿ ´2
                                                               x ν “0 and                    ν “1 and                   x ν “0.
                                                                 i  i                          i                          i     i
                                                          i“1                            i“1                       i“1
                       Then setting
                                              3                                                                3
                                             ÿ            ´1 1                 1         n                    ÿ               1            ´1 1           n
                                      a“ pν ¨x a , ν ¨xa qPZ                                  and b“              pν ¨ x b , ν ¨x             b q P Z
                                                    i     i     i      i    i   i        p                           i    i    i     i     i     i        p
                                             i“1                                                              i“1
                                                            `                                     ˘                     ř
                       we obtain that P “ H a 1 ,a 1 ,b 1 ,b 1 ,c where c “                                                3    ν ¨ xa1 ,b1 y.        We will show
                                                                r:n s    rn :s   r:n s    rn :s                            i“1 i          i     i
                       in the proof of Theorem 1 below that with one additional rewinding, to obtain a fourth relation
                       satisfying (5), we must have c “ xa,by with high probability. Hence, the extracted a,b are a valid
                       witness for the relation (3), as required.
                       Shrinking the proof by recursion. Observe that the test in (4) is equivalent to testing that
                                                                     ´                  ¯ 1    ´                   ¯ 1
                                                                          ´1              a                     ´1 b           1  1
                                                               1         x         x                x         x              xa ,b y
                                                             P “ g 1 ˝g 1                     ¨  h 1 ˝h 1                ¨ u        .
                                                                         r:n s     rn :s            r:n s     rn :s
                                                                                                    1   1
                       Hence, instead of the prover sending the vectors a ,b to the veriﬁer, they can recursively engage
                                                                                                                           ´1                            ´1
                                                                            1                                             x        x         x         x
                       in an inner-product argument for P with respect to generators pg                                      1 ˝g 1 , h 1 ˝h 1 , uq. The
                                                                             1                                            r:n s    rn :s     r:n s     rn :s
                       dimension of this problem is only n “ n{2.
                             Theresulting log2n depth recursive protocol is shown in Protocol 2. This log2n round protocol
                       is public coin and can be made non-interactive using the Fiat-Shamir heuristic. The total com-
                       munication of Protocol 2 is only 2rlog2pnqs elements in G plus 2 elements in Zp. Speciﬁcally, the
                       prover sends the following terms:
                                                                      pL ,R q, ..., pL                 , R        q,   a,b
                                                                          1    1                log2 n     log2 n
                       where a,b P Zp are sent at the tail of the recursion. The prover’s work is dominated by 8n group
                       exponentiations and the veriﬁer’s work by 4n exponentiations. In Section 3.1 we present a more
                       eﬃcient veriﬁer that performs only 1 multi-exponentiation of size 2n ` 2logpnq. In Section 6 we
                       present further optimizations.
                       Proving security. The inner product protocol for the relation (2) is presented in Protocol 1.
                       This protocol uses internally a ﬁxed group element u P G for which there is no known discrete-
                       log relation among g,h,u. The heart of Protocol 1 is Protocol 2 which is a proof system for the
                       relation (3). In Protocol 1 the element u is raised to a veriﬁer chosen power x to ensure that the
                       extracted vectors a,b from Protocol 2 satisfy xa,by “ c.
                       The following theorem shows that Protocol 1 is a proof system for (2).
                                                                                               14
                                           PIP’s input: pg,h,P,c,a,bq
                                           V ’s input: pg,h,P,cq
                                             IP
                                                                           $   ‹
                                                                   V :xÐÝZ                                        (6)
                                                                    IP         p
                                                               V ÑP :x                                            (7)
                                                                IP     IP
                                                                         1       x¨c
                                                                       P “P¨u                                     (8)
                                                                                 x   1
                                              Run Protocol 2 on Input pg,h,u ,P ; a,bq                            (9)
                Protocol 1: Proof system for Relation (2) using Protocol 2. Here u P G is a ﬁxed group element
                                                                    n
                with an unknown discrete-log relative to g,h P G .
                Theorem 1 (Inner-Product Argument). The argument presented in Protocol 1 for the relation (2)
                has perfect completeness and statistical witness-extended-emulation for either extracting a non-
                trivial discrete logarithm relation between g,h,u or extracting a valid witness a,b.
                The proof for Theorem 1 is given in Appendix B.
                3.1    Inner-Product Veriﬁcation through Multi-Exponentiation
                Protocol 2 has a logarithmic number of rounds and in each round the prover and veriﬁer compute
                                           1   1
                a new set of generators g ,h . This requires a total of 4n exponentiations: n in the ﬁrst round,
                 n in the second and     n  in the jth. We can reduce the number of exponentiations to a single
                 2                      j´1
                                       2
                multi-exponentiation of size 2n by delaying all the exponentiations until the last round. This
                technique provides a signiﬁcant speed-up if the proof is compiled to a non interactive proof using
                the Fiat-Shamir heuristic (as in Section 4.4).
                    Let g and h be the generators used in the ﬁnal round of the protocol and x be the challenge
                                                                                                    j
                                                                                    a b a¨b
                from the jth round. In the last round the veriﬁer checks that g h u         “P, where a,b P Zp are
                given by the prover. By unrolling the recursion we can express these ﬁnal g and h in terms of the
                input generators g,h P Gn as:
                                                      n                    n
                                                     ź s                  ź 1{si
                                                g “     g i P G,     h“      h     P G
                                                         i                     i
                                                     i“1                  i“1
                wheres “ ps ,...,s q P Zn onlydependsonthechallengespx ,...,x                q. Thescalarss ,...,s P
                             1       n     p                                   1       log2pnq              1       n
                Zp are calculated as follows:
                                             log2pnq                              #
                                               ź bpi,jq                             1    the jth bit of i ´ 1 is 1
                     for i “ 1,...,n:   s “        x          where      bpi,jq “
                                         i           j                              ´1 otherwise
                                               j“1
                Nowtheentireveriﬁcationcheckintheprotocolreducestothefollowingsinglemulti-exponentiation
                                                                  15
                                                                           n                              n
                                                   input: pg,h P G ,u,P P G ; a,b P Zpq                                                                            (10)
                                                             PIP’s input: pg,h,u,P,a,bq                                                                            (11)
                                                             VIP’s input: pg,h,u,Pq                                                                                (12)
                                                  output:tVIP accepts or VIP rejectsu                                                                              (13)
                                                             if n “ 1 :                                                                                            (14)
                                                                    P ÑV :a,bPZp                                                                                   (15)
                                                                       IP        IP
                                                                    V computes c “ a¨b and checks if P “ gahbuc:                                                   (16)
                                                                      IP
                                                                           if yes, VIP accepts; otherwise it rejects                                               (17)
                                                             else: pn ą 1q                                                                                         (18)
                                                             PIP computes:                                                                                         (19)
                                                                      1     n
                                                                    n “ 2                                                                                          (20)
                                                                    c “xa 1 ,b 1 yPZp                                                                              (21)
                                                                      L         r:n s    rn :s
                                                                    c    “xa 1 ,b 1 y P Zp                                                                         (22)
                                                                      R         rn :s    r:n s
                                                                             a 1      b 1
                                                                               r:n s    rn :s cL
                                                                    L“g 1 h 1 u PG                                                                                 (23)
                                                                             rn :s    r:n s
                                                                              a 1     b 1
                                                                    R“g rn:sh r:nsucR P G                                                                          (24)
                                                                                 1       1
                                                                             r:n s    rn :s
                                                             P ÑV :L,R                                                                                             (25)
                                                                IP        IP
                                                                          $    ‹
                                                             VIP : x ÐÝ Zp                                                                                         (26)
                                                             V ÑP :x                                                                                               (27)
                                                               IP         IP
                                                             P andV compute:                                                                                       (28)
                                                                IP          IP
                                                                               ´1                    1
                                                                      1       x         x           n
                                                                    g “g 1 ˝g 1 PG                                                                                 (29)
                                                                              r:n s     rn :s
                                                                                          ´1          1
                                                                      1       x          x          n
                                                                    h “h 1 ˝h 1 PG                                                                                 (30)
                                                                              r:n s      rn :s
                                                                                2        ´2
                                                                       1       x       x
                                                                    P “L PR                  P G                                                                   (31)
                                                             PIP computes:                                        1                                                (32)
                                                                      1          1              1      ´1        n
                                                                    a “a            ¨ x ` a        ¨ x      P Z                                                    (33)
                                                                              r:n s          rn :s               p 1
                                                                      1          1      ´1          1             n
                                                                    b “b            ¨ x     `b          ¨ x P Z                                                    (34)
                                                                              r:n s               rn :s           p     1    1        1   1    1
                                                             recursively run Protocol 2 on input pg ,h ,u,P ;a ,b q                                                (35)
                                                              Protocol 2: Improved Inner-Product Argument
                                                                                                16
                of size 2n ` 2log2pnq ` 1:
                                                                      log2pnq          ´2
                                                                       ź 2 px q
                                                       ´1       ?             px q
                                               a¨s   b¨s    a¨b                j       j
                                              g   ¨ h     ¨ u   “P¨         L     ¨ R     .
                                                                              j      j
                                                                       j“1
                Because a multi-exponentiation can be done much faster than n separate exponentiations, as we
                discuss in Section 6, this leads to a signiﬁcant savings.
                4     Range Proof Protocol with Logarithmic Size
                Wenowpresent a novel protocol for conducting short and aggregatable range proofs. The protocol
                uses the improved inner product argument from Protocol 1. First, in Section 4.1, we describe how
                to construct a range proof that requires the veriﬁer to check an inner product between two vectors.
                Then, in Section 4.2, we show that this check can be replaced with an eﬃcient inner-product
                argument. In Section 4.3, we show how to eﬃciently aggregate m range proofs into one short proof.
                In Section 4.4, we discuss how interactive public coin protocols can be made non-interactive by
                using the Fiat-Shamir heuristic, in the random oracle model. In Section 4.5 we present an eﬃcient
                MPCprotocol that allows multiple parties to construct a single aggregate range proof. Finally, in
                Section 4.6, we discuss an extension that enables a switch to quantum-secure range proofs in the
                future.
                4.1    Inner-Product Range Proof
                Wepresent a protocol which uses the improved inner-product argument to construct a range proof.
                The proof convinces the veriﬁer that a commitment V contains a number v that is in a certain
                range, without revealing v. Bootle et al. [BCC`16] give a proof system for arbitrary arithmetic
                circuits, and in Section 5 we show that our improvements to the inner product argument also
                transfer to this general proof system. It is of course possible to prove that a commitment is in a
                                                                                   `
                given range using an arithmetic circuit, and the work of [BCC 16] could be used to construct an
                asymptotically logarithmic sized range proof (in the length of v). However, the circuit would need
                to implement the commitment function, namely a multi-exponentiation for Pedersen commitments,
                leading to a large complex circuit.
                    Weconstruct a range proof more directly by exploiting the fact that a Pedersen commitment V
                is an element in the same group G that is used to perform the inner product argument. We extend
                this idea in Section 5 to construct a proof system for circuits that operate on committed inputs.
                    Formally, let v P Zp and let V P G be a Pedersen commitment to v using randomness γ. The
                                                                      n
                proof system will convince the veriﬁer that v P r0,2 ´1s. In other words, the proof system proves
                the following relation which is equivalent to the range proof relation in Deﬁnition 13:
                                                                           γ v            n     (
                                        pg,h P G,V,n ; v,γ P Z q : V “ h g ^v P r0,2 ´1s .                         (36)
                                                                p
                Let a “ pa ,...,a q P t0,1un be the vector containing the bits of v, so that xa ,2ny “ v. The
                      L      1       n                                                                L
                prover P commits to a       using a constant size vector commitment A P G. It will convince the
                                         L
                                         n                                                   n
                veriﬁer that v is in r0,2 ´1s by proving that it knows an opening a P Z of A and v,γ P Z such
                                                                                        L    p                   p
                            γ v
                that V “ h g and
                                       xa ,2ny “ v    and a ˝a “0n and a “a ´1n                                    (37)
                                         L                    L    R                R     L
                                                                   17
               This proves that a ,...,a    are all in t0,1u, as required and that a  is composed of the bits of
                                  1       n                                         L
               v. The high level goal of the following protocol is to convert these 2n ` 1 constraints as a single
               inner-product constraint. This will allow us to use Protocol 1 to eﬃciently argue that an inner-
               product relation holds. To do this we take a random linear combination (chosen by the veriﬁer) of
               the constraints. If the original constraints were not satisﬁed then it is inversely proportional in the
               challenge space unlikely that the combined constraint holds.
                   Concretley, we use the following observation: to prove that a committed vector b P Zn satisﬁes
                                                                                                       p
               b“0nitsuﬃces for the veriﬁer to send a random y P Zp to the prover and for the prover to prove
               that xb,yny “ 0. If b ‰ 0n then the equality will hold with at most negligible probability n{p.
               Hence, if xb,yny “ 0 the veriﬁer is convinced that b “ 0n.
                   Using this observation, and using a random y P Z from the veriﬁer, the prover can prove
                                                                       p
               that (37) holds by proving that
                            xa ,2ny “ v   and xa , a ˝yny“0 and xa ´1n´a , yny“0.                            (38)
                              L                   L     R                    L          R
               We can combine these three equalities into one using the same technique: the veriﬁer chooses a
               random z P Zp and then the prover proves that
                                  2       n              n          n                n     2
                                z ¨xa ,2 y`z¨xa ´1 ´a , y y`xa , a ˝y y“z ¨v.
                                      L             L         R            L    R
               This equality can be re-written as:
                                  Aa ´z¨1n , yn˝pa `z¨1nq`z2¨2nE“z2¨v`δpy,zq                                 (39)
                                     L                  R
               where δpy,zq “ pz´z2q¨x1n,yny´z3x1n,2ny P Zp is a quantity that the veriﬁer can easily calculate.
               Wethus reduced the problem of proving that (37) holds to proving a single inner-product identity.
                   If the prover could send to the veriﬁer the two vectors in the inner product in (39) then the
               veriﬁer could check (39) itself, using the commitment V to v, and be convinced that (37) holds.
               However, these two vectors reveal information about a and therefore the prover cannot send them
                                                                     L
               to the veriﬁer. We solve this problem by introducing two additional blinding terms sL,sR P Zn to
                                                                                                             p
               blind these vectors.
                   Speciﬁcally, to prove the statement (36), P and V engage in the following zero knowledge
               protocol:
                                                               18
                         P oninput v,γ computes:                                                             (40)
                           IP
                                        n          n
                              a Pt0,1u s.t.xa ,2 y “ v                                                       (41)
                               L               L
                              a “a ´1nPZn                                                                    (42)
                               R     L         p
                                 $
                              αÐÝZp                                                                          (43)
                                    α a   a
                              A“h g Lh R PG                          //  commitment to a and a               (44)
                                                                                          L       R
                                     $   n
                              sL,sR ÐÝ Zp                            //  choose blinding vectors sL,sR       (45)
                                 $
                              ρ ÐÝ Zp                                                                        (46)
                                    ρ sL sR
                              S “h g h PG                            //  commitment to sL and sR             (47)
                         P ÑV:A,S                                                                            (48)
                                  $  ‹
                         V : y,z ÐÝ Zp                               //  challenge points                    (49)
                         V ÑP:y,z                                                                            (50)
               With this setup, let us deﬁne two linear vector polynomials lpXq,rpXq in ZnrXs, and a quadratic
                                                                                           p
               polynomial tpXq P ZprXs as follows:
                               lpXq “ pa ´z¨1nq`s ¨X                                     P ZnrXs
                                         L             L                                    p
                               rpXq “ yn ˝pa `z¨1n`s ¨Xq`z2¨2n                           P ZnrXs
                                              R            R                                p
                               tpXq “ xlpXq,rpXqy “ t `t ¨X `t ¨X2                       P Z rXs
                                                       0   1        2                        p
               where the inner product in the deﬁnition of tpXq is as in (1). The constant terms of lpXq and rpXq
               are the inner product vectors in (39). The blinding vectors s  and s   ensure that the prover can
                                                                            L       R
               publish lpxq and rpxq for one x P Z‹ without revealing any information about a   and a .
                                                  p                                           L       R
                   The constant term of tpxq, denoted t0, is the result of the inner product in (39). The prover
               needs to convince the veriﬁer that this t satisﬁes (39), namely
                                                       0
                                                      t “v¨z2`δpy,zq.
                                                       0
               To so do, the prover commits to the remaining coeﬃcients of tpXq, namely t ,t P Z . It then
                                                                                              1  2    p
               convinces the veriﬁer that it has a commitment to the coeﬃcients of tpXq by checking the value of
                                             ‹
               tpXq at a random point x P Z . Speciﬁcally, they do:
                                             p
                                                               19
                                 PIP computes:                                                                                                                                         (51)
                                                   $
                                        τ ,τ ÐÝ Z                                                                                                                                      (52)
                                          1    2         p
                                                   ti  τi
                                        T “g h PG, i“t1,2u                                                                              //     commit to t ,t                          (53)
                                           i                                                                                                                       1   2
                                 P ÑV:T ,T                                                                                                                                             (54)
                                                  1    2
                                           $     ‹
                                 V : x ÐÝ Zp                                                                                                                                           (55)
                                 V ÑP:x                                                                                                 //     a random challenge                      (56)
                                 PIP computes:                                                                                                                                         (57)
                                        l “ lpxq “ a ´z ¨1n `s ¨x P Zn                                                                                                                 (58)
                                                            L                     L             p
                                                              n                      n                       2     n        n
                                        r “ rpxq “ y ˝pa `z¨1 `s ¨xq`z ¨2 PZ                                                                                                           (59)
                                                                       R                     R                              p
                                        ˆ                                                                                                      ˆ
                                        t “ xl,ry P Zp                                                                                  //     t “ tpxq                                (60)
                                                         2                    2                                                                                              ˆ
                                        τ “τ ¨x `τ ¨x`z ¨γ PZ                                                                           //     blinding value for t                    (61)
                                          x        2             1                          p
                                        µ“α`ρ¨xPZp                                                                                      //     α,ρ blind A,S                           (62)
                                                         ˆ
                                 P ÑV:τx,µ,t,l,r                                                                                                                                       (63)
                          The veriﬁer checks that l and r are in fact lpxq and rpxq and checks that tpxq “ xl,ry. In order to
                          construct a commitment to a ˝yn the veriﬁer switches the generators of the commitment from h P
                                                   ´n                     R
                             n         1        py     q                                                                                                                         n
                          G to h “ h                    . This has the eﬀect that A is now a vector commitment to pa , a ˝ y q with
                                                                                                                                                                 L       R
                                                                                    1                                                                                                    n
                          respect to the new generators pg,h ,hq. Similarly S is now a vector commitment to psL, sR ˝y q.
                          The remaining steps of the protocol are:
                                        1       py´i`1q                                                             1     ´         py´1q       py´2q             py´n`1q¯
                                      h “h                  P G,       @i P r1,ns                          //     h “ h ,h                  , h        , . . . , h                     (64)
                                        i       i                                                                              1    2           3                 n
                                  ˆ        ?       2                           2
                                  t   τ          z       δpy,zq       x       x                                                                                              2
                                       x                                                                                            ˆ
                                g h       “V ¨g                   ¨ T    ¨ T                               //     check that t “ tpxq “ t `t x`t x                                     (65)
                                                                      1      2                                                                         0       1         2
                                                      x      ´z         1 z¨yn`z2¨2n
                                      P “A¨S ¨g ¨phq                                       P G             //     compute a commitment to lpxq,rpxq                                    (66)
                                           ?    µ      l       1  r
                                      P “h ¨g ¨phq                                                         //     check that l,r are correct                                           (67)
                                        ˆ ?                                                                                         ˆ
                                        t “ xl,ry P Zp                                                     //     check that t is correct                                              (68)
                          Equation (65) is the only place where the veriﬁer uses the given Pedersen commitment V to v.
                          Corollary 2 (Range Proof). The range proof presented in Section 4.1 has perfect completeness,
                          perfect special honest veriﬁer zero-knowledge, and computational witness extended emulation.
                          Proof. The range proof is a special case of the aggregated range proof from section 4.3 with m “ 1.
                          This is therefore a direct corollary of Theorem 3.
                          4.2       Logarithmic Range Proof
                          Finally, we can describe the eﬃcient range proof that uses the improved inner product argument.
                                In the range proof protocol from Section 4.1, P transmits l and r, whose size is linear in n. Our
                          goal is a proof whose size is logarithmic in n.
                                                                                                          20
                    We can eliminate the transfer of l and r using the inner-product argument from Section 3.
                These vectors are not secret and hence a protocol the only provides soundness is suﬃcient.
                    To use the inner-product argument observe that verifying (67) and (68) is the same as verifying
                                                                                             `     1   ´µ ˆ˘
                that the witness l,r satisﬁes the inner product relation (2) on public input g, h ,Ph     , t . That
                                                                 n                        ˆ
                is, P P G is a commitment to two vectors l,r P Z whose inner product is t. We can therefore replace
                                                                 p
                                               ˆ
                (63) with a transfer of pτ ,µ,tq, as before, and an execution of an inner product argument. Then
                                          x
                instead of transmitting l and r, which has a communication cost of 2¨n elements, the inner-product
                argument transmits only 2¨rlog2pnqs`2 elements. In total, the prover sends only 2¨rlog2pnqs`4
                group elements and 5 elements in Z .
                                                     p
                4.3    Aggregating Logarithmic Proofs
                In many of the range proof applications described in Section 1.2, a single prover needs to perform
                multiple range proofs at the same time. For example, a conﬁdential transaction often contains
                multiple outputs, and in fact, most transactions require a so-called change output to send any
                                                                           `
                unspent funds back to the sender. In Provisions [DBB 15] the proof of solvency requires the
                exchange to conduct a range proof for every single account. Given the logarithmic size of the range
                proof presented in Section 4.2, there is some hope that we can perform a proof for m values which
                is more eﬃcient than conducting m individual range proofs. In this section, we show that this can
                be achieved with a slight modiﬁcation to the proof system from Section 4.1.
                    Concretely, we present a proof system for the following relation:
                                        m                m            γ   v              n                   (
                   pg,h P G,     V P G      ;   v,γ P Z q : Vj “ h jg j ^ vj P r0,2 ´ 1s @j P r1,ms              (69)
                                                         p
                The prover is very similar to the prover for a simple range proof with n ¨ m bits, with the
                                                                                                      n¨m
                following slight modiﬁcations.    In line (41), the prover should compute a       P Z      such that
                                                                                                L     p
                x2n,a rpj´1q¨n:j¨n´1sy “ vj for all j in r1,ms, i.e. a   is the concatenation of all of the bits for
                      L                                                L
                every vj. We adjust lpXq and rpXq accordingly so that
                      lpXq “ pa ´z¨1n¨mq`s ¨X PZn¨mrXs                                                           (70)
                                L                L        p
                                                                 m        ´                       ¯
                      rpXq “ yn¨m ˝pa `z¨1n¨m`s ¨Xq` ÿz1`j ¨ 0pj´1q¨n } 2n } 0pm´jq¨n P Zn¨m                     (71)
                                       R               R                                                p
                                                                j“1
                In the computation of τx, we need to adjust for the randomness of each commitment Vj, so that
                                  2   řm 1`j
                τx “ τ1 ¨ x ` τ2 ¨ x `  j“1z     ¨ γj. Further, δpy,zq is updated to incorporate more cross terms.
                                                                            m
                                                        2     n¨m   n¨m    ÿ j`2       n   n
                                        δpy,zq “ pz ´z q¨x1      , y   y ´j“1z      ¨ x1 ,2 y
                The veriﬁcation check (65) needs to be updated to include all the Vj commitments.
                                                   ˆ    ?            2 m          2
                                                   t τx     δpy,zq  z ¨z    x    x
                                                  g h   “g       ¨ V      ¨ T ¨ T                                (72)
                                                                            1    2
                Finally, we change the deﬁnition of P (66) such that it is a commitment to the new r.
                                                                      m
                                                                  n¨m ź     j`1 n
                                                     x   ´z    1z¨y       1z   ¨2
                                             P “AS ¨g ¨h             j“1hrpj´1q¨n:j¨n´1s
                                                                 21
               Theaggregated range proof which makes use of the inner product argument uses 2¨rlog2pn¨mqs`4
               group elements and 5 elements in Z . Note that the proof size only grows by an additive term of
                                                  p
               2¨log2pmq when conducting multiple range proofs as opposed to a multiplicative factor of m when
               creating m independent range proofs.
               Theorem 3. The aggregate range proof presented in Section 4.3 has perfect completeness, perfect
               honest veriﬁer zero-knowledge and computational witness extended emulation.
                  The proof for Theorem 3 is presented in Appendix C. It is analogous to the proof of Theorem 4
               which is described in greater detail in Appendix D.
               4.4   Non-Interactive Proof through Fiat-Shamir
               So far we presented the proof as an interactive protocol with a logarithmic number of rounds.
               The veriﬁer is a public coin veriﬁer, as all the honest veriﬁer’s messages are random elements
                      ‹
               from Z . We can therefore convert the protocol into a non-interactive protocol that is secure and
                      p
               full zero-knowledge in the random oracle model using the Fiat-Shamir heuristic [BR93]. All random
               challenges are replaced by hashes of the transcript up to that point. For instance y “ HpA,Sq and
               z “ HpA,S,yq
                  To avoid a trusted setup we can use such a hash function to generate the public parameters
                                                                                     ˚
               g,h,g,h from a small seed. The hash function needs to map from t0,1u to Gzt1u, which can be
               built as in [BLS01]. This also makes it possible to provide random access into the public parameters.
               Alternatively, a common random string can be used.
               4.5   ASimple MPC Protocol for Bulletproofs
               Inseveral of the applications described in Section 1.2, the prover could potentially consist of multiple
               parties who each want to generate a single range proof. For instance, multiple parties may want
               to create a single joined conﬁdential transaction, where each party knows some of the inputs and
               outputs and needs to create range proofs for their known outputs. The joint transaction would not
               only be smaller than the sum of multiple transactions, it would also hide which inputs correspond to
               which outputs and provide some level of anonymity. These kinds of transactions are called CoinJoin
               transactions [Max13]. In Provisions, an exchange may distribute the private keys to multiple servers
               and split the customer database into separate chunks, but it still needs to produce a single short
               proof of solvency. Can these parties generate one Bulletproof without sharing the entire witness
               with each other? The parties could certainly use generic multi-party computation techniques to
               generate a single proof, but this might be too expensive and incur signiﬁcant communication costs.
               This motivates the need for a simple MPC protocol speciﬁcally designed for Bulletproofs which
               requires little modiﬁcation to the prover and is still eﬃcient.
                  Note that for aggregate range proofs, the inputs of one range proof do not aﬀect the output
               of another range proof.  Given the composable structure of Bulletproofs, it turns out that m
                                                               m
               parties each having a Pedersen commitment pVkq      can generate a single Bulletproof that each
                                                               k“1
               Vk commits to a number in some ﬁxed range. The protocol either uses a constant number of
               rounds but communication that is linear in both m and the binary encoding of the range, or it
               uses a logarithmic number of rounds and communication that is only linear in m. We assume for
               simplicity that m is a power of 2, but the protocol could be easily adapted for other m. We use
                                                             22
                     the same notation as in the aggregate range proof protocol, but use k as an index to denote the
                     kth party’s message. That is Apkq is generated just like A but using only the inputs of party k.
                         The MPC protocol works as follows, we assign a set of distinct generators pgpkq,hpkqqm                                      to
                                                                                                                                               k“1
                     each party and deﬁne g as the interleaved concatenation of all gpkq such that g “ gppi´1q mod m`1q.
                                                                                                                            i      r i s
                                         pkq                                                                                        m
                     Deﬁne h and h           in an analogous way.
                         We ﬁrst describe the protocol with linear communication. In each of the 3 rounds of the
                     protocol, the ones that correspond to the rounds of the range proof in Section 4.1, each party
                                                                                         pkq    pkq    pkq    pkq   pkq   pkq   pkq   pkq   pkq
                                                                                                                               ˆ
                     simply generates its part of the proof, i.e. the A                      , S   ; T    , T    ; τx  , µ    , t  , l   , r    using
                                                                                                      1      2
                     its inputs and generators. These shares are then sent to a dealer (which could be one of the
                     parties), who simply adds them homomorphically to generate the respective proof component, e.g.
                           ś                           ř         pkq
                              l       pkq                 l
                     A“ k“1A andτx “ k“1τx . In each round, the dealer generates the challenges using the
                     Fiat-Shamir heuristic and the combined proof components and sends them to each party. Finally,
                                             pkq   pkq
                     each party sends l         , r     to the dealer who computes l,r as the interleaved concatenation of the
                     shares. The dealer runs the inner product argument and generates the ﬁnal proof. The protocol
                     is complete as each proof component is simply the (homomorphic) sum of each parties’ proof
                     components, and the challenges are generated as in the original protocol. It is also secure against
                     honest but curious adversaries as each share constitutes part of a separate zero-knowledge proof.
                         The communication can be reduced by running a second MPC protocol for the inner product
                     argument. Thegeneratorswereselectedinsuchawaythatuptothelastlog2plqroundseachparties’
                     witnesses are independent and the overall witness is simply the interleaved concatenation of the
                     parties’ witnesses. Therefore, parties simply compute Lpkq,Rpkq in each round and a dealer computes
                     L,R as the homomorphic sum of the shares. The dealer then again generates the challenge and
                     sends it to each party. In the ﬁnal round the parties send their witness to the dealer who completes
                     Protocol 2. A similar protocol can be used for arithmetic circuits if the circuit is decomposable
                     into separate independent circuits. Constructing an eﬃcient MPC protocol for more complicated
                     circuits remains an open problem.
                     4.6     Perfectly Binding Commitments and Proofs
                     Bulletproofs, like the range proofs currently used in conﬁdential transactions, are computationally
                     binding. An adversary that could break the discrete logarithm assumption could generate accept-
                     able range proofs for a value outside the correct range. On the other hand, the commitments are
                     perfectly hiding and Bulletproofs are perfect zero-knowledge, so that even an all powerful adver-
                     sary cannot learn which value was committed to. Commitment schemes which are simultaneously
                     perfectly-binding and perfectly-hiding commitments are impossible, so when designing commitment
                     schemes and proof systems, we need to decide which properties are more important. For cryptocur-
                     rencies, the binding property is more important than the hiding property [RM]. An adversary that
                     can break the binding property of the commitment scheme or the soundness of the proof system
                     can generate coins out of thin air and thus create uncontrolled but undetectable inﬂation rendering
                     the currency useless. Giving up the privacy of a transaction is much less harmful as the sender of
                     the transaction or the owner of an account is harmed at worst. Unfortunately, it seems diﬃcult to
                     create Bulletproofs from binding commitments. The eﬃciency of the system relies on vector com-
                     mitments which allow the commitment to a long vector in a single group element. By deﬁnition,
                     for perfectly binding commitment schemes, the size of the commitment must be at least the size of
                     the message and compression is thus impossible. The works [GH98,GVW02] show that in general,
                                                                                    23
               interactive proofs cannot have communication costs smaller than the witness size, unless some very
               surprising results in complexity theory hold.
                   While the discrete logarithm assumption is believed to hold for classical computers, it does
               not hold against a quantum adversary. It is especially problematic that an adversary can create a
               perfectly hiding UTXO at any time, planning to open to an arbitrary value later when quantum
               computers are available. To defend against this, we can use the technique from Ruﬃng and Mala-
               volta [RM] to ensure that even though the proof is only computationally binding, it is later possible
               to switch to a proof system that is perfectly binding and secure against quantum adversaries. In
               order to do this, the prover simply publishes gγ, which turns the Pedersen commitment to v into
               an ElGamal commitment. Ruﬃng and Malavolta also show that given a small message space, e.g.
                                         n
               numbers in the range r0,2 s, it is impossible for a computationally bounded prover to construct a
               commitment that an unbounded adversary could open to a diﬀerent message in the small message
               space.
                   Note that the commitment is now only computationally hiding, but that switching to quantum-
               secure range proofs is possible. Succinct quantum-secure range proofs remain an open problem, but
                                                                              `
               with a slight modiﬁcation, the scheme from Poelstra et al. [PBF ] can achieve statistical soundness.
               Instead of using Pedersen commitments, we propose using ElGamal commitments in every step of
               the protocol. An ElGamal commitment is a Pedersen commitment with an additional commitment
               gr to the randomness used. The scheme can be improved slightly if the same gr is used in multiple
               range proofs. In order to retain the hiding property, a diﬀerent h must be used for every proof.
               5    Zero-Knowledge Proof for Arithmetic Circuits
                                 `
               Bootleetal.[BCC 16]presentaneﬃcientzero-knowledgeargumentforarbitraryarithmeticcircuits
               using 6log2pnq`13 elements, where n is the multiplicative complexity of the circuit. We can use our
               improvedinner product argument to get a proof of size 2log2pnq`13 elements, while simultaneously
               generalizing to include committed values as inputs to the arithmetic circuit. Including committed
               input wires is important for many applications (notably range proofs) as otherwise the circuit would
               need to implement a commitment algorithm. Concretely a statement about Pedersen commitments
               wouldneedtoimplementthegroupexponentiationforthegroupthatthecommitmentisanelement
               of.
                   Following [BCC`16], we present a proof for a Hadamard-product relation. A multiplication
               gate of fan-in 2 has three wires; ‘left’ and ‘right’ for the input wires, and ‘output’ for the output
               wire. In the relation, a   is the vector of left inputs for each multiplication gate. Similarly, a
                                       L                                                                       R
               is the vector of right inputs, and a   “ a ˝a is the vector of outputs. [BCC`16] shows how
                                                   O      L    R
               to convert an arbitrary arithmetic circuit with n multiplication gates into a relation containing a
               Hadamard-product as above, with an additional Q ď 2¨n linear constraints of the form
                                           xw ,a y`xw ,a y`xw ,a y“cq
                                              L,q  L       R,q  R       O,q  O
                                                       n
               for 1 ď q ď Q, with w    , w   , w   P Z and c P Z .
                                     L,q   R,q   O,q   p       q    p
                   We include additional commitments Vi as part of our statement, and give a protocol for a
               more general relation, where the linear consistency constraints include the openings vj of the
               commitments Vj. For simplicity and eﬃciency we present the scheme with Vi being Pedersen
               commitments. The scheme can be trivially adapted to work with other additively homomorphic
               schemes by changing the commitments to tpXq and adapting the veriﬁcation in line (90).
                                                               24
                5.1   Inner-Product Proof for Arithmetic Circuits
                The high level idea of the protocol is to convert the Hadamard-product relation along with the
                linear constraints into a single inner product relation. Similar to the range proof protocol the
                prover veriﬁably produces a random linear combination of the Hadamard and the linear constraints
                to form a single inner product constraint. If the combination is chosen randomly by the veriﬁer, as
                in our protocol, then with overwhelming probability the inner-product constraint implies the other
                constraints.
                   In Section 5.2 we show that the inner product relation can be replaced with an eﬃcient inner
                product argument which yields short proofs for arbitrary circuits where input wires can come from
                Pedersen commitments. Formally we present a proof system for the following relation.
                                    n       m                   Qˆn         Qˆm       Q              n         m
                   tpg,h P G,g,h P G ,V P G ,W ,W ,W PZ            , W PZ       , c P Z ;a ,a ,a  P Z ,v,γ P Z q :
                                                 L    R   O     p      V    p         p  L R O       p         p
                         v  γ
                   V “g jh j @j P r1,ms^a ˝a “a ^W ¨a `W ¨a `W ¨a “W ¨v`cu
                    j                      L    R    O      L   L     R   R     O   O      V
                                                                                                               (73)
                   LetW PZQˆmbetheweightsforacommitmentV . Thepresentedproofsystemonlyworksfor
                          V    p                                      j
                relations where WV is of rank m, i.e. the columns of the matrix are all linearly independent. This
                restriction is minor as we can construct commitments that fulﬁll these linearly dependent constraints
                as a homomorphic combination of other commitments. Consider a vector w1 “ a¨W P Zm for a
                                                                                            V         V    p
                vector of scalars a P ZQ then we can construct commitment V1 “ va¨WV . Note that if the relation
                                      p
                holds then we can conclude that xw    , a y`xw    , a y`xw     , a y “ xw1 ,vy`c. The protocol is
                                                   L,j  L      R,j  R       O,j  O       V
                presented in Protocol 3. It is split into two parts. In the ﬁrst part P commits to lpXq,rpXq,tpXq in
                the second part P convinces V that the polynomials are well formed and that xlpXq,rpXqy “ tpXq.
                Theorem 4. The proof system presented in Protocol 3 has perfect completeness, perfect honest
                veriﬁer zero-knowledge and computational witness extended emulation.
                   The proof of Theorem 4 is presented in Appendix D.
                5.2   Logarithmic-Sized Protocol
                As for the range proof, we can reduce the communication cost of the protocol by using the inner
                                                                                       ˆ
                product argument. Concretely transfer (82) is altered to simply τx,µ,t and additionally P and V
                                                                            1     ´µ ˆ
                engage in an inner product argument on public input pg,h ,P ¨ h      , tq. Note that the statement
                proven is equivalent to the veriﬁcation equations (92) and (88). The inner product argument
                has only logarithmic communication complexity and is thus highly eﬃcient. Note that instead
                of transmitting l,r the inner product argument only requires communication of 2 ¨ rlog2pnqs ` 2
                elements instead of 2 ¨ n. In total the prover sends 2 ¨ rlog2pnqs ` 8 group elements and 5 elements
                in Zp. Using the Fiat-Shamir heuristic as in 4.4 the protocol can be turned into an eﬃcient non
                interactive proof. We report implementation details and evaluations in Section 6.
                Theorem 5. The arithmetic circuit protocol using the improved inner product argument (Proto-
                col 2) has perfect completeness, statistical zero-knowledge and computational soundness under the
                discrete logarithm assumption.
                Proof. Completeness follows from the completeness of the underlying protocols. Zero-knowledge
                follows from the fact that l and r can be eﬃciently simulated, and because the simulator can
                                                                25
                                          n                  Qˆn
                   Input: pg,h P G,g,h P G ,W ,W ,W PZ           ,
                                               L   R    O    p
                               Qˆm       Q              n      m
                       W PZ        , c P Z ;a ,a ,a  P Z ,γ P Z q
                          V    p         p  L R O       p      p
                   P’s input: pg,h,g,h,W ,W ,W ,W ,c;a ,a ,a ,γq
                                         L    R    O   V     L R O
                   V’s input: pg,h,g,h,W ,W ,W ,W ,cq
                                         L    R   O    V
                   Output: {V accepts,V rejects }
                   P computes:
                            $
                     α,β,ρ ÐÝ Zp
                            α a   a
                     AI “h g Lh R PG                                        //  commit to aL,aR
                            β a
                     AO “h g O PG                                           //  commitment to aO
                            $  n
                     sL,sR ÐÝ Z                                             //  choose blinding vectors sL,sR
                               p
                           ρ s  s
                     S “h g Lh R P G                                        //  commitment to sL,sR
                   P ÑV:AI,AO,S
                           $  ‹
                   V : y,z ÐÝ Z
                              p
                   V ÑP:y,z
                   P and V compute:
                     yn “ p1,y,y2,...,yn´1q P Zn                            //  challenge per witness
                                               p
                     zQ`1 “ pz,z2,...,zQq P ZQ                              //  challenge per constraint
                      r1:s                   p
                                ´n    Q`1         Q`1
                     δpy,zq “ xy   ˝pz    ¨ W q,z     ¨ W y                 //  independent of the witness
                                      r1:s    R   r1:s    L
                   P computes:
                                           2   ´n     Q`1
                     lpXq “ aL ¨X `aO ¨X `y       ˝pz     ¨ WRq¨X
                                                      r1:s
                      `s ¨X3PZnrXs
                         L        p
                              n            n    Q`1
                     rpXq “ y ˝a ¨X ´y `z           ¨ pW ¨X `W q
                                  R             r1:s    L         O
                      `yn˝s ¨X3PZnrXs
                             R         p
                                           6
                     tpXq “ xlpXq,rpXqy “ ÿ t ¨Xi P Z rXs
                                              i        p
                                          i“1
                     w“W ¨a `W ¨a `W ¨a
                            L   L     R    R     O   O
                     t “xa ,a ˝yny´xa ,yny`xzQ`1,wy`δpy,zqPZ                //  t  “dpy,zq`xzQ`1,c`W ¨vy
                      2     L R           O          r1:s               p        2             r1:s       V
                        $
                     τ ÐÝ Z    @i P r1,3,4,5,6s
                      i     p
                           t  τ
                     Ti “ g ih i @i P r1,3,4,5,6s
                   P ÑV:T ,T ,T ,T ,T                                       //  commitments to t ,t ,t ,t ,t
                            1  3   4  5  6                                                      1  3  4 5  6
                              Protocol 3: Part 1: Computing commitments to lpXq,rpXq and tpXq
                                                                26
                                              $     ‹
                                    V : x ÐÝ Zp                                                                            //     Random challenge                                          (74)
                                    V ÑP:x                                                                                                                                                  (75)
                                    P computes:                                                                                                                                             (76)
                                                          n
                                        l “ lpxq P Z                                                                                                                                        (77)
                                                          p
                                                            n
                                        r “ rpxq P Z                                                                                                                                        (78)
                                                            p
                                        ˆ
                                        t “ xl,ry P Z                                                                                                                                       (79)
                                                            p
                                                     6
                                                   ÿ               i      2       Q`1                                                                           ˆ
                                        τ “                τ ¨ x `x ¨xz                 , W ¨γyPZ                          //     blinding value for t                                      (80)
                                         x                   i                    r1:s        V               p
                                                i“1,i‰2
                                        µ“α¨x`β¨x2`ρ¨x3PZ                                                                  //     Blinding value for P                                      (81)
                                                                                      p
                                                           ˆ
                                    P ÑV:τ ,µ,t,l,r                                                                                                                                         (82)
                                                    x
                                    V computes and checks:                                                                                                                                  (83)
                                          1       y´i`1                                                                              1              y´1            y´n`1
                                        hi “ h                @i P r1,ns                                                   //     h “ph1,h               , . . . , hn      q                (84)
                                                  i                                                                                                 2
                                                       Q`1
                                                     1z     ¨WL
                                        W “h r1:s                                                                          //     Weights for a                                             (85)
                                           L                                                                                                            L
                                                     y´n˝pzQ`1¨WRq
                                        W “g                  r1:s                                                         //     Weights for a                                             (86)
                                           R                                                                                                            R
                                                       Q`1
                                                     1z      ¨WO
                                        W “h r1:s                                                                          //     Weights for a                                             (87)
                                           O                                                                                                            O
                                        ˆ ?                                                                                                          ˆ
                                        t “ xl,ry                                                                          //     Check that t is correct                                   (88)
                                          ˆ       ?      2               Q`1              2    Q`1
                                          t  τ         x ¨pδpy,zq`xz          ,cyq       x ¨pz      ¨W q         x
                                        g h x “ g                        r1:s       ¨ V        r1:s      V ¨T                                                                               (89)
                                                                                                                 1
                                            6                                                                                                        6
                                           ź i                                                                                                      ÿ
                                                  px q                                                                             ˆ                            i
                                         ¨ i“3Ti                                                                           //     t “ tpxq “ i“1ti ¨ x                                      (90)
                                                          px2q       ´yn                                    3
                                                  x                 1             x       x               px q
                                        P “A ¨A                 ¨ h         ¨ W ¨W ¨WO¨S                                   //     commitment to lpxq,rpxq                                   (91)
                                                  I       O                      L        R
                                            ?     µ     l      1r
                                        P “h ¨g ¨h                                                                         //     Check that l “ lpxq and r “ rpxq                          (92)
                                    if all checks succeed:               V accepts                                                                                                          (93)
                                    else:      V rejects                                                                                                                                    (94)
                                                     Protocol 3: Part 2: Polynomial identity check for xlpxq,rpxqy “ tpxq
                                                                                                               27
                simply run Protocol 2 given the simulated witness pl,rq. The protocol also has a knowledge-
                extractor, as the extractor of the range proof can be extended to extract l and r by calling the
                                                                3
                extractor of Protocol 2. The extractor uses Opn q valid transcripts in total, which is polynomial
                in λ if n “ Opλq. The extractor is thus eﬃcient and either extracts a discrete logarithm relation
                or a valid witness. However, if the generators g,h,g,h are independently generated, then ﬁnding
                a discrete logarithm relation between them is as hard as breaking the discrete log problem. If the
                discrete log assumption holds in G then a computationally bounded P cannot produce discrete-
                logarithm relations between independent generators. The proof system is therefore computationally
                sound.
                6    Performance
                6.1   Theoretical Performance
                In Table 1 we give analytical measurements for the proof size of diﬀerent range proof protocols.
                                                                                                       n
                Wecompare both the proof sizes for a single proof and for m proofs for the range r0,2 ´ 1s. We
                                                   `
                compare Bulletproofs against [PBF ] and a Σ-protocol range proof where the proof commits to
                each bit and then shows that the commitment is to 0 or 1. The table shows that Bulletproofs
                    Table 1: Range proof size for m proofs. m “ 1 is the special case of a single range proof
                                                                            n
                                              mrange proofs for range r0,2 ´1s
                                                       #Gelements                  #Zp elements
                               ΣProtocol [CD98] `      mn                          3mn`1
                               Poelstra et al. [PBF ]  0.63¨mn                     1.26 ¨ mn `1
                                                         `                  ˘
                               Bulletproofs            2 log2pnq`log2pmq `4 5
                have a signiﬁcant advantage when providing multiple range proofs at once. The proof size for the
                protocol presented in Section 4.3 only grows by an additive logarithmic factor when conducting m
                range proofs, while all other solutions grow multiplicatively in m.
                6.2   An Optimized Veriﬁer Using Multi-Exponentiation and Batch Veriﬁcation
                In many of the applications discussed in Section 1.2 the veriﬁer’s runtime is of particular interest.
                For example, with conﬁdential transactions every full node needs to check all conﬁdential transac-
                tions and all associated range proofs. We therefore now present a number of optimizations for the
                non-interactive veriﬁer. We present the optimizations for a single range proof but they all carry
                over to aggregate range proofs and the arithmetic circuit protocol.
                Single multi-exponentiation. In Section 3.1 we showed that the veriﬁcation of the inner product
                can be reduce to a single multi-exponentiation. We can further extend this idea to verify the whole
                rangeproofusingasinglemulti-exponentiationofsize2n`2log2pnq`7. NoticethattheBulletproofs
                veriﬁer only performs two checks (68) and (16). The idea is to delay exponentiation until those
                checks are actually performed and then to combine them into a single check. We, therefore, unroll
                the inner product argument as described in Section 3.1 using the input from the range proof. The
                                                               28
                     resulting protocol is presented below with x being the challenge from Protocol 1, and x being the
                                                                              u                                                         j
                     challenge from round j of Protocol 2. L and R are the L,R values from round j of Protocol 2.
                                                                          j          j
                     The veriﬁer runs the following veriﬁcation procedure:
                                                                 !                           logpnq            ˆ                )
                                          input: proof π “ A,S,T ,T ,pL ,R q                        P G, τ,t,µ,a,b P Z                        (95)
                                                                           1    2    j    j j“1                               p
                                          compute challenges from π : ty,z,x,x ,px qlog2pnqu                                                  (96)
                                                                                             u    j j“1
                                                              2       n   n        3   n   n
                                          δpy,zq “ pz ´z q¨x1 ,y y´z x1 ,2 y                                                                  (97)
                                           ˆ                    2               2 ?
                                           t´δpy,zq τ        ´z       ´x     ´x
                                          g         h x ¨ V       ¨ T     ¨ T      “1                                                         (98)
                                                     #               1       2
                                          bpi,jq “      1     if the jth bit of i ´ 1 is 1                                                    (99)
                                                        ´1 otherwise
                                          for i “ 1,...,n:                                                                                   (100)
                                                      log2 n
                                                       ź bpi,jq
                                                l “         x       ¨ a ` z    P Z                                                           (101)
                                                 i            j                     p
                                                       j“1
                                                               log2 n
                                                        1´i     ź ´bpi,jq              2    i´1
                                                r “y        ¨ p      x         ¨ b ´ z ¨ 2      q ´z PZ                                      (102)
                                                 i                     j                                      p
                                                                j“1
                                                                  n
                                          l “ pl ,...,l q P Z                                                                                (103)
                                                 1        n       p
                                                                   n
                                          r “ pr ,...,r q P Z                                                                                (104)
                                                  1        n       p
                                                                             log2pnq             ´2
                                                          ˆ                   ź ´x2 ´x ?
                                           l  r x ¨pa¨b´tq µ        ´1 ´x                 j      j
                                          g h g u           h ¨A S                   L     R        “1                                       (105)
                                                                                       j     j
                                                                              j“1
                     We can combine the two multi-exponentiations in line (98) and (105) by using a random value
                        $                                 c
                     c ÐÝ Z . This is because if A B “ 1 for a random c then with high probability A “ 1^B “ 1.
                             p
                         Various algorithms are known to compute the multi-exponentiations (105) and (98) eﬃciently.
                     As explained in [BDLO12], algorithms like Pippenger’s [Pip80] perform a number of group op-
                     erations that scales with O             n , i.e.     sub-linearly.      For realistic problem sizes these dominate
                     veriﬁcation time.                    logpnq
                     Computing scalars. A further optimization concerns the computation of the l and r values.
                                                          ś                                                                       i        i
                                                   piq       log2 n  bpi,jq
                     Instead of computing x            “            x       for each i, we can compute each challenge product using
                                                             j“1     j                                                            ś
                                                                                                                          p1q        log2 n     ´1
                     only one multiplication in Zp by applying batch division. First we compute x                             “p j“1 xjq            to
                                                                                                                    p2q      p1q 2      3      p1q 2
                     get the ﬁrst challenge value using a single inversion. Then computing x                            “x x , x “x x ,
                                            p7q      p3q 2                                              piq                       1                 2
                     and for example x          “x x . Ingeneral in order to compute x                      we let k be the next lower power
                                                          5
                                                         piq      pi´kq     2
                     of 2 of i ´ 1 and compute x             “x         ¨ x      which takes only one additional multiplication in Zp
                                                                            k`1
                     and no inversion. Further, note that the squares of the challenges are computed anyway in order
                     to check equation (105).
                     Batch veriﬁcation. A further important optimization concerns the veriﬁcation of multiple proofs.
                     In many applications described in Section 1.2 the veriﬁer needs to verify multiple (separate) range
                     proofs at once. For example a Bitcoin node receiving a block of transactions needs to verify all
                                                                                    29
                transactions and thus range proofs in parallel. As noted above, veriﬁcation boils down to a large
                multi-exponentiation. In fact, 2n`2 of the generators only depend on the public parameters, and
                only 2logpnq`5 are proof-dependent. We can therefore apply batch veriﬁcation [BGR98] in order to
                reduce the number of expensive exponentiations. Batch veriﬁcation is based on the observation that
                checking gx “ 1^gy “ 1 can be checked by drawing a random scalar α from a large enough domain
                and checking gα¨x`y “ 1. With high probability, the latter equation implies that gx “ 1 ^ gy “ 1,
                but the latter is more eﬃcient to check. The same trick applies to multi-exponentiations and
                can save 2n exponentiations per additional proof. This is equivalent to the trick that is used
                for combining multiple exponentiations into one with the diﬀerence that the bases are equivalent.
                Verifying m distinct range proofs of size n now only requires a single multi-exponentiation of size
                2n`2`m¨p2¨logpnq`5q along with Opm¨nq scalar operations.
                    Note that this optimization can even be applied for circuits and proofs for diﬀerent circuits if
                the same public parameter are used.
                    Even for a single veriﬁcation we can take advantage of the fact that most generators are ﬁxed
                in the public parameters. Both the veriﬁer and the prover can used fast ﬁxed-base exponentiation
                with precomputation [Gor98] to speed-up all the multi-exponentiations.
                6.3    Implementation and Performance
                To evaluate the performance of Bulletproofs in practice we give a reference implementation in C
                and integrate it into the popular library libsecp256k1 which is used in many cryptocurrency clients.
                libsecp256k1 uses the elliptic curve secp256k12 which has 128 bit security.
                    In their compressed form, secp256k1 points can be stored as 32 bytes plus one bit. We use
                all of the optimizations described above, except the pre-computation of generators. The prover
                uses constant time operations until the computation of l and r. By Theorem 2, the inner product
                argument does not need to hide l and r and can therefore use variable time operations. The veriﬁer
                has no secrets and can therefore safely use variable time operations like the multi-exponentiations.
                    All experiments were performed on an Intel i7-6820HQ system throttled to 2.00 GHz and using
                a single thread. Less than 100 MB of memory was used in all experiments. For reference, verifying
                an ECDSA signature takes 86 µs on the same system. Table 2 shows that in terms of proof size
                                                                                                    `
                Bulletproofs bring a signiﬁcant improvement over the 3.8 KB proof size in [PBF ]. A single 64-bit
                range proof is 688 bytes. An aggregated proof for 32 ranges is still just 1 KB whereas 32 proofs
                from [PBF`] would have taken up 121 KB. The cost to verify a single 64-bit range proof is 3.9 ms
                but using batch veriﬁcation of many proofs the amortized cost can be brought down to 450 µs or
                5.2 ECDSA veriﬁcations. Verifying an aggregated proof for 64 ranges takes 61 ms or 1.9 ms per
                range. The marginal cost of verifying an additional proof is 2.67 ms or 83 µs per range. This is less
                than verifying an ECDSA signature, which cannot take advantage of the same batch validation.
                    To aid future use of Bulletproofs we also implemented Protocol 3 for arithmetic circuits and
                provide a parser for circuits in the Pinocchio [PHGR13] format to the Bulletproofs format. This
                hooks Bulletproofs up to the Pinocchio toolchain which contains a compiler from a subset of C to
                the circuit format. To evaluate the implementation we analyze several circuits for hash preimages
                in Table 3 and Figure 3.
                    Speciﬁcally, a SHA256 circuit generated by jsnark3 and a Pedersen hash function over an em-
                   2http://www.secg.org/SEC2-Ver-1.0.pdf
                   3See https://github.com/akosba/jsnark.
                                                                  30
                bedded elliptic curve similar to Jubjub4 are benchmarked. A Bulletproof for knowing a 384-bit
                Pedersen hash preimage is about 1 KB and takes 61 ms to verify. The marginal cost of verifying
                an additional proof is 2.1 ms. The SHA256 preimage proof is 1.4 KB and takes 750 ms to verify.
                The marginal cost of verifying additional proofs is 41.5 ms. Figure 3 shows that the proving and
                veriﬁcation time grow linearly. The batch veriﬁcation ﬁrst grows logarithmically and then linearly.
                For small circuits the logarithmic number of exponentiations dominate the cost while for larger
                circuits the linear scalar operations do.
                                                   Figure 1: Sizes for range proofs
                                            9
                                                    Sigma Protocol
                                                  Confidental Assets
                                            8         Bulletproofs
                                            7
                                            6
                                            5
                                          KB
                                            4
                                            3
                                            2
                                            1
                                            0
                                              0     8    16    24    32    40    48    56    64
                                                                  Range (bits)
                        Figure 2: Timings for range proofs              Figure 3: Timings for arithmetic circuits
                                                                                     (Pedersen Hash)
                                                                         10000
                                                                                        Proving time
                                                                                      Verification time
                                                                                  Batch verification time
                                                                         1000
                                                                          100
                                                                      ms
                                                                           10
                                                                           1
                                                                          0.1
                                                                             8       32      128     512     2048    8192
                                                                                        Number of multiplication gates
                   4See https://z.cash/technology/jubjub.html.
                                                                   31
                                     Table 2: Range proofs: performance and proof size
                                   Problem size   Gates   π Size       Timing (ms)
                                                         (bytes)   prove  verify  batch
                                   Range proofs (range ˆ aggregation size)
                                   8 bit              8      482     3.7     0.9   0.28
                                   16 bit            16      546     7.2     1.4   0.33
                                   32 bit            32      610      15     2.4   0.38
                                   64 bit            64      675      29     3.9   0.45
                                   64 bit ˆ 2       128      739      57     6.2   0.55
                                     per range       64      370      29     3.1   0.28
                                   64 bit ˆ 4       256      803    111    10.4    0.71
                                     per range       64      201      28     2.6   0.18
                                   64 bit ˆ 8       512      932    213    18.8    1.08
                                     per range       64      117      27     2.4   0.13
                                   64 bit ˆ 16     1024      932    416    33.2    1.58
                                     per range       64       59      26     2.1   0.10
                                   64 bit ˆ 32     2048      996    812    61.0    2.67
                                     per range       64       32      25     1.9  0.083
                                   64 bit ˆ 64     4096     1060   1594     114    4.91
                                     per range       64       17      25     1.8  0.077
                                   64 bit ˆ 128    8192     1124   3128     210    9.75
                                     per range       64      8.8      25     1.6  0.076
                                   64 bit ˆ 256   16384     1189   6171     392   21.03
                                     per range       64      4.6      24     1.5  0.082
                                   64 bit ˆ 512   32768     1253  12205     764    50.7
                                     per range       64      2.5      24     1.5   0.10
                The ﬁrst 4 instances are n-bit range proofs and the later ones are m aggregated 64-bit proofs and the normalized
                 costs per range. “Batch” is the marginal cost of verifying an additional proof, computed by batch-verifying 100
                                    proofs, subtracting the cost to verify one, and dividing by 99.
                                                            32
                                    Table 3: Protocol 3: Performance numbers and proof sizes
                                       Input size   Gates    π Size        Timing (ms)
                                                             (bytes)   prove   verify  batch
                                       Pedersen hash preimage (input size)
                                       48 bit         128       864       88     6.4    0.72
                                       96 bit         256       928      172    10.6    0.93
                                       192 bit        512       992      335    19.1    1.33
                                       384 bit       1024      1056      659    33.6    2.12
                                       768 bit       2048      1120    1292     61.6    3.66
                                       1536 bit      4096      1184    2551    114.9    6.93
                                       3072 bit      8192      1248    5052    213.4   13.20
                                       Unpadded SHA256 preimage
                                       512 bit      25400      1376   19478    749.9   41.52
                 Bulletproofs for proving knowledge of x s.t. Hpxq “ y for diﬀerent sized x’s. The ﬁrst 7 rows are for the Pedersen
                   hash function and the ﬁnal row is for SHA256. “Batch” is the marginal cost of verifying an additional proof,
                         computed by batch-verifying 100 proofs, subtracting the cost to verify one, and dividing by 99.
                Acknowledgments
                We thank Shashank Agrawal for coming up with the Bulletproof name (short like a bullet with
                bulletproof security assumptions). We thank Peter Dettman for pointing out the batch inversion
                trick. We thank Sean Bowe and Daira Hopwood for various optimizations applicable to arithmetic
                circuits for Pedersen hash functions. Further we thank Philip Hayes, Cathie Yun and the anonymous
                reviewers for helpful corrections. This work was supported by NSF, DARPA, a grant from ONR,
                and the Simons Foundation.
                References
                [AHIV17]      Scott Ames, Carmit Hazay, Yuval Ishai, and Muthuramakrishnan Venkitasubrama-
                              niam. Ligero: Lightweight sublinear arguments without a trusted setup. In Pro-
                              ceedings of the 2017 ACM SIGSAC Conference on Computer and Communications
                              Security, pages 2087–2104. ACM, 2017.
                      `
                [AKR 13]      Elli Androulaki, Ghassan O Karame, Marc Roeschlin, Tobias Scherer, and Srdjan
                              Capkun. Evaluating User Privacy in Bitcoin. In Financial Cryptography, 2013.
                [And17]       Oleg Andreev. Hidden in Plain Sight: Transacting Privately on a Blockchain. blog.
                              chain.com, 2017.
                [BB04]        DanBonehandXavierBoyen. Shortsignatureswithoutrandomoracles. In Advances
                              in Cryptology - EUROCRYPT 2004, pages 56–73, 2004.
                                                                 33
                         `
                   [BBB 18]         Benedikt Bunz,¨    Jonathan Bootle, Dan Boneh, Andrew Poelstra, Pieter Wuille, and
                                    Greg Maxwell. Bulletproofs: Short proofs for conﬁdential transactions and more
                                    (conference version). In Security and Privacy (SP), 2018 IEEE Symposium on, pages
                                    319–338. IEEE, 2018.
                   [BCC`16]         Jonathan Bootle, Andrea Cerulli, Pyrros Chaidos, Jens Groth, and Christophe Petit.
                                    Eﬃcient zero-knowledge arguments for arithmetic circuits in the discrete log setting.
                                    In Annual International Conference on the Theory and Applications of Cryptographic
                                    Techniques, pages 327–357. Springer, 2016.
                   [BCCT12]         Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. From extractable
                                    collision resistance to succinct non-interactive arguments of knowledge, and back
                                    again. In Innovations in Theoretical Computer Science 2012, pages 326–349, 2012.
                   [BCCT13]         Nir Bitansky, Ran Canetti, Alessandro Chiesa, and Eran Tromer. Recursive compo-
                                    sition and bootstrapping for SNARKS and proof-carrying data. In Symposium on
                                    Theory of Computing Conference, STOC’13, Palo Alto, CA, USA, June 1-4, 2013,
                                    pages 111–120, 2013.
                         `
                   [BCG 17a]        Eli Ben-Sasson, Alessandro Chiesa, Ariel Gabizon, Michael Riabzev, and Nicholas
                                    Spooner. Interactive oracle proofs with constant rate and query complexity. In 44th
                                    International Colloquium on Automata, Languages, and Programming, ICALP 2017,
                                    July 10-14, 2017, Warsaw, Poland, pages 40:1–40:15, 2017.
                         `
                   [BCG 17b]        Jonathan Bootle, Andrea Cerulli, Essam Ghadaﬁ, Jens Groth, Mohammad Haji-
                                    abadi, and Sune K. Jakobsen. Linear-time zero-knowledge proofs for arithmetic
                                    circuit satisﬁability.    Cryptology ePrint Archive, Report 2017/872, 2017. http:
                                    //eprint.iacr.org/2017/872.
                   [BDLO12]         Daniel J Bernstein, Jeroen Doumen, Tanja Lange, and Jan-Jaap Oosterwijk. Faster
                                    batch forgery identiﬁcation. In International Conference on Cryptology in India,
                                    pages 454–473. Springer, 2012.
                   [BdM93]          Josh Cohen Benaloh and Michael de Mare. One-way accumulators: A decentralized
                                    alternative to digital sinatures (extended abstract). In Advances in Cryptology -
                                    EUROCRYPT ’93, pages 274–285, 1993.
                   [BG12]           Stephanie Bayer and Jens Groth. Eﬃcient zero-knowledge argument for correctness
                                    of a shuﬄe. In Annual International Conference on the Theory and Applications of
                                    Cryptographic Techniques, pages 263–280. Springer, 2012.
                   [BGB17]          Benedikt Bunz,¨      Steven Goldfeder, and Joseph Bonneau.                  Proofs-of-delay and
                                    randomness beacons in ethereum.              IEEE SECURITY and PRIVACY ON THE
                                    BLOCKCHAIN (IEEE S&B), 2017.
                   [BGG17]          Sean Bowe, Ariel Gabizon, and Matthew D. Green. A multi-party protocol for
                                    constructing the public parameters of the pinocchio zk-snark.                  IACR Cryptology
                                    ePrint Archive, 2017:602, 2017.
                                                                            34
             [BGR98]    Mihir Bellare, Juan A. Garay, and Tal Rabin. Fast batch veriﬁcation for modular
                        exponentiation and digital signatures. In Kaisa Nyberg, editor, Advances in Cryptol-
                        ogy — EUROCRYPT’98, pages 236–250, Berlin, Heidelberg, 1998. Springer Berlin
                        Heidelberg.
             [BLS01]    Dan Boneh, Ben Lynn, and Hovav Shacham. Short signatures from the weil pair-
                        ing. In International Conference on the Theory and Application of Cryptology and
                        Information Security, pages 514–532. Springer, 2001.
             [BMC`15]   Joseph Bonneau, Andrew Miller, Jeremy Clark, Arvind Narayanan, Joshua A. Kroll,
                        and Edward W. Felten. Research Perspectives and Challenges for Bitcoin and Cryp-
                        tocurrencies. IEEE Symposium on Security and Privacy, 2015.
             [BR93]     Mihir Bellare and Phillip Rogaway. Random oracles are practical: A paradigm for
                        designing eﬃcient protocols. In CCS ’93, pages 62–73, 1993.
             [BSBC`17]  Eli Ben-Sasson, Iddo Bentov, Alessandro Chiesa, Ariel Gabizon, Daniel Genkin,
                        Matan Hamilis, Evgenya Pergament, Michael Riabzev, Mark Silberstein, Eran
                        Tromer, et al. Computational integrity with a public random string from quasi-
                        linear pcps. In Annual International Conference on the Theory and Applications of
                        Cryptographic Techniques, pages 551–579. Springer, 2017.
             [BSBTHR18] Eli Ben-Sasson, Iddo Ben-Tov, Yinon Horesh, and Michael Riabzev. Scalable, trans-
                        parent, and post-quantum secure computational integrity. https://eprint.iacr.
                        org/2018/046.pdf, 2018.
             [BSCG`13]  Eli Ben-Sasson, Alessandro Chiesa, Daniel Genkin, Eran Tromer, and Madars Virza.
                        SNARKs for C: Verifying program executions succinctly and in zero knowledge. In
                        CRYPTO, 2013.
             [BSCG`14]  Eli Ben-Sasson, Alessandro Chiesa, Christina Garman, Matthew Green, Ian Miers,
                        EranTromer,andMadarsVirza. Zerocash: Decentralizedanonymouspaymentsfrom
                        Bitcoin. In IEEE Symposium on Security and Privacy. IEEE, 2014.
             [CCs08]    Jan Camenisch, Raﬁk Chaabouni, and abhi shelat. Eﬃcient protocols for set mem-
                        bershipandrangeproofs. Advances in Cryptology-ASIACRYPT 2008, pages234–252,
                        2008.
             [CD98]     Ronald Cramer and Ivan Damg˚ard. Zero-knowledge proofs for ﬁnite ﬁeld arithmetic,
                        or: Can zero-knowledge be for free? In CRYPTO 98, pages 424–441. Springer, 1998.
             [CGGN17]   Matteo Campanelli, Rosario Gennaro, Steven Goldfeder, and Luca Nizzardo. Zero-
                        knowledge contingent payments revisited: Attacks and payments for services. Com-
                        mun. ACM, 2017.
             [Cha82]    David Chaum. Blind signatures for untraceable payments. In CRYPTO, 1982.
             [CHL05]    Jan Camenisch, Susan Hohenberger, and Anna Lysyanskaya. Compact e-cash. In
                        EUROCRYPT,2005.
                                                    35
              [CLas10]      Raﬁk Chaabouni, Helger Lipmaa, and abhi shelat. Additive combinatorics and dis-
                            crete logarithm based range protocols. In Information Security and Privacy - 15th
                            Australasian Conference, ACISP 2010, Sydney, Australia, July 5-7, 2010. Proceed-
                            ings, pages 336–351, 2010.
              [CRR11]       Ran Canetti, Ben Riva, and Guy N Rothblum. Practical delegation of computation
                            using multiple servers. In Proceedings of the 18th ACM conference on Computer and
                            communications security, pages 445–454. ACM, 2011.
                    `
              [DBB 15]      G Dagher, B Bunz,¨  Joseph Bonneau, Jeremy Clark, and D Boneh. Provisions:
                            Privacy-preserving proofs of solvency for bitcoin exchanges (full version). Techni-
                            cal report, IACR Cryptology ePrint Archive, 2015.
              [FS01]        Jun Furukawa and Kazue Sako. An eﬃcient scheme for proving a shuﬄe. In Crypto,
                            volume 1, pages 368–387. Springer, 2001.
              [GGPR13]      Rosario Gennaro, Craig Gentry, Bryan Parno, and Mariana Raykova. Quadratic
                            span programs and succinct nizks without pcps. In Advances in Cryptology - EU-
                            ROCRYPT 2013, pages 626–645, 2013.
              [GH98]        Oded Goldreich and Johan H˚astad. On the complexity of interactive proofs with
                            bounded communication. Inf. Process. Lett., 67(4):205–214, 1998.
              [GI08a]       Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of
                            a shuﬄe. Advances in Cryptology–EUROCRYPT 2008, pages 379–396, 2008.
              [GI08b]       Jens Groth and Yuval Ishai. Sub-linear zero-knowledge argument for correctness of
                            a shuﬄe. In Advances in Cryptology - EUROCRYPT 2008, pages 379–396, 2008.
              [GKR08]       Shaﬁ Goldwasser, Yael Tauman Kalai, and Guy N Rothblum. Delegating compu-
                            tation: interactive proofs for muggles. In Proceedings of the fortieth annual ACM
                            symposium on Theory of computing, pages 113–122. ACM, 2008.
              [Gor98]       Daniel M Gordon. A survey of fast exponentiation methods. Journal of algorithms,
                            27(1):129–146, 1998.
              [Gro03]       Jens Groth. A veriﬁable secret shuﬄe of homomorphic encryptions. In Public Key
                            Cryptography, volume 2567, pages 145–160. Springer, 2003.
              [Gro05]       Jens Groth. Non-interactive zero-knowledge arguments for voting. In International
                            Conference on Applied Cryptography and Network Security, pages 467–482. Springer,
                            2005.
              [Gro10]       Jens Groth. Short pairing-based non-interactive zero-knowledge arguments. In Ad-
                            vances in Cryptology - ASIACRYPT 2010, pages 321–340, 2010.
              [Gro16]       Jens Groth. On the size of pairing-based non-interactive arguments. In Advances in
                            Cryptology - EUROCRYPT 2016, pages 305–326, 2016.
              [GS08]        Jens Groth and Amit Sahai. Eﬃcient non-interactive proof systems for bilinear
                            groups. In Advances in Cryptology - EUROCRYPT 2008, pages 415–432, 2008.
                                                           36
               [GVW02]      Oded Goldreich, Salil P. Vadhan, and Avi Wigderson. On interactive proofs with a
                            laconic prover. Computational Complexity, 11(1-2):1–53, 2002.
               [Jed16]      TEJedusor. Mimblewimble, 2016.
                    `
               [KMS 16]     Ahmed Kosba, Andrew Miller, Elaine Shi, Zikai Wen, and Charalampos Papaman-
                            thou. Hawk: The blockchain model of cryptography and privacy-preserving smart
                            contracts. In Security and Privacy (SP), 2016 IEEE Symposium on, pages 839–858.
                            IEEE, 2016.
               [KP95]       Joe Kilian and Erez Petrank. An eﬃcient non-interactive zero-knowledge proof sys-
                            tem for NP with general assumptions. Electronic Colloquium on Computational
                            Complexity (ECCC), 2(38), 1995.
               [Lin03]      Yehuda Lindell. Parallel coin-tossing and constant-round secure two-party computa-
                            tion. J. Cryptology, 16(3):143–184, 2003.
               [Lip03]      Helger Lipmaa. On diophantine complexity and statistical zero-knowledge argu-
                            ments. In International Conference on the Theory and Application of Cryptology
                            and Information Security, pages 398–415. Springer, 2003.
               [Max]        G Maxwell. Zero knowledge contingent payment. 2011. URl: https://en. bitcoin.
                            it/wiki/Zero Knowledge Contingent Payment (visited on 05/01/2016).
               [Max13]      Gregory Maxwell. CoinJoin: Bitcoin privacy for the real world. bitcointalk.org,
                            August 2013.
               [Max16]      Greg Maxwell.     Conﬁdential transactions.   https://people.xiph.org/ greg/
                                                                                                     ~
                            confidential_values.txt, 2016.
               [Mic94]      Silvio Micali. Cs proofs. In Foundations of Computer Science, 1994 Proceedings.,
                            35th Annual Symposium on, pages 436–453. IEEE, 1994.
               [Mon]        Monero - Private Digital Currency . https://getmonero.org/.
               [MP15]       GregoryMaxwellandAndrewPoelstra. Borromeanringsignatures. http://diyhpl.
                            us/ bryan/papers2/bitcoin/Borromean%20ring%20signatures.pdf, 2015.
                                ~
               [MPJ`13]     Sarah Meiklejohn, Marjori Pomarole, Grant Jordan, Kirill Levchenko, Damon Mc-
                            Coy, Geoﬀrey M Voelker, and Stefan Savage. A ﬁstful of bitcoins: characterizing
                            payments among men with no names. In IMC, 2013.
               [MSH17]      Patrick McCorry, Siamak F Shahandashti, and Feng Hao. A smart contract for
                            boardroom voting with maximum voter privacy. IACR Cryptology ePrint Archive,
                            2017:110, 2017.
               [Nak08]      S Nakamoto. Bitcoin: A peer-to-peer electionic cash system. Unpublished, 2008.
               [Nef01]      CAndrewNeﬀ. Averiﬁable secret shuﬄe and its application to e-voting. In Proceed-
                            ings of the 8th ACM conference on Computer and Communications Security, pages
                            116–125. ACM, 2001.
                                                            37
                   `
               [NM 16]      ShenNoether, AdamMackenzie, etal. Ringconﬁdential transactions. Ledger, 1:1–18,
                            2016.
                 `
               [P 91]       Torben P Pedersen et al. Non-interactive and information-theoretic secure veriﬁable
                            secret sharing. In Crypto, volume 91, pages 129–140. Springer, 1991.
               [PBF`]       Andrew Poelstra, Adam Back, Mark Friedenbach, Gregory Maxwell, and Pieter
                            Wuille. Conﬁdential assets.
               [PHGR13]     Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: Nearly
                            practical veriﬁable computation. In Security and Privacy (SP), 2013 IEEE Sympo-
                            sium on, pages 238–252. IEEE, 2013.
               [PHGR16]     Bryan Parno, Jon Howell, Craig Gentry, and Mariana Raykova. Pinocchio: nearly
                            practical veriﬁable computation. Commun. ACM, 59(2):103–112, 2016.
               [Pip80]      Nicholas Pippenger. On the evaluation of powers and monomials. SIAM Journal on
                            Computing, 9:230–250, 1980.
               [Poe]        Andrew Poelstra. Mimblewimble.
               [RM]         Tim Ruﬃng and Giulio Malavolta. Switch commitments: A safety switch for conﬁ-
                            dential transactions.
               [RMSK14]     Tim Ruﬃng, Pedro Moreno-Sanchez, and Aniket Kate. CoinShuﬄe: Practical de-
                            centralized coin mixing for Bitcoin. In ESORICS, 2014.
               [San99]      Tomas Sander. Eﬃcient accumulators without trapdoor extended abstract. Infor-
                            mation and Communication Security, pages 252–262, 1999.
               [TR]         Jason Teutsch and Christian Reitwießner.     A scalable veriﬁcation solution for
                            blockchains.
               [vS13]       Nicolas van Saberhagen. Cryptonote v 2. 0, 2013.
               [Woo14]      Gavin Wood.     Ethereum: A secure decentralized transaction ledger.    http://
                            gavwood.com/paper.pdf, 2014.
               [WTs`]       Riad S Wahby, Ioanna Tzialla, abhi shelat, Justin Thaler, and Michael Walﬁsh.
                            Doubly-eﬃcient zksnarks without trusted setup.
               A AGeneral Forking Lemma
                                                            `
               Webrieﬂy describe the forking lemma of [BCC 16] that will be needed in the proofs.
                  Suppose that we have a p2µ ` 1q-move public-coin argument with µ challenges, x ,...,x in
                                                           ś                                     1      µ
               sequence. Let n ě 1 for 1 ď i ď µ. Consider   µ  n accepting transcripts with challenges in the
                              i                              i“1 i
                                                               ś
               following tree format. The tree has depth µ and   µ  n leaves. The root of the tree is labeled
                                                                 i“1 i
               with the statement. Each node of depth i ă µ has exactly n children, each labeled with a distinct
                                                                        i
               value of the ith challenge x .
                                         i
                                                            38
                    This can be referred to as an pn ,...,n q-tree of accepting transcripts. Given a suitable tree
                                                      1       µ
                of accepting transcripts, one can compute a valid witness for our inner-product argument, range
                proof, and argument for arithmetic circuit satisﬁability. This is a natural generalization of special-
                soundness for Sigma-protocols, where µ “ 1 and n “ 2. Combined with Theorem 6, this shows that
                the protocols have witness-extended emulation, and hence, the prover cannot produce an accepting
                transcript unless they know a witness. For simplicity in the following lemma, we assume that
                the challenges are chosen uniformly from Zp where |p| “ λ, but any suﬃciently large challenge
                space would suﬃce. The success probability of a cheating prover scales inversely with the size of
                the challenge space and linearly with the number of accepting transcripts that an extractor needs.
                             ś
                                µ                      λ
                Therefore if       n is negligible in 2 , then a cheating prover can create a proof that the veriﬁer
                                i“1 i
                accepts with only negligible probability.
                                                       `
                Theorem 6 (Forking Lemma, [BCC 16]). Let pSetup,P,Vq be a p2k`1q-move, public coin inter-
                active protocol. Let χ be a witness extraction algorithm that succeeds with probability 1 ´ µpλq for
                some negligible function µpλq in extracting a witness from an pn ,...,n q-tree of accepting tran-
                                                                        ś            1       k
                scripts in probabilistic polynomial time. Assume that      k  n is bounded above by a polynomial in
                                                                           i“1 i
                the security parameter λ. Then pSetup,P,Vq has witness-extended emulation.
                                                                                `
                    The theorem is slightly diﬀerent than the one from [BCC 16]. We allow the extractor χ to fail
                with negligible probability. Whenever this happens the Emulator E as deﬁned by Deﬁnition 10 also
                simply fails. Even with this slight modiﬁcation this slightly stronger lemma still holds as E overall
                still only fails with negligible probability.
                B Proof of Theorem 1
                Proof. Perfect completeness follows directly because Protocol 1 converts an instance for relation (2)
                into an instance for relation (3). Protocol 2 is trivially complete. For witness extended emulation
                                                                               2
                we show that there exists an eﬃcient extractor χ that uses n transcripts, as needed by Theorem 6.
                    First we show how to construct an extractor χ for Protocol 2 which on input pg,h,u,Pq, either
                                                                    1
                extracts a witness a,b such that relation (3) holds, or discovers a non-trivial discrete logarithm
                relation between g,h,u. Note that the hardness of computing a discrete log relation between
                  1  1
                g,h,u implies the hardness of computing one between g,h,u as deﬁned in Protocol 2. We will,
                therefore, use an inductive argument showing that in each step we either extract a witness or a
                discrete log relation.
                    If n “ |g| “ 1, then the prover reveals the witness pa,bq in the protocol and the relation
                       a b a¨b
                P “g h u      can simply be checked directly.
                    Next, we show that for each recursive step that on input pg,h,u,Pq, we can eﬃciently extract
                from the prover a witness a,b or a non-trivial discrete logarithm relation between g,h,u. The
                extractor runs the prover to get L and R. Then, by rewinding the prover four times and giving it
                four challenges x ,x ,x ,x , such that x ‰ ˘x for 1 ď i ă j ď 4, the extractor obtains four pairs
                            1     1  2   3  4             i       j
                  1   1    n
                ai,bi P Zp such that
                                     ˆ             ˙ 1   ˆ             ˙ 1
                          2     ´2       ´1          a i             ´1  bi     1  1
                         x     x        x       x           x       x          xa ,b y
                       L iPR i “ g i1 ˝g i1             ¨  h i 1 ˝ h i1     ¨ u  i  i     for i “ 1,...,4.       (106)
                                        r:n s  rn :s        r:n s   rn :s
                                                                  39
                       Wecan use the ﬁrst three challenges x ,x ,x , to compute ν ,ν ,ν P Z such that
                                                                                  1    2    3                      1    2    3      p
                                                                 3                        3                  3
                                                                ÿ           2            ÿ                  ÿ           ´2
                                                                     ν ¨ x “ 1,               ν “0,              ν ¨ x       “0.
                                                                       i    i                   i                  i    i
                                                                i“1                      i“1                i“1
                       Then taking a linear combination of the ﬁrst three equalities in (106), with ν ,ν ,ν as the coeﬃ-
                                                                                                                                            1    2    3
                                                                           n                                             a    b     c
                       cients, we can compute a ,b P Z and c P Zp such that L “ g Lh Lu L. Repeating this process
                                                             L     L       p          L
                       with diﬀerent combinations, we can also compute a ,a ,b ,b P Zn and c ,c P Zp such that
                                                                                                     P     R P R               p          P    R
                                                                              a     b    c                     a    b     c
                                                                     R“g Rh Ru R,                    P “g Ph Pu P.
                                                                                                               1   1      n1
                       Now, for each x P tx ,x ,x ,x u and the corresponding a ,b P Z                                         we can rewrite (106) as:
                                                      1    2    3     4                                                   p
                               2              ´2          2              ´2         2             ´2          2       ´2          1  ´1     1      1      1   ´1     1   1
                         a ¨x `a `a ¨x              b ¨x `b `b ¨x              c ¨x `c `c ¨x                x        x          a ¨x      a ¨x   b¨x b¨x           xa ,b y
                       g L          P    R       ¨h L          P     R      ¨u L         P    R       “L PR               “g 1 g 1 h 1 h 1                       u         .
                                                                                                                                r:n s     rn :s  r:n s   rn :s
                       This implies that
                                                                  1    ´1              1     2             1             1     ´2
                                                                a ¨ x      “a             ¨ x `a             `a             ¨ x
                                                                     1           L,r:n s     2       P,r:n s       R,r:n s     ´2
                                                                   a ¨ x “ a          1   ¨ x `a          1  `a 1 ¨x
                                                                     1           L,rn :s      2      P,rn :s       R,rn :s      ´2
                                                                   b ¨x “ b            1  ¨ x `b           1  `b          1 ¨ x                                     (107)
                                                                  1    ´1        L,r:n s      2      P,r:n s        R,r:n s     ´2
                                                               b ¨x        “b 1 ¨x `b 1 `b 1 ¨x
                                                                                 L,rn :s             P,rn :s        R,rn :s
                                                                    1   1              2                     ´2
                                                                xa ,b y “ cL ¨ x `cP `cR ¨x
                       If any of these equalities do not hold, we directly obtain a non-trivial discrete logarithm relation
                       between the generators pg ,...,g ,h ,...,h ,uq.
                                                              1          n     1          n
                       If the equalities hold, we can deduce that for each challenge x P tx ,x ,x ,x u
                                                                                                                            1    2    3    4
                                           1      3             1             1                     1            1       ´1             1      ´3
                                   a          ¨ x `pa              ´a           q ¨ x ` pa            ´a           q ¨ x      ´a            ¨ x     “0              (108)
                                     L,r:n s               P,r:n s      L,rn :s               R,r:n s       P,rn :s                R,rn :s
                                         1      3              1              1                   1              1       ´1              1     ´3
                                  b          ¨ x `pb              ´b           q ¨ x ` pb             ´b           q ¨ x     ´b             ¨ x     “0              (109)
                                    L,rn :s               P,rn :s       L,r:n s              R,rn :s       P,r:n s                 R,r:n s
                       The equality (108) follows from the ﬁrst two equations in (107). Similarly, (109) follows from the
                       third and fourth equations in (107).
                             The only way (108) and (109) hold for all 4 challenges x ,x ,x ,x P Z is if
                                                                                                                  1    2    3    4       p
                                                                   a       1  “a 1 “b                   1  “b 1 “0,
                                                                     L,r:n s       R,rn :s        R,r:n s        L,rn :s
                                                                   a      1   “a         1 ,        a       1 “a 1                                                  (110)
                                                                     L,rn :s       P,r:n s            R,r:n s       P,rn :s
                                                                   b       1  “b 1 ,                b      1   “b 1.
                                                                     L,r:n s        P,rn :s           R,rn :s        P,r:n s
                       Plugging these relations into (107) we obtain that for every x P tx ,x ,x ,x u we have that
                                                                                                                            1    2    3    4
                                             1             1                1      ´1                        1            1     ´1              1
                                           a “a              ¨ x ` a            ¨ x           and         b “b               ¨ x     `b            ¨ x.
                                                     P,r:n s           P,rn :s                                      P,r:n s               P,rn :s
                       Now, using these values we can see that the extracted c ,c                                   and c       have the expected form:
                                                                                                            L P             R
                                     2                     ´2          1   1
                             c ¨x `c `c ¨x “xa,by
                               L            P       R
                                                    1                 1      ´1              1     ´1             1
                                        “xa            ¨ x ` a           ¨ x      , b          ¨ x     `b            ¨ xy
                                               P,r:n s           P,rn :s               P,r:n s               P,rn :s
                                                    1          1        2              1          1               1           1               1           1       ´2
                                        “xa           , b         y ¨ x `xa             , b         y `xa            , b        y `xa            , b        y ¨ x
                                               P,r:n s    P,rn :s                P,r:n s    P,r:n s          P,rn :s    P,rn :s          P,rn :s     P,r:n s
                                                    1          1        2                              1           1       ´2
                                        “xa           , b         y ¨ x `xa ,b y`xa                       , b        y ¨ x     .
                                               P,r:n s    P,rn :s                P     P          P,rn :s    P,r:n s
                                                                                                40
                 Since this relation holds for all x P tx ,x ,x ,x u it must be that
                                                         1  2   3  4
                                                             xa ,b y “ c .
                                                               P    P      P
                 The extractor, thus, either extracts a discrete logarithm relation between the generators, or the
                 witness pa ,b q for the relation (3).
                            P   P
                                                                              log2pnq    2
                    Using Theorem 6 we can see that the extractor uses 4             “n transcripts in total and thus
                 runs in expected polynomial time in n and λ.
                    WenowshowthatusingProtocol1wecanconstructanextractorχthatextractsavalidwitness
                 for relation (3). The extractor uses the extractor χ of Protocol 2. On input pg,h,u,P,cq χ runs
                                                                        1
                 the prover with on a challenge x and uses the extractor χ to obtain a witness a,b such that:
                                                                                 1
                      x¨c    a b x¨xa,by                                                                 1
                 P ¨ u   “g h u          . Rewinding P, supplying him with a diﬀerent challenge x and rerunning
                                                               1   1
                 the extractor χ1 yields a second witness pa ,b q. Again the soundness of Protocol 2 implies that
                       1       1  1  1  1 1
                      x ¨c   a   b x¨xa,by
                 P ¨ u   “g h u             . From the two witnesses, we can compute:
                                                       1          1     1         1  1  1
                                                 upx´xq¨c “ ga´a hb´b ux¨xa,by´x ¨xa ,b y
                              1            1
                 Unless a “ a and b “ b we get a not trivial discrete log relation between g,h and u. Otherwise
                              1            1
                          px´x q¨c     px´x q¨xa,by
                 we get u         “ u              ùñ c “ xa,by. Thus, pa,bq is a valid witness for relation (3).
                 Since χ forks the prover once, and uses the eﬃcient extractor χ1 twice, it is also eﬃcient. Using
                 the forking lemma (Theorem 6) we conclude that the protocol has witness extended emulation.
                 C Proof of Theorem 3
                                                                                                2     m
                 Proof. Perfect completeness follows from the fact that t        “ δpy,zq ` z ¨ xz ,vy for all valid
                                                                               0
                 witnesses. To prove perfect honest-veriﬁer zero-knowledge we construct a simulator that produces a
                                                                                 n¨m         m
                 distribution of proofs for a given statement pg,h P G,g,h P G       , V P G q that is indistinguishable
                 from valid proofs produced by an honest prover interacting with an honest veriﬁer. The simulator
                 chooses all proof elements and challenges according to the randomness supplied by the adversary
                 from their respective domains or computes them directly as described in the protocol. S and T
                                                                                                                        1
                 are computed according to the veriﬁcation equations, i.e.:
                                                                              m
                                                           n¨m      z¨yn¨m´r ź     zj`1¨2n        ´1
                                              ´µ       ´z¨1   ´l    1             1             ´x
                                      S “ph      ¨ A ¨ g         ¨ h         j“1hrpj´1q¨m:j¨msq
                                                         ˆ    2 m      2   ´1
                                              ´τ  δpy,zq´t   z ¨z     x ´x
                                     T “ph xg             ¨ V      ¨ T  q
                                       1                              2
                 Finally, the simulator runs the inner-product argument with the simulated witness pl,rq and the
                 veriﬁer’s randomness. All elements in the proof are either independently randomly distributed
                 or their relationship is fully deﬁned by the veriﬁcation equations. The inner product argument
                 remains zero knowledge as we can successfully simulate the witness, thus revealing the witness or
                 leaking information about it does not change the zero-knowledge property of the overall protocol.
                 The simulator runs in time OpV `P                q and is thus eﬃcient.
                                                        InnerProduct
                    In order to prove computational witness extended emulation, we construct an extractor χ as
                 follows. The extractor χ runs the prover with n ¨ m diﬀerent values of y, pm ` 2q diﬀerent values
                 of z, and 3 diﬀerent values of the challenge x. Additionally it invokes the extractor for the inner
                                                                    41
                product argument on each of the transcripts. This results in 3 ¨ pm ` 2q ¨ n ¨ m ¨ Opn2q valid proof
                transcripts.
                    For each transcript the extractor χ ﬁrst runs the extractor χ                 for the inner-product
                                                                                      InnerProduct
                                                                                                 µ l r                 ˆ
                argument to extract a witness l,r to the inner product argument such that h g h “ P ^xl,ry “ t.
                Using 2 valid transcripts and extracted inner product argument witnesses for diﬀerent x challenges,
                we can compute linear combinations of (67) such that in order to compute α,ρ,a ,a ,s ,s             such
                                                                                                      L R L R
                            α a    a                    ρ s   s
                that A “ h g Lh R, as well as S “ h g Lh R.
                    If for any other set of challenges px,y,zq the extractor can compute a diﬀerent representation
                of A or S, then this yields a non-trivial discrete logarithm relation between independent generators
                h,g,h which contradicts the discrete logarithm assumption.
                    Using these representations of A and S, as well as l and r, we then ﬁnd that for all challenges
                x,y and z
                                l “ a ´z¨1n¨m`s ¨x
                                      L               L
                                                                        m        ´                      ¯
                                      n¨m              n¨m             ÿ 1`j       pj´1q¨n   n  pm´jq¨n
                                r “ y     ˝pa `z¨1         `s ¨xq`        z     ¨ 0       ||2 ||0
                                              R               R
                                                                       j“1
                If these equalities do not hold for all challenges and l,r from the transcript, then we have two
                distinct representations of the same group element using a set of independent generators. This
                would be a non-trivial discrete logarithm relation.
                    For given values of y and z, we now takes 3 transcripts with diﬀerent x’s and uses linear
                combinations of equation (72) to compute τ ,τ ,t ,t such that
                                                               1  2  1  2
                                                              t  τ           t  τ
                                                       T “g1h1^T “g1h2
                                                         1             2
                                                                           ś        j`1
                                                                    v γ       m    z
                Additionally we can compute a v,γ such that g h “             j“1Vj     Repeating this for m diﬀerent
                                                         m                v  γ
                z challenges, we can compute pv ,γ q         such that g jh j “ V @j P r1,ms. If for any transcript
                          ř                         j  j j“1                        j
                            m    j`2                    2    ˆ
                δpy,zq`         z    ¨ v `t ¨x`t ¨x ‰t then this directly yields a discrete log relation between
                            j“1         j   1       2
                g and h, i.e. a violation of the binding property of the Pedersen commitment. If not, then for all
                y,z challenges and 3 distinct challenges X “ x ,j P r1,3s:
                                                                  j
                                                          2
                                                         ÿti¨Xi´ppXq“0
                                                         i“0
                                     ř                                 ř
                with t “ δpy,zq`       m zj`2¨xv ,2ny and ppXq “          2  p ¨ Xi “ xlpXq,rpXqy. Since the polyno-
                       0               j“1          j                     i“0 i
                mial tpXq ´ ppXq is of degree 2, but has at least 3 roots (each challenge x ), it is necessarily the
                                                                                                j
                zero polynomial, i.e. tpXq “ xlpXq,rpXqy.
                    Since this implies that t “ p , the following holds for all y,z challenges:
                                              0    0
                                                     řm zj`2¨xvj,2ny`δpy,zq
                                                        j“1         “
                                 xa ,yn¨m ˝a y`z¨xa ´a ,yn¨my`řm zj`1xa                             , 2ny
                                   L          R          L     R ř          j“1        L,rpj´1q¨n:j¨ns
                                                2    n¨m   n¨m       m    j`2    n   n
                                             ´z ¨x1     , y   y ´    j“1z    ¨ x1 ,2 y P Zp
                If this equality holds for n ¨ m distinct y challenges and m ` 2 distinct z challenges, then we can
                                                                   42
                    infer the following.
                                                          n¨m                                                        n¨m
                                           a ˝a “0                                                               P Z
                                            L     R                                                                  p
                                                 a “a ´1n¨m                                                      P Zn¨m
                                                  R       L                                                          p
                                                                             n
                                                 vj “ xa                  , 2 y                       P Zp@j P r1,ms
                                                           L,rpj´1q¨n:j¨ns
                                                                               n¨m                                                    n´1
                    The ﬁrst two equations imply that a P t0,1u                    . The last equation imply that v P r0,2                 s for
                                                                   L                                                         j
                                               vi  γi
                    all j P r1,ms. Since g h          “V @jPr1,ms we have that pv,γq is valid witness for relation (69).
                                                           i
                                                                                             2
                    The extractor rewinds the prover 3 ¨ pm ` 2q ¨ n ¨ m ¨ Opn q times. Extraction is eﬃcient and the
                    number of transcripts is polynomial in λ because n,m “ Opλq. Note that extraction either returns
                    a valid witness or a discrete logarithm relation between independently chosen generators. We deﬁne
                     1
                    χ being equal to χ but failing whenever χ extracts a discrete log relation. By the Discrete Log
                    Relation assumption this happens with at most negligible probability. We can, therefore, apply the
                    forking lemma and see that computational witness emulation holds.
                    D Proof of Theorem 4
                    Proof. Perfect completeness follows from the fact that
                                            Q`1                                                                  Q`1
                      t   “ δpy,zq ` xz          , W ¨ a ` W ¨a `W ¨a y “ δpy,zq`xz                                  , W ¨ v ` cy (111)
                       2                    r1:s      L     L        R     R        O     O                      r1:s     V
                        whenever the prover knows a witness to the relation and is honest.
                        Toproveperfecthonest-veriﬁer zero-knowledge we construct an eﬃcient simulator that produces
                    a distribution of proofs for a given statement
                            ´                       n          m                         Q        nˆ3           Q        m         Q ¯
                               g,h P G,g,h P G ,V P G ,pw                , w     , w    q     P Z      , pw    q     P Z ,c P Z
                                                                      L,q    R,q    O,q q“1       p         V,q q“1      p         p
                    and the veriﬁer’s randomness that is indistinguishable from valid proofs produced by an honest
                    prover interacting with an honest veriﬁer. The simulator acts as follows:
                                        Compute x,y,z using V’s randomness                                                                (112)
                                                     $
                                              µ,τ ÐÝ Z                                                                                    (113)
                                                  x       p
                                                     $    n
                                                l, r ÐÝ Z                                                                                 (114)
                                                          p
                                                   ˆ
                                                   t “ xl,ry                                                                              (115)
                                                     $
                                           A ,A ÐÝG                                                                                       (116)
                                             I    O
                                                       ´                                                     ¯ ´3
                                                  S “       x    x2    ´l 1´yn´r        x     x          ´µ    ´x                         (117)
                                                          A ¨A ¨g h                 ¨ W ¨W ¨W ¨h
                                                            I    O                     L      R     O
                                                     $
                                     T ,T ,T ,T ÐÝ G                                                                                      (118)
                                       3   4  5   6
                                                       ´          2           Q`1            2  Q`1         ś           ¯´x´1
                                                                                       ˆ                       6      i
                                                 T “        ´τx x ¨pδpy,zq`xzr1:s ,cyq´t    x ¨pzr1:s ¨WV q         x                     (119)
                                                  1       h     g                       ¨ V                ¨   i“3 Ti
                                                                              6           ˆ
                                         Output: pA ,A ,S;y,z;T ,pT q ;x;τ ,µ,t,l,rq                                                      (120)
                                                       I   O            1    i 3     x
                     The values A ,A ,l,r,µ,τx produced by an honest prover interacting with an honest veriﬁer are
                                      I   O
                    random independent elements, i.e. if s,ρ,α,τ ,pτ q6,ρ as well as x,y,z are chosen independently
                                                                              1    i 3
                                                                                 43
                                 ˆ
                and randomly. t is the inner product of l,r as in any verifying transcript. The simulated S is fully
                deﬁned by equations (92). The honestly produced T are perfectly hiding commitments and as such
                                                                           ˆ
                random group elements. Their internal relation given t and τ is fully deﬁned by equation (90),
                                                                                  x
                which is ensured by computing T accordingly. Therefore, the transcript of the proof is identically
                                                   1
                distributed to an honestly computed proof with uniformly selected challenges. The simulator runs
                in time OpVq and is thus eﬃcient.
                    In order to prove computational witness extended emulation we construct an extractor χ as
                follows. The χ runs the prover with n diﬀerent y, pQ ` 1q diﬀerent z and 7 diﬀerent x challenges.
                This results in 7¨pQ`1q¨n valid proof transcripts. We takes 3 valid transcripts for x P tx ,x ,x u
                                                                                                               1  2   3
                                                                  ˆ
                and ﬁxed y and z. From the transmitted l,r,t for each combination of challenges, we compute
                ν ,ν ,ν such that
                  1  2  3
                                               3                3            3
                                               ÿ               ÿ       2    ÿ       3
                                                  ν ¨ x “ 1^      ν ¨ x “      ν ¨ x “ 0
                                                   i   i            i           i   i
                                              i“1              i“1          i“1
                Taking the linear combinations of equation (92) with pν ,ν ,ν q as coeﬃcients, we compute α P
                                                                            1   2  3
                                n              α a   a
                Zp,a ,a     P Z such that h g Lh R “ A . If for any other set of challenges we can compute
                     L R        p                             I
                                                   1  1   1
                            1  1   1              α a a                 α a    a
                diﬀerent α ,a ,a     such that h g Lh R “ A “ h g Lh R, then this yields a non-trivial dis-
                               L R                                I
                crete log relation between independent generators h,g,h which contradicts the discrete log relation
                assumption. Similarly, we can use the same challenges and equation (92) to compute unique
                                                 n             β a     a                 ρ s   s
                β,ρ P Zp,a     , a   , s ,s  P Z such that h g O,Lh O,R “ A        and h g Lh R “ S.
                            O,L   O,R  L R       p                              O
                    Using Equation (92), we can replace A ,A ,S with the computed representations and read
                                                              I   O
                    ˆ
                l, r, t from the transcripts. We then ﬁnd that for all challenges x,y,z:
                             l “ a ¨x`a        ¨ x2 ` y´n ˝ pzQ`1 ¨ W q¨X `s ¨x3
                                  L        O,L                r1:s     R         L
                                  n             n     Q`1                       n           2    n         3
                            r “ y ˝a ¨x´y `z              ¨ pW ¨x`W q`y ˝a               ¨ x `y ˝s ¨x
                                       R              r1:s     L         O           O,R              R
                             ˆ
                             t “ xl,ry
                If these equalities do not hold for all challenges and l,r from the transcript, then we necessarily
                have a non-trivial discrete log relation between the generators g,h and h.
                    Wenowshowthatt2 indeedhastheformdescribedin(111). For a given y,z the extractor takes
                6 transcripts with diﬀerent x’s and uses linear combinations of equation (90) to compute pτ ,t q,i P
                                                                                                               i  i
                                                                                                                       i
                                             t  τ                                                                     x
                r1,3,...,6s such that T “ g ih i. Note that the linear combinations have to cancel out the other T
                                        i                                                                            i
                                    zQ`1¨WV x2                                                       v γ      zQ`1¨WV
                terms as well as pv r1:s    q  . Using these pτ ,t q we can compute v,γ such that g h “ V r1:s         .
                                                               i  i
                Repeating this for m diﬀerent z challenges, we can compute pv ,γ qm          using linear combinations
                                                                                   j  j j“1
                              Q`1
                    v γ      z    ¨WV             v   γ
                of g h “ V r1:s        such that g jh j “ Vj@j P r1,ms. This will however only succeed if the weight
                vectors w     are linearly independent, i.e if the matrix W     has rank m. This necessarily implies
                           V,j                              ř                 V
                                                              6        i    2     Q`1                            ˆ
                that Q ě m. If for any transcript t1 ¨ x `        ti ¨ x ` x ¨ pxz    , W ¨v`cy`δpy,zqq‰t then
                                                              i“3                 r1:s    V
                this directly yields a a discrete log relation between g and h.
                    If not, then for all y,z challenges and 7 distinct challenges x “ xj,j P r1,7s:
                                                           6
                                                          ÿti¨x´ppxq“0                                            (121)
                                                          i“1
                             Q`1                                     ř6         i
                with t “ xz      , W ¨v`cy`δpy,zq and ppxq “               p ¨x “xlpxq,rpxqy . Since the polynomial
                       2     r1:s    V                                 i“1 i
                tpxq ´ ppxq is of degree 6, but has at least 7 roots (each challenge x ), it is necessarily the zero
                                                                                          j
                                                                   44
                polynomial, i.e. tpxq “ xlpxq,rpxqy. Finally, we show that this equality implies that we can extract
                a witness pa ,a ,a P Zn,v,γ P Zmq which satisﬁes the relation.
                             L R O         p          p
                    The quadratic coeﬃcient of p is:
                                 n                 n       Q`1
                     p “xa ,y ˝a y´xa            , y y ` xz    , W ¨a `W          ¨ a  `W ¨a y`δpy,zqPZ
                      2      L        R       O,L          r1:s    L   L       R,q   R      O    O,L               p
                The polynomial equality implies that any challenge y,z, p “ t . Using a ﬁxed y and pQ ` 1q
                                                                                2     2
                diﬀerent z challenges we can infer that all coeﬃcients of p pzq ´ t pzq have to be zero. Using n
                                                                                2       2
                diﬀerent y challenges, i.e. n ¨ pQ ` 1q total transcripts we can infer the following equalities:
                                                                                        n    n
                                                                     a ˝a ´a        “0 PZ                          (122)
                                                                      L    R    O,L          p
                                                                                             Q
                                           W ¨a `W ¨a `W ¨a                 “W ¨v`cPZ                              (123)
                                             L    L     R    R     O    O,L     V            p
                 From equation (122) we can directly infer that a ˝ a        “a . Equations (123) are exactly the
                                                                      L    R     O,L
                linear constraints on the circuit gates.
                    Deﬁning a     “ a     , we can conclude that pa ,a ,a ,v,γq is indeed a valid witness. Ex-
                                O      O,L                             L R O
                traction is eﬃcient and the number of transcripts is polynomial in λ because n,m “ Opλq. Note
                that extraction either returns a valid witness or a non-trivial discrete logarithm relation between
                                                                  1
                independently chosen generators. We deﬁne χ being equal to χ but failing whenever χ extracts
                a discrete log relation. By the discrete log relation assumption this happens with at most negli-
                gible probability. We can, therefore, apply the forking lemma and see that computational witness
                emulation holds.
                                                                   45
