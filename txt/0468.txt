                    ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER
                                                                 EIP-150 REVISION
                                                                   DR. GAVIN WOOD
                                                          FOUNDER, ETHEREUM&ETHCORE
                                                                  GAVIN@ETHCORE.IO
                        Abstract. The blockchain paradigm when coupled with cryptographically-secured transactions has demonstrated its
                        utility through a number of projects, not least Bitcoin. Each such project can be seen as a simple application on
                        a decentralised, but singleton, compute resource. We can call this paradigm a transactional singleton machine with
                        shared-state.
                           Ethereum implements this paradigm in a generalised manner. Furthermore it provides a plurality of such resources,
                        each with a distinct state and operating code but able to interact through a message-passing framework with others.
                        Wediscuss its design, implementation issues, the opportunities it provides and the future hurdles we envisage.
                                   1. Introduction                             information is often lacking, and plain old prejudices are
                  With ubiquitous internet connections in most places          diﬃcult to shake.
               of the world, global information transmission has become           Overall, I wish to provide a system such that users can
               incredibly cheap. Technology-rooted movements like Bit-         be guaranteed that no matter with which other individ-
               coin have demonstrated, through the power of the default,       uals, systems or organisations they interact, they can do
               consensus mechanisms and voluntary respect of the social        so with absolute conﬁdence in the possible outcomes and
               contract that it is possible to use the internet to make        how those outcomes might come about.
               a decentralised value-transfer system, shared across the        1.2. Previous Work. Buterin [2013a] ﬁrst proposed the
               world and virtually free to use. This system can be said        kernel of this work in late November, 2013. Though now
               to be a very specialised version of a cryptographically se-     evolved in many ways, the key functionality of a block-
               cure, transaction-based state machine. Follow-up systems        chain with a Turing-complete language and an eﬀectively
               such as Namecoin adapted this original “currency appli-         unlimited inter-transaction storage capability remains un-
               cation” of the technology into other applications albeit        changed.
               rather simplistic ones.                                            DworkandNaor[1992]provided the ﬁrst work into the
                  Ethereum is a project which attempts to build the gen-       usage of a cryptographic proof of computational expendi-
               eralised technology; technology on which all transaction-       ture (“proof-of-work”) as a means of transmitting a value
               based state machine concepts may be built. Moreover it          signal over the Internet. The value-signal was utilised here
               aims to provide to the end-developer a tightly integrated       as a spam deterrence mechanism rather than any kind
               end-to-end system for building software on a hitherto un-       of currency, but critically demonstrated the potential for
               explored compute paradigm in the mainstream: a trustful         a basic data channel to carry a strong economic signal,
               object messaging compute framework.                             allowing a receiver to make a physical assertion without
                                                                               having to rely upon trust. Back [2002] later produced a
                                                                               system in a similar vein.
               1.1. Driving Factors. There are many goals of this                 The ﬁrst example of utilising the proof-of-work as a
               project; one key goal is to facilitate transactions be-         strong economic signal to secure a currency was by Vish-
               tween consenting individuals who would otherwise have           numurthy et al. [2003]. In this instance, the token was
               no means to trust one another.       This may be due to         used to keep peer-to-peer ﬁle trading in check, ensuring
               geographical separation, interfacing diﬃculty, or perhaps       “consumers” be able to make micro-payments to “suppli-
               theincompatibility, incompetence, unwillingness, expense,       ers” for their services.  The security model aﬀorded by
               uncertainty, inconvenience or corruption of existing legal      the proof-of-work was augmented with digital signatures
               systems. By specifying a state-change system through a          and a ledger in order to ensure that the historical record
               rich and unambiguous language, and furthermore archi-           couldn’t be corrupted and that malicious actors could not
               tecting a system such that we can reasonably expect that        spoof payment or unjustly complain about service deliv-
               an agreement will be thus enforced autonomously, we can         ery.  Five years later, Nakamoto [2008] introduced an-
               provide a means to this end.                                    other such proof-of-work-secured value token, somewhat
                  Dealings in this proposed system would have several          wider in scope. The fruits of this project, Bitcoin, became
               attributes not often found in the real world. The incor-        the ﬁrst widely adopted global decentralised transaction
               ruptibility of judgement, often diﬃcult to ﬁnd, comes nat-      ledger.
               urally from a disinterested algorithmic interpreter. Trans-        Other projects built on Bitcoin’s success; the alt-coins
               parency, or being able to see exactly how a state or judge-     introduced numerous other currencies through alteration
               ment came about through the transaction log and rules           to the protocol. Some of the best known are Litecoin and
               or instructional codes, never happens perfectly in human-       Primecoin, discussed by Sprankel [2013]. Other projects
               based systems since natural language is necessarily vague,      sought to take the core value content mechanism of the
                                                                            1
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                           EIP-150 REVISION           2
                protocol and repurpose it; Aron [2012] discusses, for ex-         identiﬁer for the ﬁnal state (though do not store the ﬁnal
                ample, the Namecoin project which aims to provide a de-           state itself—that would be far too big). They also punc-
                centralised name-resolution system.                               tuate the transaction series with incentives for nodes to
                   Other projects still aim to build upon the Bitcoin net-        mine. Thisincentivisation takes place as a state-transition
                work itself, leveraging the large amount of value placed in       function, adding value to a nominated account.
                the system and the vast amount of computation that goes              Mining is the process of dedicating eﬀort (working) to
                into the consensus mechanism. The Mastercoin project,             bolster one series of transactions (a block) over any other
                ﬁrst proposed by Willett [2013], aims to build a richer           potential competitor block.     It is achieved thanks to a
                protocol involving many additional high-level features on         cryptographically secure proof. This scheme is known as
                top of the Bitcoin protocol through utilisation of a num-         a proof-of-work and is discussed in detail in section 11.5.
                ber of auxiliary parts to the core protocol. The Coloured            Formally, we expand to:
                Coins project, proposed by Rosenfeld [2012], takes a sim-         (2)           σ      ≡ Π(σ ,B)
                ilar but more simpliﬁed strategy, embellishing the rules                         t+1             t
                                                                                  (3)              B ≡ (...,(T ,T ,...))
                of a transaction in order to break the fungibility of Bit-                                        0   1
                coin’s base currency and allow the creation and tracking of       (4)       Π(σ,B) ≡ Ω(B,Υ(Υ(σ,T0),T1)...)
                tokens through a special “chroma-wallet”-protocol-aware              Where Ω is the block-ﬁnalisation state transition func-
                piece of software.                                                tion (a function that rewards a nominated party); B is
                   Additionalworkhasbeendoneintheareawithdiscard-                 this block, which includes a series of transactions amongst
                ing the decentralisation foundation; Ripple, discussed by         some other components; and Π is the block-level state-
                Boutellier and Heinzen [2014], has sought to create a “fed-       transition function.
                erated” system for currency exchange, eﬀectively creating            This is the basis of the blockchain paradigm, a model
                a new ﬁnancial clearing system. It has demonstrated that          that forms the backbone of not only Ethereum, but all de-
                high eﬃciency gains can be made if the decentralisation           centralised consensus-based transaction systems to date.
                premise is discarded.
                   Early work on smart contracts has been done by Szabo           2.1. Value. In order to incentivise computation within
                [1997] and Miller [1997]. Around the 1990s it became clear        the network, there needs to be an agreed method for trans-
                that algorithmic enforcement of agreements could become           mitting value. To address this issue, Ethereum has an in-
                a signiﬁcant force in human cooperation. Though no spe-           trinsic currency, Ether, known also as ETH and sometimes
                ciﬁc system was proposed to implement such a system,              referred to by the Old English D. The smallest subdenom-
                it was proposed that the future of law would be heavily                                           ¯
                aﬀected by such systems. In this light, Ethereum may              ination of Ether, and thus the one in which all integer val-
                be seen as a general implementation of such a crypto-law          ues of the currency are counted, is the Wei. One Ether is
                                                                                  deﬁned as being 1018 Wei. There exist other subdenomi-
                system.                                                           nations of Ether:
                             2. The Blockchain Paradigm                                                Multiplier   Name
                                                                                                                0
                   Ethereum, taken as a whole, can be viewed as a                                             10    Wei
                                                                                                               12
                transaction-based state machine: we begin with a gene-                                       10     Szabo
                                                                                                               15
                sis state and incrementally execute transactions to morph                                    10     Finney
                                                                                                               18
                it into some ﬁnal state. It is this ﬁnal state which we ac-                                  10     Ether
                cept as the canonical “version” of the world of Ethereum.            Throughout the present work, any reference to value,
                The state can include such information as account bal-            in the context of Ether, currency, a balance or a payment,
                ances, reputations, trust arrangements, data pertaining           should be assumed to be counted in Wei.
                to information of the physical world; in short, anything
                that can currently be represented by a computer is admis-         2.2. Which History? Since the system is decentralised
                sible. Transactions thus represent a valid arc between two        and all parties have an opportunity to create a new block
                states; the ‘valid’ part is important—there exist far more        onsomeolderpre-existing block, the resultant structure is
                invalid state changes than valid state changes.       Invalid     necessarily a tree of blocks. In order to form a consensus as
                state changes might, e.g. be things such as reducing an           to which path, from root (the genesis block) to leaf (the
                account balance without an equal and opposite increase            block containing the most recent transactions) through
                elsewhere. A valid state transition is one which comes            this tree structure, known as the blockchain, there must
                about through a transaction. Formally:                            be an agreed-upon scheme. If there is ever a disagree-
                (1)                  σ     ≡Υ(σ ,T)                               ment between nodes as to which root-to-leaf path down
                                       t+1        t                               the block tree is the ‘best’ blockchain, then a fork occurs.
                   where Υ is the Ethereum state transition function. In             This would mean that past a given point in time
                Ethereum, Υ, together with σ are considerably more pow-           (block), multiple states of the system may coexist: some
                erful then any existing comparable system; Υ allows com-          nodesbelievingoneblocktocontainthecanonicaltransac-
                ponents to carry out arbitrary computation, while σ al-           tions, other nodes believing some other block to be canoni-
                lows components to store arbitrary state between trans-           cal, potentially containing radically diﬀerent or incompat-
                actions.                                                          ible transactions. This is to be avoided at all costs as the
                   Transactions are collated into blocks;        blocks are       uncertainty that would ensue would likely kill all conﬁ-
                chained together using a cryptographic hash as a means of         dence in the entire system.
                reference. Blocks function as a journal, recording a series          The scheme we use in order to generate consensus is a
                of transactions together with the previous block and an           simpliﬁed version of the GHOST protocol introduced by
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION           3
                                                                                   ∗∗
               Sompolinsky and Zohar [2013]. This process is described            &c. On very particular occasions, in order to max-
               in detail in section 10.                                          imise readability and only if unambiguous in meaning, I
                                                                                 may use alpha-numeric subscripts to denote intermediate
                                     3. Conventions                              values, especially those of particular note.
                  I use a number of typographical conventions for the               When considering the use of existing functions, given
               formal notation, some of which are quite particular to the        a function f, the function f∗ denotes a similar, element-
               present work:                                                     wise version of the function mapping instead between se-
                  The two sets of highly structured, ‘top-level’, state val-     quences. It is formally deﬁned in section 4.4.
               ues, are denoted with bold lowercase Greek letters. They             I deﬁne a number of useful functions throughout. One
               fall into those of world-state, which are denoted σ (or a         of the more common is ℓ, which evaluates to the last item
               variant thereupon) and those of machine-state, µ.                 in the given sequence:
                  Functions operating on highly structured values are
               denoted with an upper-case greek letter, e.g. Υ, the              (5)                  ℓ(x) ≡ x[kxk−1]
               Ethereum state transition function.
                  For most functions, an uppercase letter is used, e.g.                   4. Blocks, State and Transactions
               C, the general cost function. These may be subscripted
               to denote specialised variants, e.g. CSSTORE, the cost func-         Having     introduced    the   basic   concepts    behind
               tion for the SSTORE operation. For specialised and possibly       Ethereum, we will discuss the meaning of a transaction, a
               externally deﬁned functions, I may format as typewriter           block and the state in more detail.
               text, e.g. the Keccak-256 hash function (as per the winning
               entry to the SHA-3 contest) is denoted KEC (and generally         4.1. World State. The world state (state), is a map-
               referred to as plain Keccak). Also KEC512 is referring to         ping between addresses (160-bit identiﬁers) and account
               the Keccak 512 hash function.                                     states (a data structure serialised as RLP, see Appendix
                  Tuples are typically denoted with an upper-case letter,        B). Though not stored on the blockchain, it is assumed
               e.g. T, is used to denote an Ethereum transaction. This           that the implementation will maintain this mapping in a
               symbol may, if accordingly deﬁned, be subscripted to re-          modiﬁed Merkle Patricia tree (trie, see Appendix D). The
               fer to an individual component, e.g. T , denotes the nonce        trie requires a simple database backend that maintains a
                                                       n
               of said transaction. The form of the subscript is used to         mapping of bytearrays to bytearrays; we name this under-
               denote its type; e.g. uppercase subscripts refer to tuples        lying database the state database. This has a number of
               with subscriptable components.                                    beneﬁts; ﬁrstly the root node of this structure is crypto-
                  Scalars and ﬁxed-size byte sequences (or, synony-              graphically dependent on all internal data and as such its
               mously, arrays) are denoted with a normal lower-case let-         hash can be used as a secure identity for the entire sys-
               ter, e.g. n is used in the document to denote a transaction       tem state. Secondly, being an immutable data structure,
               nonce. Those with a particularly special meaning may be           it allows any previous state (whose root hash is known) to
               greek, e.g. δ, the number of items required on the stack          be recalled by simply altering the root hash accordingly.
               for a given operation.                                            Since we store all such root hashes in the blockchain, we
                  Arbitrary-length sequences are typically denoted as a          are able to trivially revert to old states.
               bold lower-case letter, e.g. o is used to denote the byte-           The account state comprises the following four ﬁelds:
               sequence given as the output data of a message call. For                nonce: Ascalar value equal to the number of trans-
               particularly important values, a bold uppercase letter may                 actions sent from this address or, in the case
               be used.                                                                   of accounts with associated code, the number of
                  Throughout, we assume scalars are positive integers                     contract-creations made by this account. For ac-
               and thus belong to the set P. The set of all byte sequences                count of address a in state σ, this would be for-
               is B, formally deﬁned in Appendix B. If such a set of se-                  mally denoted σ[a] .
                                                                                                              n
               quences is restricted to those of a particular length, it is            balance: A scalar value equal to the number of Wei
               denoted with a subscript, thus the set of all byte sequences               owned by this address. Formally denoted σ[a] .
                                                                                                                                           b
               of length 32 is named B      and the set of all positive in-            storageRoot: A 256-bit hash of the root node of a
                                         32
               tegers smaller than 2256 is named P       . This is formally               Merkle Patricia tree that encodes the storage con-
                                                      256
               deﬁned in section 4.4.                                                     tents of the account (a mapping between 256-bit
                  Square brackets are used to index into and reference                    integer values), encoded into the trie as a map-
               individual components or subsequences of sequences, e.g.                   ping from the Keccak 256-bit hash of the 256-bit
               µs[0] denotes the ﬁrst item on the machine’s stack. For                    integer keys to the RLP-encoded 256-bit integer
               subsequences, ellipses are used to specify the intended                    values. The hash is formally denoted σ[a]s.
               range, to include elements at both limits, e.g. µ [0..31]               codeHash: The hash of the EVM code of this
                                                                    m
               denotes the ﬁrst 32 items of the machine’s memory.                         account—this is the code that gets executed
                  In the case of the global state σ, which is a sequence of               should this address receive a message call; it is
               accounts, themselves tuples, the square brackets are used                  immutable and thus, unlike all other ﬁelds, can-
               to reference an individual account.                                        not be changed after construction. All such code
                  When considering variants of existing values, I follow                  fragments are contained in the state database un-
               the rule that within a given scope for deﬁnition, if we                    der their corresponding hashes for later retrieval.
               assume that the unmodiﬁed ‘input’ value be denoted by                      This hash is formally denoted σ[a] , and thus the
                                                                                                                              c
               the placeholder  then the modiﬁed and utilisable value                    code may be denoted as b, given that KEC(b) =
                                ′                                         ∗
               is denoted as  , and intermediate values would be  ,                     σ[a] .
                                                                                              c
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                             EIP-150 REVISION           4
                   Since I typically wish to refer not to the trie’s root hash            gasLimit: A scalar value equal to the maximum
                but to the underlying set of key/value pairs stored within,                  amount of gas that should be used in executing
                I deﬁne a convenient equivalence:                                            this transaction. This is paid up-front, before any
                                         ∗                                                  computation is done and may not be increased
                (6)               TRIE L (σ[a] ) ≡ σ[a]
                                         I      s          s                                 later; formally T .
                                                                                                               g
                   The collapse function for the set of key/value pairs in                to: The 160-bit address of the message call’s recipi-
                           ∗                                                                 ent or, for a contract creation transaction, ∅, used
                the trie, L , is deﬁned as the element-wise transformation
                           I
                of the base function L , given as:                                           here to denote the only member of B ; formally
                                        I                                                                                             0
                                                                                           T .
                (7)             L (k,v) ≡ KEC(k),RLP(v)                                       t
                                 I                                                        value: A scalar value equal to the number of Wei to
                   where:                                                                    be transferred to the message call’s recipient or,
                (8)                 k ∈ B      ∧ v∈P                                         in the case of contract creation, as an endowment
                                          32                                                 to the newly created account; formally T .
                                                                                                                                         v
                   It shall be understood that σ[a] is not a ‘physical’                   v, r, s: Values corresponding to the signature of the
                                                        s
                memberoftheaccountanddoesnotcontributetoitslater                             transaction and used to determine the sender of
                                                                                             the transaction; formally T , T and T . This is
                serialisation.                                                                                            w    r        s
                   If the codeHash ﬁeld is the Keccak-256 hash of the                        expanded in Appendix F.
                                                   
                empty string, i.e. σ[a]c = KEC () , then the node repre-               Additionally, a contract creation transaction contains:
                sents a simple account, sometimes referred to as a “non-                  init: An unlimited size byte array specifying the
                contract” account.                                                           EVM-code for the account initialisation proce-
                   Thuswemaydeﬁneaworld-statecollapse function L :
                                                                            S                dure, formally T .
                                                                                                              i
                (9)              L (σ) ≡ {p(a) : σ[a] 6= ∅}
                                  S                                                    init is an EVM-code fragment; it returns the body,
                where                                                               a second fragment of code that executes each time the
                                                                                  account receives a message call (either through a trans-
                (10)    p(a) ≡ KEC(a),RLP (σ[a] ,σ[a] ,σ[a] ,σ[a] )
                                                  n      b      s      c            action or due to the internal execution of code). init is
                   This function, L , is used alongside the trie function           executed only once at account creation and gets discarded
                                     S                                              immediately thereafter.
                to provide a short identity (hash) of the world state. We
                assume:                                                                In contrast, a message call transaction contains:
                (11)       ∀a : σ[a] = ∅ ∨ (a ∈ B       ∧ v(σ[a]))                        data: An unlimited size byte array specifying the
                                                    20                                       input data of the message call, formally T .
                                                                                                                                          d
                where v is the account validity function:                              Appendix F speciﬁes the function, S, which maps
                (12)     v(x) ≡ x ∈ P       ∧x ∈P ∧x ∈B ∧x ∈B                       transactions to the sender, and happens through the
                                   n     256   b     256   s     32    c    32      ECDSA of the SECP-256k1 curve, using the hash of the
                4.2. Homestead. A signiﬁcant block number for com-                  transaction (excepting the latter three signature ﬁelds) as
                patibility with the public network is the block marking the         the datum to sign. For the present we simply assert that
                transition between the Frontier and Homestead phases of             the sender of a given transaction T can be represented
                the platform, which we denote with the symbol NH, de-               with S(T).
                ﬁned thus
                                                                                    (14)       (
                (13)                  NH ≡1,150,000                                              (T ,T ,T ,T ,T ,T ,T ,T ,T )          if T = ∅
                                                                                     L (T)≡         n   p  g   t  v   i   w r s           t
                The protocol was upgraded at this block, so this symbol               T          (T ,T ,T ,T ,T ,T ,T ,T ,T ) otherwise
                                                                                                    n   p  g   t  v   d   w r s
                appears in some equations to account for the changes.
                                                                                       Here, we assume all components are interpreted by the
                4.3. The Transaction. A transaction (formally, T) is a              RLPasinteger values, with the exception of the arbitrary
                single cryptographically-signed instruction constructed by          length byte arrays T and T .
                                                                                                          i       d
                an actor externally to the scope of Ethereum. While is as-          (15)    T ∈P          ∧ T ∈P           ∧ T ∈P           ∧
                sumed that the ultimate external actor will be human in                       n     256        v     256         p    256
                                                                                            T ∈P          ∧ T ∈P           ∧ T ∈P           ∧
                nature, software tools will be used in its construction and                   g     256        w      5          r    256
                                                                                            T ∈P          ∧ T ∈B           ∧ T ∈B
                               1                                                              s     256        d                 i
                dissemination . There are two types of transactions: those
                which result in message calls and those which result in             where
                the creation of new accounts with associated code (known            (16)            P ={P :P ∈P∧P <2n}
                informally as ‘contract creation’). Both types specify a                              n
                number of common ﬁelds:                                                The address hash T is slightly diﬀerent: it is either a
                                                                                                            t
                      nonce: Ascalar value equal to the number of trans-            20-byte address hash or, in the case of being a contract-
                         actions sent by the sender; formally T .                   creation transaction (and thus formally equal to ∅), it is
                                                                  n
                      gasPrice: A scalar value equal to the number of               the RLP empty byte-series and thus the member of B :
                                                                                                                                              0
                         Wei to be paid per unit of gas for all computa-                                    (B      if  T 6= ∅
                         tion costs incurred as a result of the execution of        (17)              T ∈      20        t
                         this transaction; formally T .                                                 t     B     otherwise
                                                       p                                                       0
                   1
                    Notably, such ‘tools’ could ultimately become so causally removed from their human-based initiation—or humans may become so
                causally-neutral—that there could be a point at which they rightly be considered autonomous agents. e.g. contracts may oﬀer bounties to
                humans for being sent transactions to initiate their execution.
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION           5
               4.4. The Block. The block in Ethereum is the collec-              a block B:
               tion of relevant pieces of information (known as the block
                                                                                 (18)                B≡(B ,B ,B )
               header), H, together with information corresponding to                                        H    T    U
               the comprised transactions, T, and a set of other block
               headers U that are known to have a parent equal to the            4.4.1. Transaction Receipt. In order to encode informa-
               present block’s parent’s parent (such blocks are known as         tion about a transaction concerning which it may be use-
                        2                                                        ful to form a zero-knowledge proof, or index and search,
               ommers ). The block header contains several pieces of
               information:                                                      we encode a receipt of each transaction containing cer-
                                                                                 tain information from concerning its execution. Each re-
                                                                                 ceipt, denoted B [i] for the ith transaction) is placed in
                     parentHash: The Keccak 256-bit hash of the par-                               R
                        ent block’s header, in its entirety; formally H .        an index-keyed trie and the root recorded in the header as
                                                                        p        H .
                     ommersHash: TheKeccak256-bithashoftheom-                      e
                        mers list portion of this block; formally H .               The transaction receipt is a tuple of four items com-
                                                                     o           prising the post-transaction state, R , the cumulative gas
                     beneﬁciary: The 160-bit address to which all fees                                                 σ
                        collected from the successful mining of this block       used in the block containing the transaction receipt as of
                        be transferred; formally H .                             immediately after the transaction has happened, Ru, the
                                                    c                            set of logs created through execution of the transaction, R
                     stateRoot: The Keccak 256-bit hash of the root                                                                          l
                        node of the state trie, after all transactions are       and the Bloom ﬁlter composed from information in those
                        executed and ﬁnalisations applied; formally H .          logs, Rb:
                                                                         r
                     transactionsRoot: TheKeccak256-bithashofthe                 (19)               R≡(R ,R ,R ,R)
                        root node of the trie structure populated with                                      σ    u   b   l
                        each transaction in the transactions list portion           ThefunctionLR trivially prepares a transaction receipt
                        of the block; formally Ht.                               for being transformed into an RLP-serialised byte array:
                     receiptsRoot: TheKeccak256-bithashoftheroot
                        node of the trie structure populated with the re-        (20)       LR(R)≡(TRIE(LS(Rσ)),Ru,Rb,Rl)
                        ceipts of each transaction in the transactions list      thus the post-transaction state, R    is encoded into a trie
                        portion of the block; formally H .                                                           σ
                                                          e                      structure, the root of which forms the ﬁrst item.
                     logsBloom: The Bloom ﬁlter composed from in-                   Weassert R , the cumulative gas used is a positive in-
                        dexable information (logger address and log top-                         u
                        ics) contained in each log entry from the receipt of     teger and that the logs Bloom, Rb, is a hash of size 2048
                        each transaction in the transactions list; formally      bits (256 bytes):
                        Hb.                                                      (21)              R ∈P ∧ R ∈B
                                                                                                     u              b    256
                     diﬃculty: A scalar value corresponding to the dif-
                        ﬁculty level of this block. This can be calculated          The log entries, Rl, is a series of log entries, termed,
                                                                                 for example, (O ,O ,...). A log entry, O, is a tuple of a
                        from the previous block’s diﬃculty level and the                          0   1
                                                                                 logger’s address, O , a series of 32-bytes log topics, O
                        timestamp; formally H .                                                       a                                      t
                                                d
                                                                                 and some number of bytes of data, O :
                     number: A scalar value equal to the number of an-                                                   d
                        cestor blocks. The genesis block has a number of         (22)            O≡(O ,(O ,O ,...),O )
                        zero; formally H .                                                               a    t0   t1       d
                                         i
                     gasLimit: A scalar value equal to the current limit
                        of gas expenditure per block; formally H .               (23)     O ∈B        ∧ ∀        : t ∈ B     ∧ O ∈B
                                                                   l                        a    20         t∈O         32          d
                                                                                                                t
                     gasUsed: A scalar value equal to the total gas used
                        in transactions in this block; formally H .                 WedeﬁnetheBloomﬁlterfunction, M, to reduce a log
                                                                   g             entry into a single 256-byte hash:
                     timestamp: A scalar value equal to the reasonable
                        output of Unix’s time() at this block’s inception;                                  _                  
                                                                                 (24)          M(O)≡                M       (t)
                        formally H .                                                                                   3:2048
                                    s                                                                   t∈{O }∪O
                     extraData: An arbitrary byte array containing                                           a    t
                        data relevant to this block. This must be 32 bytes          where M3:2048 is a specialised Bloom ﬁlter that sets
                        or fewer; formally H .                                   three bits out of 2048, given an arbitrary byte series. It
                                              x
                     mixHash: A 256-bit hash which proves combined               does this through taking the low-order 11 bits of each of
                        with the nonce that a suﬃcient amount of compu-          the ﬁrst three pairs of bytes in a Keccak-256 hash of the
                        tation has been carried out on this block; formally      byte series. Formally:
                        Hm.
                                                                                 (25)M       (x : x ∈ B)   ≡ y:y∈B            where:
                     nonce: A 64-bit hash which proves combined with                    3:2048                           256
                        the mix-hash that a suﬃcient amount of compu-            (26)                  y = (0,0,...,0) except:
                        tation has been carried out on this block; formally      (27)          ∀            :   B      (y) = 1
                        Hn.                                                                     i∈{0,2,4}        m(x,i)
                                                                                 (28)            m(x,i)    ≡ KEC(x)[i,i+1] mod 2048
                  The other two components in the block are simply a                where B is the bit reference function such that Bj(x)
               list of ommer block headers (of the same format as above)         equals the bit of index j (indexed from 0) in the byte array
               and a series of the transactions. Formally, we can refer to       x.
                  2
                   ommer is the most prevalent (not saying much) gender-neutral term to mean “sibling of parent”; see http://nonbinary.org/wiki/
               Gender_neutral_language#Family_Terms
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                           EIP-150 REVISION           6
                4.4.2. Holistic Validity. We can assert a block’s validity if     4.4.4. Block Header Validity. We deﬁne P(B ) to be the
                                                                                                                                  H
                and only if it satisﬁes several conditions: it must be in-        parent block of B, formally:
                ternally consistent with the ommer and transaction block          (37)         P(H)≡B′:KEC(RLP(B′ ))=H
                hashes and the given transactions B      (as speciﬁed in sec                                            H        p
                                                      T
                11), when executed in order on the base state σ (derived             The block number is the parent’s block number incre-
                from the ﬁnal state of the parent block), result in a new         mented by one:
                state of the identity Hr:                                         (38)                 H ≡P(H) +1
                (29)                                                                                     i         Hi
                 H ≡ TRIE(L (Π(σ,B)))                                      ∧         The canonical diﬃculty of a block of header H is de-
                   r               S
                                      ∗                                           ﬁned as D(H):
                 H ≡ KEC(RLP(L (B )))                                      ∧
                   o                  H U
                 H ≡ TRIE({∀i<kB k,i∈P:p(i,L (B [i]))}) ∧                         (39)
                   t                       T                T   T                           
                                                                                              D                                   if  H =0
                 H ≡ TRIE({∀i<kB k,i∈P:p(i,L (B [i]))}) ∧                                    0                                         i
                   e       W              R                R   R                                                            
                 H ≡                r                                                         max D ,P(H)        +x×ς +ǫ if H <N
                   b         r∈B     b                                            D(H)≡               0       Hd         1              i     H
                                 R                                                                                           
                                                                                            
                                                                                              max D ,P(H)        +x×ς +ǫ otherwise
                   where p(k,v) is simply the pairwise RLP transforma-                                0       Hd         2
                tion, in this case, the ﬁrst being the index of the trans-        where:
                action in the block and the second being the transaction          (40)                    D ≡131072
                receipt:                                                                                    0
                                                                                                            P(H)Hd
                (30)             p(k,v) ≡ RLP(k),RLP(v)                           (41)                  x≡       2048
                   Furthermore:                                                                    (
                                                                                                     1     if  H <P(H) +13
                (31)             TRIE(L (σ)) = P(B )                              (42)        ς ≡                s         Hs
                                        S             H Hr                                     1     −1 otherwise
                   Thus TRIE(L (σ)) is the root node hash of the Merkle
                                S                                                                                                
                                                                                                              H −P(H)
                Patricia tree structure containing the key-value pairs of         (43)      ς ≡max 1−           s         Hs ,−99
                the state σ with values encoded using RLP, and P(B )                         2                      10
                                                                          H
                is the parent block of B, deﬁned directly.                                                j                k
                                                                                                            ⌊H ÷100000⌋−2
                   Thevalues stemming from the computation of transac-            (44)                ǫ ≡ 2 i
                tions, speciﬁcally the transaction receipts, B , and that
                                                                R
                                                                                     Thecanonical gas limit H of a block of header H must
                deﬁned through the transactions state-accumulation func-                                         l
                tion, Π, are formalised later in section 11.4.                    fulﬁl the relation:                        
                                                                                  (45)            H <P(H) + P(H)Hl                 ∧
                                                                                                    l         Hl       1024
                4.4.3. Serialisation. The function L      and L      are the
                                                       B         H                                                           
                preparation functions for a block and block header respec-        (46)            H >P(H) − P(H)Hl                 ∧
                tively. Much like the transaction receipt preparation func-                         l         Hl       1024
                tion L , we assert the types and order of the structure for
                      R                                                           (47)            H >125000
                when the RLP transformation is required:                                            l
                                                                                     Hs is the timestamp of block H and must fulﬁl the
                (32) L (H) ≡ ( H ,H ,H ,H ,H ,H ,H ,H ,                           relation:
                       H                 p   o   c   r    t   e   b   d
                                       H,H,H ,H ,H ,H ,H )
                                         i   l   g   s   x   m n                  (48)                   H >P(H)
                                                  ∗        ∗                                              s          Hs
                (33)  L (B) ≡         L (B ),L (B ),L (B )
                        B              H H T T H U                                   This mechanism enforces a homeostasis in terms of the
                           ∗        ∗                                             timebetweenblocks; asmallerperiodbetweenthelasttwo
                   With L and L being element-wise sequence trans-
                           T        H
                formations, thus:                                                 blocks results in an increase in the diﬃculty level and thus
                (34)                                                              additional computation required, lengthening the likely
                  ∗                                                             next period. Conversely, if the period is too large, the
                 f  (x ,x ,...) ≡ f(x ),f(x ),...       for any function f
                       0  1              0      1
                                                                                  diﬃculty, and expected time to the next block, is reduced.
                   The component types are deﬁned thus:                              The nonce, H , must satisfy the relations:
                                                                                                    n
                                                                                                          256
                (35)   H ∈B          ∧ H ∈B           ∧ H ∈B            ∧                                2
                         p     32          o     32          c    20              (49)              n6          ∧ m=H
                       H ∈B          ∧ H ∈B           ∧ H ∈B            ∧                                H                  m
                         r     32          t     32          e    32                                       d
                       H ∈B          ∧ H ∈P           ∧ H ∈P            ∧
                         b     256         d                 i                    with (n,m) = PoW(Hn,Hn,d).
                       H ∈P          ∧ H ∈P           ∧ H ∈P            ∧
                         l                 g                 s    256                Where Hn is the new block’s header H, but without
                       H ∈B          ∧ H ∈B           ∧ H ∈B
                         x                 m     32          n    8               the nonce and mix-hash components, d being the current
                   where                                                          DAG, a large data set needed to compute the mix-hash,
                                                                                  and PoW is the proof-of-work function (see section 11.5):
                (36)           Bn ={B : B ∈ B∧kBk=n}                              this evaluates to an array with the ﬁrst item being the mix-
                                                                                  hash, to proof that a correct DAG has been used, and the
                   Wenowhave a rigorous speciﬁcation for the construc-            second item being a pseudo-random number cryptograph-
                tion of a formal block structure. The RLP function RLP            ically dependent on H and d. Given an approximately
                                                                                                                             64
                (see Appendix B) provides the canonical method for trans-         uniform distribution in the range [0,2 ), the expected
                forming this structure into a sequence of bytes ready for         time to ﬁnd a solution is proportional to the diﬃculty,
                transmission over the wire or storage locally.                    H .
                                                                                    d
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                            EIP-150 REVISION           7
                   This is the foundation of the security of the blockchain        they will execute transactions and transactors will be free
                and is the fundamental reason why a malicious node can-            to canvas these prices in determining what gas price to
                not propagate newly created blocks that would otherwise            oﬀer. Since there will be a (weighted) distribution of min-
                overwrite (“rewrite”) history.     Because the nonce must          imum acceptable gas prices, transactors will necessarily
                satisfy this requirement, and because its satisfaction de-         have a trade-oﬀ to make between lowering the gas price
                pends on the contents of the block and in turn its com-            and maximising the chance that their transaction will be
                posed transactions, creating new, valid, blocks is diﬃcult         mined in a timely manner.
                and, over time, requires approximately the total compute
                power of the trustworthy portion of the mining peers.                             6. Transaction Execution
                   Thus we are able to deﬁne the block header validity                Theexecutionofatransactionisthemostcomplexpart
                function V(H):                                                     of the Ethereum protocol: it deﬁnes the state transition
                                          256                                      function Υ. It is assumed that any transactions executed
                (50)  V(H) ≡ n6 2             ∧m=H           ∧
                                         H              m                          ﬁrst pass the initial tests of intrinsic validity. These in-
                                           d
                (51)                Hd =D(H) ∧                                     clude:
                (52)                Hg ≤H       ∧                                       (1) The transaction is well-formed RLP, with no ad-
                                            l                   
                                                       P(H)                                 ditional trailing bytes;
                (53)                H <P(H) +                 Hl     ∧                  (2) the transaction signature is valid;
                                      l         Hl       1024
                                                                                      (3) the transaction nonce is valid (equivalent to the
                                                       P(H)
                (54)                H >P(H) −                 Hl     ∧                      sender account’s current nonce);
                                      l         Hl       1024                           (4) the gas limit is no smaller than the intrinsic gas,
                (55)                H >125000       ∧                                       g , used by the transaction;
                                      l                                                      0
                (56)                H >P(H)           ∧                                 (5) the sender account balance contains at least the
                                      s         Hs                                          cost, v , required in up-front payment.
                (57)                H =P(H) +1 ∧                                                   0
                                      i         Hi                                    Formally, we consider the function Υ, with T being a
                (58)                kH k≤32
                                       x                                           transaction and σ the state:
                where (n,m) = PoW(Hn,Hn,d)                                         (59)                    σ′ = Υ(σ,T)
                   Noting additionally that extraData must be at most                         ′
                32 bytes.                                                             Thus σ is the post-transactional state. We also deﬁne
                                                                                   Υg to evaluate to the amount of gas used in the execution
                                                                                                             l
                                   5. Gas and Payment                              of a transaction and Υ to evaluate to the transaction’s
                                                                                   accrued log items, both to be formally deﬁned later.
                   In order to avoid issues of network abuse and to side-
                step the inevitable questions stemming from Turing com-            6.1. Substate. Throughout transaction execution, we
                pleteness, all programmable computation in Ethereum is             accrue certain information that is acted upon immediately
                subject to fees. The fee schedule is speciﬁed in units of          following the transaction. We call this transaction sub-
                gas (see Appendix G for the fees associated with var-              state, and represent it as A, which is a tuple:
                ious computation).      Thus any given fragment of pro-            (60)                  A≡(A ,A,A )
                                                                                                                 s   l   r
                grammable computation (this includes creating contracts,              The tuple contents include A , the suicide set: a set
                makingmessagecalls, utilising and accessing account stor-                                              s
                age and executing operations on the virtual machine) has           of accounts that will be discarded following the transac-
                                                                                   tion’s completion. A is the log series: this is a series of
                a universally agreed cost in terms of gas.                                                l
                   Every transaction has a speciﬁc amount of gas associ-           archived and indexable ‘checkpoints’ in VM code execu-
                ated with it: gasLimit. This is the amount of gas which            tion that allow for contract-calls to be easily tracked by
                is implicitly purchased from the sender’s account balance.         onlookers external to the Ethereum world (such as decen-
                                                                                   tralised application front-ends). Finally there is A , the
                The purchase happens at the according gasPrice, also                                                                       r
                speciﬁed in the transaction. The transaction is considered         refund balance, increased through using the SSTORE in-
                invalid if the account balance cannot support such a pur-          struction in order to reset contract storage to zero from
                chase. It is named gasLimit since any unused gas at the            some non-zero value. Though not immediately refunded,
                endofthetransaction is refunded (at the same rate of pur-          it is allowed to partially oﬀset the total execution costs.
                                                                                                                                       0
                chase) to the sender’s account. Gas does not exist outside            For brevity, we deﬁne the empty substate A to have
                of the execution of a transaction. Thus for accounts with          no suicides, no logs and a zero refund balance:
                trusted code associated, a relatively high gas limit may be                                 0
                set and left alone.                                                (61)                    A ≡(∅,(),0)
                   In general, Ether used to purchase gas that is not re-          6.2. Execution. We deﬁne intrinsic gas g0, the amount
                funded is delivered to the beneﬁciary address, the address         of gas this transaction requires to be paid prior to execu-
                of an account typically under the control of the miner.            tion, as follows:
                Transactors are free to specify any gasPrice that they                               X (G                     if  i = 0
                                                                                   (62)      g ≡              txdatazero
                wish, however miners are free to ignore transactions as                       0              G                otherwise
                                                                                                   i∈T ,T     txdatanonzero
                theychoose. Ahighergaspriceonatransactionwillthere-                                   i  d
                fore cost the sender more in terms of Ether and deliver a                             (
                                                                                                        G          if  T =∅∧H ≥N
                                                                                   (63)            +      txcreate       t          i     H
                greater value to the miner and thus will more likely be                                 0          otherwise
                selected for inclusion by more miners. Miners, in general,
                                                                                   (64)            +G
                will choose to advertise the minimum gas price for which                                transaction
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION           8
                   where T ,T    means the series of bytes of the trans-          from the refund counter, to the sender at the original rate.
                           i   d
               action’s associated data and initialisation EVM-code,                                            jT −g′k
                                                                                  (72)          g∗ ≡ g′ +min{      g       , A }
               depending on whether the transaction is for contract-                                                 2        r
               creation or message-call. G          is added if the transac-
                                            txcreate                                 Thetotalrefundableamountisthelegitimatelyremain-
               tion is contract-creating, but not if a result of EVM-code         ing gas g′, added to A , with the latter component being
               or before the Homestead transition. G is fully deﬁned in                                  r
               Appendix G.                                                        capped up to a maximum of half (rounded down) of the
                                                                                  total amount used T −g′.
                   The up-front cost v is calculated as:                                               g
                                       0                                             The Ether for the gas is given to the miner, whose ad-
               (65)                   v ≡T T +T
                                       0     g p     v                            dress is speciﬁed as the beneﬁciary of the present block
                   The validity is determined as:                                 B. So we deﬁne the pre-ﬁnal state σ∗ in terms of the
               (66)               S(T) 6= ∅ ∧                                     provisional state σP:
                               σ[S(T)]    6= ∅ ∧                                  (73)             σ∗ ≡ σP except
                                    T     = σ[S(T)]       ∧                       (74)      σ∗[S(T)]     ≡ σ [S(T)] +g∗T
                                      n               n                                              b         P       b       p
                                     g    6 T ∧                                                  ∗                              ∗
                                      0         g                                 (75)         σ [m]     ≡ σP[m] +(Tg−g )Tp
                                     v    6 σ[S(T)]       ∧                                          b              b
                                      0               b                           (76)              m ≡ B
                                    T     6 B −ℓ(B )                                                           Hc
                                      g         Hl       R u
                   Note the ﬁnal condition; the sum of the transaction’s             Theﬁnalstate, σ′, is reached after deleting all accounts
               gas limit, T , and the gas utilised in this block prior, given     that appear in the suicide list:
                           g
               byℓ(B ) , mustbenogreaterthantheblock’sgasLimit,                   (77)                     σ′   ≡ σ∗ except
                      R u
               BHl.                                                               (78)         ∀i ∈ A : σ′[i]   ≡ ∅
                                                                                                      s
                   The execution of a valid transaction begins with an                                          g
               irrevocable change made to the state: the nonce of the ac-            And ﬁnally, we specify Υ , the total gas used in this
                                                                                  transaction and Υl, the logs created by this transaction:
               count of the sender, S(T), is incremented by one and the
               balance is reduced by part of the up-front cost, T T . The                             g                     ′
                                                                   g p            (79)              Υ (σ,T) ≡ T −g
                                                                                                                      g
               gas available for the proceeding computation, g, is deﬁned         (80)              Υl(σ,T)     ≡ A
               as T −g . The computation, whether contract creation                                                    l
                    g    0
               or a message call, results in an eventual state (which may            These are used to help deﬁne the transaction receipt,
               legally be equivalent to the current state), the change to         discussed later.
               which is deterministic and never invalid: there can be no
               invalid transactions from this point.                                               7. Contract Creation
                   Wedeﬁne the checkpoint state σ0:                                  There are a number of intrinsic parameters used when
               (67)                 σ0    ≡ σ except:                             creating an account: sender (s), original transactor (o),
               (68)          σ [S(T)]     ≡ σ[S(T)] −T T                          available gas (g), gas price (p), endowment (v) together
                              0       b                b    g p                   with an arbitrary length byte array, i, the initialisation
               (69)         σ0[S(T)]n     ≡ σ[S(T)]n+1                            EVMcode and ﬁnally the present depth of the message-
                   Evaluating σP from σ0 depends on the transaction               call/contract-creation stack (e).
               type; either contract creation or message call; we deﬁne              We deﬁne the creation function formally as the func-
               the tuple of post-execution provisional state σP, remain-          tion Λ, which evaluates from these values, together with
               ing gas g′ and substate A:                                         the state σ to the tuple containing the new state, remain-
               (70)                                                              ing gas and accrued transaction substate (σ′,g′,A), as in
                                Λ(σ ,S(T),T ,                                     section 6:
                                   0         o
                              
                              
                                    g,T ,T ,T ,0)               if  T =∅         (81)         (σ′,g′,A) ≡ Λ(σ,s,o,g,p,v,i,e)
               (σ ,g′,A) ≡               p  v   i                      t
                  P           
                                Θ (σ ,S(T),T ,
                               3 0             o                                    The address of the new account is deﬁned as being the
                              
                                    T ,T ,g,T ,T ,T ,T ,0)      otherwise        rightmost 160 bits of the Keccak hash of the RLP encod-
                                      t   t    p   v   v  d
                   where g is the amount of gas remaining after deducting         ing of the structure containing only the sender and the
               the basic amount required to pay for the existence of the          nonce. Thus we deﬁne the resultant address for the new
               transaction:                                                       account a:                                     
                                                                                  (82)     a ≡ B        KEC RLP  (s,σ[s] −1) 
               (71)                     g ≡ T −g                                                 96..255                  n
                                              g    0
               andT istheoriginal transactor, which can diﬀer from the               where KEC is the Keccak 256-bit hash function, RLP is
                     o
               sender in the case of a message call or contract creation          the RLP encoding function, B       (X) evaluates to binary
                                                                                                                  a..b
               not directly triggered by a transaction but coming from            value containing the bits of indices in the range [a,b] of
               the execution of EVM-code.                                         the binary data X and σ[x] is the address state of x or ∅ if
                   Note we use Θ3 to denote the fact that only the ﬁrst           noneexists. Note we use one fewer than the sender’s nonce
               three components of the function’s value are taken; the            value; we assert that we have incremented the sender ac-
               ﬁnal represents the message-call’s output value (a byte            count’s nonce prior to this call, and so the value used
               array) and is unused in the context of transaction evalua-         is the sender’s nonce at the beginning of the responsible
               tion.                                                              transaction or VM operation.
                   After the message call or contract creation is processed,         The account’s nonce is initially deﬁned as zero, the
               the state is ﬁnalised by determining the amount to be re-          balance as the value passed, the storage as empty and the
               funded, g∗ from the remaining gas, g′, plus some allowance         code hash as the Keccak 256-bit hash of the empty string;
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION           9
               the sender’s balance is also reduced by the value passed.         state is allowed to persist. Thus formally, we may specify
               Thus the mutated state becomes σ∗:                                the resultant state, gas and substate as (σ′,g′,A) where:
               (83)                  σ∗ ≡σ except:
                                                                               (97)
               (84)      σ∗[a]   ≡ 0,v+v′,TRIE(∅),KEC ()                                    
                                                                                                            ∗∗
                          ∗                                                                   0         if  σ =∅
               (85)     σ [s]    ≡ σ[s] −v                                                  
                              b           b                                            g′ ≡   g∗∗       if  g∗∗ < c∧H <N
                                                                                                                       i     H
                  wherev′ is the account’s pre-existing value, in the event                  ∗∗
               it was previously in existence:                                                g   −c otherwise
                                     (                                           (98)       
                                 ′     0      if  σ[a] = ∅                                    σ                    if  σ∗∗ = ∅
               (86)            v ≡                                                          
                                                                                            
                                                                                            
                                       σ[a]   otherwise                                      ∗∗                        ∗∗
                                           b                                            ′     σ                    if  g   <c∧Hi<NH
                                                                                      σ ≡ ∗∗
                  Finally, the account is initialised through the execution                   σ     except:
                                                                                            
                                                                                            
               of the initialising EVM code i according to the execution                     σ′[a] =KEC(o) otherwise
                                                                                                      c
               model (see section 9). Code execution can eﬀect several
               events that are not internal to the execution state: the             The exception in the determination of σ′ dictates that
               account’s storage can be altered, further accounts can be         o, the resultant byte sequence from the execution of the
               created and further message calls can be made. As such,           initialisation code, speciﬁes the ﬁnal body code for the
               the code execution function Ξ evaluates to a tuple of the         newly-created account.
               resultant state σ∗∗, available gas remaining g∗∗, the ac-            NotethattheintentionfromblockNH onwards(Home-
               crued substate A and the body code of the account o.              stead) is that the result is either a successfully created new
                                                                                 contract with its endowment, or no new contract with no
                                 ∗∗   ∗∗              ∗                          transfer of value. Before Homestead, if there is not enough
               (87)            (σ ,g ,A,o)≡Ξ(σ ,g,I)                             gas to pay c, an account at the new contract’s address is
               where I contains the parameters of the execution environ-         created, along with all the initialisation side-eﬀects, and
               ment as deﬁned in section 9, that is:                             the value is transferred, but no contract code is deployed.
               (88)                     I    ≡ a
                                         a                                       7.1. Subtleties. Note that while the initialisation code
               (89)                     I    ≡ o
                                         o                                       is executing, the newly created address exists but with no
               (90)                     Ip   ≡ p                                 intrinsic body code. Thus any message call received by
               (91)                     I    ≡ ()                                it during this time causes no code to be executed. If the
                                         d                                       initialisation execution ends with a SUICIDE instruction,
               (92)                     I    ≡ s
                                         s                                       the matter is moot since the account will be deleted before
               (93)                     Iv   ≡ v                                 the transaction is completed. For a normal STOP code,
               (94)                     Ib   ≡ i                                 or if the code returned is otherwise empty, then the state
               (95)                     I    ≡ e                                 is left with a zombie account, and any remaining balance
                                         e                                       will be locked into the account forever.
                  I   evaluates to the empty tuple as there is no input
                    d
               data to this call. I   has no special treatment and is de-
                                    H                                                                 8. Message Call
               termined from the blockchain.
                  Codeexecution depletes gas, and gas may not go below              In the case of executing a message call, several param-
               zero, thus execution may exit before the code has come to         eters are required: sender (s), transaction originator (o),
               a natural halting state. In this (and several other) excep-       recipient (r), the account whose code is to be executed (c,
               tional cases we say an Out-of-Gas exception has occurred:         usually the same as recipient), available gas (g), value (v)
               The evaluated state is deﬁned as being the empty set, ∅,          and gas price (p) together with an arbitrary length byte
               and the entire create operation should have no eﬀect on           array, d, the input data of the call and ﬁnally the present
               the state, eﬀectively leaving it as it was immediately prior      depth of the message-call/contract-creation stack (e).
               to attempting the creation.                                          Aside from evaluating to a new state and transaction
                  If the initialization code completes successfully, a ﬁ-        substate, message calls also have an extra component—the
               nal contract-creation cost is paid, the code-deposit cost,        output data denoted by the byte array o. This is ignored
               c, proportional to the size of the created contract’s code:       when executing transactions, however message calls can
               (96)                c ≡ G           ×|o|                          be initiated due to VM-code execution and in this case
                                         codedeposit                             this information is used.
                  If there is not enough gas remaining to pay this, i.e.                      ′  ′
               g∗∗ < c, then we also declare an Out-of-Gas exception.            (99)      (σ ,g ,A,o) ≡ Θ(σ,s,o,r,c,g,p,v,v˜,d,e)
                  The gas remaining will be zero in any such exceptional         Note that we need to diﬀerentiate between the value that
               condition, i.e. if the creation was conducted as the recep-       is to be transferred, v, from the value apparent in the ex-
               tion of a transaction, then this doesn’t aﬀect payment of         ecution context, v˜, for the DELEGATECALL instruction.
               the intrinsic cost of contract creation; it is paid regardless.      We deﬁne σ , the ﬁrst transitional state as the orig-
               However, the value of the transaction is not transferred to                        1
                                                                                 inal state but with the value transferred from sender to
               the aborted contract’s address when we are Out-of-Gas.            recipient:
                  If such an exception does not occur, then the remain-
               ing gas is refunded to the originator and the now-altered         (100)     σ1[r] ≡ σ[r] +v       ∧ σ1[s] ≡σ[s] −v
                                                                                                 b       b                 b        b
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION          10
                  Throughout the present work, it is assumed that if             a parameter, gas, which limits the total amount of com-
               σ1[r] was originally undeﬁned, it will be created as an ac-       putation done.
               count with no code or state and zero balance and nonce.
               Thus the previous equation should be taken to mean:               9.1. Basics. The EVM is a simple stack-based architec-
               (101)                σ1 ≡σ′      except:                          ture. The word size of the machine (and thus size of stack
                                            1                                    item) is 256-bit. This was chosen to facilitate the Keccak-
               (102)                σ1[s] ≡ σ′[s] −v                             256 hash scheme and elliptic-curve computations. The
                                         b     1  b
                                                                                 memorymodelisasimpleword-addressedbytearray. The
               (103)              and σ′ ≡σ except:                              stack has a maximum size of 1024. The machine also has
                                          1
                       (                                                         an independent storage model; this is similar in concept
                         σ′[r] ≡ (v,0,KEC(()),TRIE(∅))      if  σ[r] = ∅
               (104)       1                                                     to the memory but rather than a byte array, it is a word-
                         σ′[r] ≡ σ[r] +v                    otherwise            addressable word array. Unlike memory, which is volatile,
                           1   b       b
                  The account’s associated code (identiﬁed as the frag-          storage is non volatile and is maintained as part of the
               mentwhoseKeccakhashisσ[c] )isexecuted according to                system state. All locations in both storage and memory
                                                c                                are well-deﬁned initially as zero.
               the execution model (see section 9). Just as with contract           The machine does not follow the standard von Neu-
               creation, if the execution halts in an exceptional fashion        mann architecture. Rather than storing program code in
               (i.e. due to an exhausted gas supply, stack underﬂow, in-         generally-accessible memory or storage, it is stored sepa-
               valid jump destination or invalid instruction), then no gas       rately in a virtual ROM interactable only through a spe-
               is refunded to the caller and the state is reverted to the        cialised instruction.
               point immediately prior to balance transfer (i.e. σ).                The machine can have exceptional execution for sev-
                                        (                                        eral reasons, including stack underﬂows and invalid in-
               (105)           σ′   ≡     σ     if  σ∗∗ = ∅                      structions.  Like the out-of-gas (OOG) exception, they
                                          σ∗∗   otherwise                        do not leave state changes intact. Rather, the machine
                                                                                halts immediately and reports the issue to the execution
                                        
                                          ΞECREC(σ1,g,I)     if  r = 1
                                                                                agent (either the transaction processor or, recursively, the
                                        
                                        
                                        
                                        
                                          ΞSHA256(σ1,g,I)    if  r = 2           spawning execution environment) which will deal with it
               (106)(σ∗∗,g′,s,o)    ≡                                           separately.
                                          ΞRIP160(σ1,g,I)    if  r = 3
                                        
                                        
                                        
                                          Ξ (σ ,g,I)         if  r = 4
                                         ID    1
                                        
                                        
                                                                                9.2. Fees Overview. Fees (denominated in gas) are
                                          Ξ(σ1,g,I)          otherwise
                                                                                 charged under three distinct circumstances, all three as
               (107)           I    ≡ r
                                a                                                prerequisite to the execution of an operation. The ﬁrst
               (108)           Io   ≡ o                                          and most common is the fee intrinsic to the computation
               (109)           Ip   ≡ p                                          of the operation (see Appendix G). Secondly, gas may
               (110)           I    ≡ d                                          be deducted in order to form the payment for a subor-
                                d                                                dinate message call or contract creation; this forms part
               (111)           I    ≡ s
                                s                                                of the payment for CREATE, CALL and CALLCODE. Fi-
               (112)           Iv   ≡ v˜                                         nally, gas may be paid due to an increase in the usage of
               (113)           I    ≡ e                                          the memory.
                                e
               (114)Let KEC(I )     = σ[c]                                          Over an account’s execution, the total fee for memory-
                               b            c                                    usage payable is proportional to smallest multiple of 32
                  It is assumed that the client will have stored the pair        bytes that are required such that all memory indices
               (KEC(I ),I ) at some point prior in order to make the de-
                      b   b                                                      (whether for read or write) are included in the range. This
               termination of I   feasible.
                                b                                                is paid for on a just-in-time basis; as such, referencing an
                  As can be seen, there are four exceptions to the usage         area of memory at least 32 bytes greater than any previ-
               of the general execution framework Ξ for evaluation of the        ously indexed memorywillcertainlyresultinanadditional
               message call: these are four so-called ‘precompiled’ con-         memory usage fee. Due to this fee it is highly unlikely
               tracts, meant as a preliminary piece of architecture that         addresses will ever go above 32-bit bounds. That said,
               may later become native extensions. The four contracts            implementations must be able to manage this eventuality.
               in addresses 1, 2, 3 and 4 execute the elliptic curve public         Storage fees have a slightly nuanced behaviour—to in-
               key recovery function, the SHA2 256-bit hash scheme, the          centivise minimisation of the use of storage (which corre-
               RIPEMD 160-bit hash scheme and the identity function              sponds directly to a larger state database on all nodes),
               respectively.                                                     the execution fee for an operation that clears an entry in
                  Their full formal deﬁnition is in Appendix E.                  the storage is not only waived, a qualiﬁed refund is given;
                                                                                 in fact, this refund is eﬀectively paid up-front since the
                                  9. Execution Model                             initial usage of a storage location costs substantially more
                  The execution model speciﬁes how the system state is           than normal usage.
               altered given a series of bytecode instructions and a small          See Appendix H for a rigorous deﬁnition of the EVM
               tuple of environmental data. This is speciﬁed through a           gas cost.
               formal model of a virtual state machine, known as the
               Ethereum Virtual Machine (EVM). It is a quasi-Turing-             9.3. Execution Environment. In addition to the sys-
               complete machine; the quasi qualiﬁcation comes from the           tem state σ, and the remaining gas for computation g,
               fact that the computation is intrinsically bounded through        there are several pieces of important information used in
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                            EIP-150 REVISION          11
                the execution environment that the execution agent must               Note that we must drop the fourth value in the tuple
                provide; these are contained in the tuple I:                       returned by X to correctly evaluate Ξ, hence the subscript
                                                                                   X       .
                      • I , the address of the account which owns the                0,1,2,4
                          a
                         code that is executing.                                      Xisthuscycled(recursively here, but implementations
                      • I , the sender address of the transaction that orig-       are generally expected to use a simple iterative loop) until
                          o
                         inated this execution.                                    either Z becomes true indicating that the present state is
                      • I , the price of gas in the transaction that origi-        exceptional and that the machine must be halted and any
                          p
                         nated this execution.                                     changes discarded or until H becomes a series (rather than
                      • I , the byte array that is the input data to this          the empty set) indicating that the machine has reached a
                          d
                         execution; if the execution agent is a transaction,       controlled halt.
                         this would be the transaction data.
                      • I , the address of the account which caused the            9.4.1. Machine State. The machine state µ is deﬁned as
                          s
                         code to be executing; if the execution agent is a         the tuple (g,pc,m,i,s) which are the gas available, the
                         transaction, this would be the transaction sender.        program counter pc ∈ P256 , the memory contents, the ac-
                      • I , the value, in Wei, passed to this account as           tive number of words in memory (counting continuously
                          v
                         part of the same procedure as execution; if the           from position 0), and the stack contents. The memory
                         execution agent is a transaction, this would be           contents µ     are a series of zeroes of size 2256.
                                                                                               m
                         the transaction value.                                       For the ease of reading, the instruction mnemonics,
                      • I , the byte array that is the machine code to be          written in small-caps (e.g. ADD), should be interpreted
                          b
                         executed.                                                 as their numeric equivalents; the full table of instructions
                      • I , the block header of the present block.                 and their speciﬁcs is given in Appendix H.
                          H
                      • I , the depth of the present message-call or                  For the purposes of deﬁning Z, H and O, we deﬁne w
                          e
                         contract-creation (i.e. the number of CALLs or            as the current operation to be executed:
                         CREATEs being executed at present).                                           (I [µ ] if µ <kI k
                   The execution model deﬁnes the function Ξ, which can            (125)         w≡ b pc                pc      b
                compute the resultant state σ′, the remaining gas g′, the                                STOP      otherwise
                suicide list s, the log series l, the refunds r and the resul-        Wealso assume the ﬁxed amounts of δ and α, specify-
                tant output, o, given these deﬁnitions:                            ing the stack items removed and added, both subscript-
                (115)           (σ′,g′,s,l,r,o) ≡ Ξ(σ,g,I)                         able on the instruction and an instruction cost function C
                                                                                   evaluating to the full cost, in gas, of executing the given
                9.4. Execution Overview. We must now deﬁne the Ξ                   instruction.
                function. In most practical implementations this will be
                modelled as an iterative progression of the pair comprising        9.4.2. Exceptional Halting. The exceptional halting func-
                the full system state, σ and the machine state, µ. For-            tion Z is deﬁned as:
                mally, we deﬁne it recursively with a function X. This
                                                                                   (126)       Z(σ,µ,I) ≡ µ <C(σ,µ,I) ∨
                uses an iterator function O (which deﬁnes the result of a                                       g
                                                                                                              δ   =∅ ∨
                single cycle of the state machine) together with functions                                      w
                                                                                                              kµ k < δw     ∨
                Z which determines if the present state is an exceptional                                        s
                halting state of the machine and H, specifying the output                                     (w ∈ {JUMP,JUMPI} ∧
                                                                                                                 µ [0] ∈/ D(I ))   ∨
                data of the instruction if and only if the present state is a                                      s          b
                                                                                                              kµ k−δ +α >1024
                normal halting state of the machine.                                                             s      w     w
                   The empty sequence, denoted (), is not equal to the                This states that the execution is in an exceptional halt-
                empty set, denoted ∅; this is important when interpreting          ing state if there is insuﬃcient gas, if the instruction is in-
                the output of H, which evaluates to ∅ when execution is to         valid (and therefore its δ subscript is undeﬁned), if there
                continue but a series (potentially empty) when execution           are insuﬃcient stack items, if a JUMP/JUMPI destination
                should halt.                                                       is invalid or the new stack size would be larger then 1024.
                                                              0                   The astute reader will realise that this implies that no in-
                (116)     Ξ(σ,g,I)     ≡ X0,1,2,4 (σ,µ,A ,I)                       struction can, through its execution, cause an exceptional
                (117)             µ    ≡ g
                                   g                                               halt.
                (118)            µ     ≡ 0
                                   pc
                (119)            µ     ≡ (0,0,...)                                 9.4.3. Jump Destination Validity. We previously used D
                                   m
                (120)             µ    ≡ 0                                         as the function to determine the set of valid jump desti-
                                    i                                              nations given the code that is being run. We deﬁne this
                (121)             µ    ≡ ()
                                    s                                              as any position in the code occupied by a JUMPDEST in-
                (122)                                                             struction.
                                                 0                                   All such positions must be on valid instruction bound-
                                       ∅,µ,A ,I,()          if  Z(σ,µ,I)
                                                                                 aries, rather than sitting in the data portion of PUSH
                  X (σ,µ,A,I) ≡ O(σ,µ,A,I)·o                 if  o6= ∅
                                                        
                                                                                  operations and must appear within the explicitly deﬁned
                                        X O(σ,µ,A,I)         otherwise             portion of the code (rather than in the implicitly deﬁned
                   where                                                           STOP operations that trail it).
                (123)                     o ≡ H(µ,I)                                  Formally:
                (124)            (a,b,c) · d  ≡ (a,b,c,d)                          (127)                 D(c) ≡ DJ(c,0)
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION          12
                  where:                                                         arrive at the leaf. This is akin to existing schemes, such
               (128)                                                            as that employed in Bitcoin-derived protocols.
                                                                                   Since a block header includes the diﬃculty, the header
                             {}                       if  i > |c|
               D (c,i) ≡                                                        alone is enough to validate the computation done. Any
                 J           {i}∪D (c,N(i,c[i]))      if  c[i] = JUMPDEST
                                    J                                           block contributes toward the total computation or total
                           
                             DJ(c,N(i,c[i]))          otherwise                  diﬃculty of a chain.
                  where N is the next valid instruction position in the             Thus we deﬁne the total diﬃculty of block B recur-
               code, skipping the data of a PUSH instruction, if any:            sively as:
               (129)      (                                                      (141)                B ≡ B′+B
                            i +w−PUSH1+2 if w∈[PUSH1,PUSH32]                                           t         t     d
               N(i,w) ≡                                                          (142)                B′   ≡ P(B )
                            i +1                  otherwise                                                         H
                                                                                    As such given a block B, B is its total diﬃculty, B′ is
                                                                                                                t
               9.4.4. Normal Halting. The normal halting function H is           its parent block and B is its diﬃculty.
                                                                                                        d
               deﬁned:
               (130)                                                                            11. Block Finalisation
                            
                              HRETURN(µ) if w =RETURN
                 H(µ,I)≡                                                           The process of ﬁnalising a block involves four stages:
                              ()              if  w∈{STOP,SUICIDE}                   (1) Validate (or, if mining, determine) ommers;
                            
                            
                              ∅               otherwise                              (2) validate (or, if mining, determine) transactions;
                  The data-returning halt operation, RETURN, has a                   (3) apply rewards;
               special function H         , deﬁned in Appendix H.                    (4) verify (or, if mining, compute a valid) state and
                                  RETURN                                                 nonce.
               9.5. The Execution Cycle. Stack items are added or
               removed from the left-most, lower-indexed portion of the          11.1. Ommer Validation. The validation of ommer
               series; all other items remain unchanged:                         headers means nothing more than verifying that each om-
                                                         ′  ′   ′               mer header is both a valid header and satisﬁes the rela-
               (131)             O (σ,µ,A,I)       ≡ (σ,µ,A,I)                   tion of Nth-generation ommer to the present block where
               (132)                          ∆ ≡ α −δ                           N≤6. Themaximumofommerheadersistwo. Formally:
                                                         w    w
                                              ′                                                         ^
               (133)                       kµ k    ≡ kµ k+∆
                                              s           s                      (143)     kB k62           V(U) ∧ k(U,P(BH)H,6)
                                                                                               U
                                      ′     ′                                                         U∈B
               (134)    ∀x∈[αw,kµ k):µ [x] ≡ µ [x+∆]                                                      U
                                      s     s            s
                  The gas is reduced by the instruction’s gas cost and              where k denotes the “is-kin” property:
               for most instructions, the program counter increments on          (144)            
                                                                                                  
               each cycle, for the three exceptions, we assume a function                           false                      if  n=0
               J, subscripted by one of two instructions, which evaluates           k(U,H,n) ≡ 
                                                                                                    s(U,H)
                                                                                                  
               to the according value:                                                             ∨k(U,P(H) ,n−1) otherwise
                                                                                                                   H
               (135)      µ′    ≡ µ −C(σ,µ,I)
                            g         g                                             and s denotes the “is-sibling” property:
                                                                                (145)
                                    
                                      JJUMP(µ)      if w=JUMP
               (136)     µ′     ≡                                                 s(U,H) ≡ (P(H) = P(U) ∧ H 6= U ∧ U ∈/ B(H)U)
                           pc         JJUMPI(µ) if w =JUMPI
                                    
                                                                                where B(H) is the block of the corresponding header H.
                                      N(µ ,w) otherwise
                                           pc
                  In general, we assume the memory, suicide list and sys-        11.2. Transaction Validation. The given gasUsed
               tem state don’t change:                                           mustcorrespondfaithfullytothetransactionslisted: B         ,
                                                                                                                                         Hg
                                        ′                                        the total gas used in the block, must be equal to the ac-
               (137)                  µ     ≡ µ
                                        m          m                             cumulated gas used according to the ﬁnal transaction:
                                         ′
               (138)                   µ    ≡ µ
                                         i         i
                                         ′                                       (146)                  B =ℓ(R)
               (139)                   A ≡ A                                                             Hg          u
               (140)                   σ′   ≡ σ                                  11.3. Reward Application. The application of rewards
                  However, instructions do typically alter one or several        to a block involves raising the balance of the accounts of
               components of these values. Altered components listed by          the beneﬁciary address of the block and each ommer by a
               instruction are noted in Appendix H, alongside values for         certain amount. We raise the block’s beneﬁciary account
               αandδ and a formal description of the gas requirements.           by Rb; for each ommer, we raise the block’s beneﬁciary by
                                                                                 anadditional 1 of the block reward and the beneﬁciary of
                                                                                               32
                            10. Blocktree to Blockchain                          the ommer gets rewarded depending on the block number.
                                                                                 Formally we deﬁne the function Ω:
                  The canonical blockchain is a path from root to leaf           (147) Ω(B,σ)     ≡ σ′:σ′=σ except:
               through the entire block tree. In order to have consensus
                                                                                                                        kB k
               over which path it is, conceptually we identify the path          (148)σ′[B    ]   = σ[B ] +(1+             U )R
                                                                                           Hc b            Hc b           32     b
               that has had the most computation done upon it, or, the
                                                                                 (149)∀        :
               heaviest path. Clearly one factor that helps determine the               U∈BU
               heaviest path is the block number of the leaf, equivalent                 σ′[U ]   = σ[U ] +(1+ 1(U −B ))R
               to the number of blocks, not counting the unmined genesis                     c b           c b        8   i     Hi    b
               block, in the path. The longer the path, the greater the             If there are collisions of the beneﬁciary addresses be-
               total mining eﬀort that must have been done in order to           tween ommers and the block (i.e. two ommers with the
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                           EIP-150 REVISION          13
                samebeneﬁciaryaddressoranommerwiththesamebene-                    11.5. Mining Proof-of-Work. The mining proof-of-
                ﬁciary address as the present block), additions are applied       work (PoW) exists as a cryptographically secure nonce
                cumulatively.                                                     that proves beyond reasonable doubt that a particular
                   Wedeﬁne the block reward as 5 Ether:                           amount of computation has been expended in the deter-
                (150)               Let   R =5×1018                               mination of some token value n. It is utilised to enforce
                                            b                                     the blockchain security by giving meaning and credence
                11.4. State & Nonce Validation. We may now deﬁne                  to the notion of diﬃculty (and, by extension, total dif-
                the function, Γ, that maps a block B to its initiation state:     ﬁculty). However, since mining new blocks comes with
                (151)                                                             an attached reward, the proof-of-work not only functions
                        (σ                                   if  P(B )=∅          as a method of securing conﬁdence that the blockchain
                Γ(B) ≡      0                                         H           will remain canonical into the future, but also as a wealth
                          σ : TRIE(L (σ )) = P(B )           otherwise            distribution mechanism.
                            i         S    i         H Hr
                                                                                     For both reasons, there are two important goals of the
                   Here, TRIE(L (σ )) means the hash of the root node of
                                 S   i                                            proof-of-work function; ﬁrstly, it should be as accessible as
                a trie of state σi; it is assumed that implementations will       possible to as many people as possible. The requirement
                store this in the state database, trivial and eﬃcient since       of, or reward from, specialised and uncommon hardware
                the trie is by nature an immutable data structure.                should be minimised. This makes the distribution model
                   And ﬁnally deﬁne Φ, the block transition function,             as open as possible, and, ideally, makes the act of mining a
                which maps an incomplete block B to a complete block              simple swap from electricity to Ether at roughly the same
                B′:                                                               rate for anyone around the world.
                (152) Φ(B)    ≡ B′: B′=B∗ except:                                    Secondly, it should not be possible to make super-linear
                                             2256                                 proﬁts, and especially not so with a high initial barrier.
                (153)   B′    = n: x6                                             Such a mechanism allows a well-funded adversary to gain
                          n                   H
                                                d                                 atroublesomeamountofthenetwork’stotalminingpower
                (154)   B′    = m with(x,m)=PoW(B∗,n,d)
                          m                                  n                    and as such gives them a super-linear reward (thus skew-
                (155)   B∗ ≡ B except: B∗=r(Π(Γ(B),B))                            ing distribution in their favour) as well as reducing the
                                                   r
                With d being a dataset as speciﬁed in appendix J.                 network security.
                   As speciﬁed at the beginning of the present work, Π is            One plague of the Bitcoin world is ASICs. These are
                the state-transition function, which is deﬁned in terms of        specialised pieces of compute hardware that exist only to
                Ω, the block ﬁnalisation function and Υ, the transaction-         do a single task. In Bitcoin’s case the task is the SHA256
                evaluation function, both now well-deﬁned.                        hashfunction. WhileASICsexistforaproof-of-workfunc-
                   As previously detailed, R[n] , R[n] and R[n] are the           tion, both goals are placed in jeopardy. Because of this,
                                                 σ      l           u             a proof-of-work function that is ASIC-resistant (i.e. diﬃ-
                nth corresponding states, logs and cumulative gas used af-        cult or economically ineﬃcient to implement in specialised
                ter each transaction (R[n]b, the fourth component in the          compute hardware) has been identiﬁed as the proverbial
                tuple, has already been deﬁned in terms of the logs). The         silver bullet.
                former is deﬁned simply as the state resulting from apply-           Two directions exist for ASIC resistance; ﬁrstly make
                ing the corresponding transaction to the state resulting          it sequential memory-hard, i.e. engineer the function such
                from the previous transaction (or the block’s initial state       that the determination of the nonce requires a lot of mem-
                in the case of the ﬁrst such transaction):                        ory and bandwidth such that the memory cannot be used
                (156)     R[n]σ = (Γ(B)                       if  n<0             in parallel to discover multiple nonces simultaneously. The
                                     Υ(R[n−1] ,B [n]) otherwise                   second is to make the type of computation it would need
                                                 σ    T                           to do general-purpose; the meaning of “specialised hard-
                   In the case of B [n] , we take a similar approach deﬁn-        ware” for a general-purpose task set is, naturally, general
                                   R u
                ing each item as the gas used in evaluating the correspond-       purpose hardware and as such commodity desktop com-
                ing transaction summed with the previous item (or zero,           puters are likely to be pretty close to “specialised hard-
                if it is the ﬁrst), giving us a running total:                    ware” for the task. For Ethereum 1.0 we have chosen the
                                                                                 ﬁrst path.
                                 
                                    0                           if  n<0              More formally, the proof-of-work function takes the
                (157)   R[n] = g                                                 form of PoW:
                             u    Υ (R[n−1]σ,BT[n])
                                  +R[n−1]u                     otherwise         (160)                 256
                                                                                  m=H ∧ n62                   with   (m,n) = PoW(H ,H ,d)
                   For R[n] , we utilise the Υl function that we conve-                   m             H                             n    n
                            l                                                                             d
                niently deﬁned in the transaction execution function.                Where Hn is the new block’s header but without the
                                         l                                        nonce and mix-hash components; H is the nonce of the
                (158)         R[n] =Υ(R[n−1]σ,B [n])                                                                     n
                                   l                     T
                                                                                  header; d is a large data set needed to compute the mix-
                   Finally, we deﬁne Π as the new state given the block           Hash and H is the new block’s diﬃculty value (i.e. the
                                                                                               d
                reward function Ω applied to the ﬁnal transaction’s resul-        block diﬃculty from section 10). PoW is the proof-of-work
                tant state, ℓ(B ) :
                               R σ                                                function which evaluates to an array with the ﬁrst item
                (159)             Π(σ,B)≡Ω(B,ℓ(R) )                               being the mixHash and the second item being a pseudo-
                                                        σ                         randomnumbercryptographically dependent on H and d.
                   Thus the complete block-transition mechanism, less             TheunderlyingalgorithmiscalledEthashandisdescribed
                PoW, the proof-of-work function is deﬁned.                        below.
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                           EIP-150 REVISION          14
                11.5.1. Ethash. Ethash is the planned PoW algorithm               a trivial solution would be to add some constant amount
                for Ethereum 1.0.     It is the latest version of Dagger-         and hashing the result.
                Hashimoto, introduced by Buterin [2013b] and Dryja
                [2014], although it can no longer appropriately be called                          13. Future Directions
                that since many of the original features of both algorithms
                havebeendrasticallychangedinthelastmonthofresearch                   Thestate database won’t be forced to maintain all past
                and development. The general route that the algorithm             state trie structures into the future. It should maintain an
                takes is as follows:                                              age for each node and eventually discard nodes that are
                   There exists a seed which can be computed for each             neither recent enough nor checkpoints; checkpoints, or a
                block by scanning through the block headers up until that         set of nodes in the database that allow a particular block’s
                point. From the seed, one can compute a pseudorandom              state trie to be traversed, could be used to place a maxi-
                cache, Jcacheinit bytes in initial size. Light clients store      mumlimit on the amount of computation needed in order
                the cache. From the cache, we can generate a dataset,             to retrieve any state throughout the blockchain.
                Jdatasetinit bytes in initial size, with the property that           Blockchain consolidation could be used in order to re-
                each item in the dataset depends on only a small number           ducetheamountofblocksaclientwouldneedtodownload
                of items from the cache. Full clients and miners store the        to act as a full, mining, node. A compressed archive of the
                dataset. The dataset grows linearly with time.                    trie structure at given points in time (perhaps one in every
                   Mining involves grabbing random slices of the dataset          10,000th block) could be maintained by the peer network,
                and hashing them together. Veriﬁcation can be done with           eﬀectively recasting the genesis block. This would reduce
                low memory by using the cache to regenerate the speciﬁc           the amount to be downloaded to a single archive plus a
                pieces of the dataset that you need, so you only need to          hard maximum limit of blocks.
                store the cache. The large dataset is updated once ev-               Finally, blockchain compression could perhaps be con-
                ery Jepoch blocks, so the vast majority of a miner’s eﬀort        ducted: nodes in state trie that haven’t sent/received a
                will be reading the dataset, not making changes to it. The        transaction in some constant amount of blocks could be
                mentionedparametersaswellasthealgorithmisexplained                thrown out, reducing both Ether-leakage and the growth
                in detail in appendix J.                                          of the state database.
                             12. Implementing Contracts                           13.1. Scalability. Scalability remains an eternal con-
                   Thereareseveral patterns of contracts engineering that         cern. With a generalised state transition function, it be-
                allow particular useful behaviours; two of these that I will      comes diﬃcult to partition and parallelise transactions
                brieﬂy discuss are data feeds and random numbers.                 to apply the divide-and-conquer strategy. Unaddressed,
                                                                                  the dynamic value-range of the system remains essentially
                12.1. Data Feeds. Adatafeedcontractisonewhichpro-                 ﬁxed and as the average transaction value increases, the
                vides a single service: it gives access to information from       less valuable of them become ignored, being economically
                the external world within Ethereum. The accuracy and              pointless to include in the main ledger. However, several
                timeliness of this information is not guaranteed and it is        strategies exist that may potentially be exploited to pro-
                the task of a secondary contract author—the contract that         vide a considerably more scalable protocol.
                utilises the data feed—to determine how much trust can               Some form of hierarchical structure, achieved by ei-
                be placed in any single data feed.                                ther consolidating smaller lighter-weight chains into the
                   The general pattern involves a single contract within          main block or building the main block through the in-
                Ethereum which, when given a message call, replies with           cremental combination and adhesion (through proof-of-
                some timely information concerning an external phenom-            work) of smaller transaction sets may allow parallelisa-
                enon.   An example might be the local temperature of              tion of transaction combination and block-building. Par-
                NewYorkCity. This would be implemented as a contract              allelism could also come from a prioritised set of parallel
                that returned that value of some known point in storage.          blockchains, consolidated each block and with duplicate
                Of course this point in storage must be maintained with           or invalid transactions thrown out accordingly.
                the correct such temperature, and thus the second part               Finally, veriﬁable computation, if made generally avail-
                of the pattern would be for an external server to run an          able and eﬃcient enough, may provide a route to allow the
                Ethereum node, and immediately on discovery of a new              proof-of-work to be the veriﬁcation of ﬁnal state.
                block, creates a new valid transaction, sent to the contract,
                updating said value in storage. The contract’s code would                               14. Conclusion
                accept such updates only from the identity contained on
                said server.                                                         I have introduced, discussed and formally deﬁned the
                                                                                  protocol of Ethereum. Through this protocol the reader
                12.2. Random Numbers. Providing random numbers                    mayimplement a node on the Ethereum network and join
                within a deterministic system is, naturally, an impossible        others in a decentralised secure social operating system.
                task. However, we can approximate with pseudo-random              Contracts may be authored in order to algorithmically
                numbers by utilising data which is generally unknowable           specify and autonomously enforce rules of interaction.
                at the time of transacting. Such data might include the
                block’s hash, the block’s timestamp and the block’s beneﬁ-                         15. Acknowledgements
                ciary address. In order to make it hard for malicious miner
                to control those values, one should use the BLOCKHASH                Many thanks to Aeron Buchanan for authoring the
                operation in order to use hashes of the previous 256 blocks       Homesteadrevisions, ChristophJentzschforauthoringthe
                as pseudo-random numbers. For a series of such numbers,           Ethash algorithm and Yoichi Hirai for doing most of the
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION         15
               EIP-150 changes. Important maintenance, useful correc-             {https://en.wikipedia.org/wiki/Fowler%E2%80%
               tions and suggestions were provided by a number of oth-            93Noll%E2%80%93Vo_hash_function#cite_note-2}.
               ers from the Ethereum DEV organisation and Ethereum              Nils Gura, Arun Patel, Arvinderpal Wander, Hans Eberle,
               community at large including Gustav Simonsson, Pawe l              and Sheueling Chang Shantz. Comparing elliptic curve
               Bylica, Jutta Steiner, Nick Savers, Viktor Tr´on, Marko            cryptography and RSA on 8-bit CPUs.           In Crypto-
               Simovic, Giacomo Tazzari and, of course, Vitalik Buterin.          graphic Hardware and Embedded Systems-CHES 2004,
                                                                                  pages 119–132. Springer, 2004.
                                      References                                Sergio DemianLerner. StrictMemoryHardHashingFunc-
               Jacob Aron. BitCoin software ﬁnds new life. New Scien-             tions. 2014. URL {http://www.hashcash.org/papers/
                  tist, 213(2847):20, 2012.                                       memohash.pdf}.
               Adam Back. Hashcash - Amortizable Publicly Auditable             Mark Miller. The Future of Law. In paper delivered at the
                  Cost-Functions. 2002. URL {http://www.hashcash.                 Extro 3 Conference (August 9), 1997.
                  org/papers/amortizable.pdf}.                                  Satoshi Nakamoto. Bitcoin: A peer-to-peer electronic cash
               RomanBoutellierandMareikeHeinzen. Pirates, Pioneers,               system. Consulted, 1:2012, 2008.
                  Innovators and Imitators. In Growth Through Innova-           Meni Rosenfeld. Overview of Colored Coins. 2012. URL
                  tion, pages 85–96. Springer, 2014.                              {https://bitcoil.co.il/BitcoinX.pdf}.
               Vitalik Buterin.   Ethereum: A Next-Generation Smart             Yonatan Sompolinsky and Aviv Zohar.                  Accel-
                  Contract and Decentralized Application Platform.                erating    Bitcoin’s   Transaction     Processing.   Fast
                  2013a. URL {http://ethereum.org/ethereum.html}.                 Money Grows on Trees, Not Chains, 2013.              URL
               Vitalik Buterin. Dagger: A Memory-Hard to Compute,                 {CryptologyePrintArchive,Report2013/881}.
                  Memory-EasytoVerifyScryptAlternative. 2013b. URL                http://eprint.iacr.org/.
                  {http://vitalik.ca/ethereum/dagger.html}.                     Simon Sprankel. Technical Basis of Digital Currencies,
               Thaddeus Dryja. Hashimoto: I/O bound proof of work.                2013.
                  2014. URL {https://mirrorx.com/files/hashimoto.               Nick Szabo. Formalizing and securing relationships on
                  pdf}.                                                           public networks. First Monday, 2(9), 1997.
               Cynthia Dwork and Moni Naor. Pricing via processing or           Vivek Vishnumurthy, Sangeeth Chandrakumar, and
                  combatting junk mail. In In 12th Annual International           Emin Gn Sirer. Karma: A secure economic framework
                  Cryptology Conference, pages 139–147, 1992.                     for peer-to-peer resource sharing, 2003.
               Phong     Vo    Glenn    Fowler,    Landon     Curt    Noll.     J. R. Willett. MasterCoin Complete Speciﬁcation. 2013.
                  FowlerNollVo    hash    function.       1991.       URL         URL{https://github.com/mastercoin-MSC/spec}.
                                                              Appendix A. Terminology
                     External Actor: A person or other entity able to interface to an Ethereum node, but external to the world of
                        Ethereum. It can interact with Ethereum through depositing signed Transactions and inspecting the blockchain
                        and associated state. Has one (or more) intrinsic Accounts.
                     Address: A 160-bit code used for identifying Accounts.
                     Account: Accounts have an intrinsic balance and transaction count maintained as part of the Ethereum state.
                        They also have some (possibly empty) EVM Code and a (possibly empty) Storage State associated with them.
                        Though homogenous, it makes sense to distinguish between two practical types of account: those with empty
                        associated EVM Code (thus the account balance is controlled, if at all, by some external entity) and those with
                        non-empty associated EVM Code (thus the account represents an Autonomous Object). Each Account has a
                        single Address that identiﬁes it.
                     Transaction: A piece of data, signed by an External Actor. It represents either a Message or a new Autonomous
                        Object. Transactions are recorded into each block of the blockchain.
                     Autonomous Object: AnotionalobjectexistentonlywithinthehypotheticalstateofEthereum. Hasanintrinsic
                        address and thus an associated account; the account will have non-empty associated EVM Code. Incorporated
                        only as the Storage State of that account.
                     Storage State: The information particular to a given Account that is maintained between the times that the
                        Account’s associated EVM Code runs.
                     Message: Data (as a set of bytes) and Value (speciﬁed as Ether) that is passed between two Accounts, either
                        through the deterministic operation of an Autonomous Object or the cryptographically secure signature of the
                        Transaction.
                     Message Call: Theactofpassing a message from one Account to another. If the destination account is associated
                        with non-empty EVM Code, then the VM will be started with the state of said Object and the Message acted
                        upon. If the message sender is an Autonomous Object, then the Call passes any data returned from the VM
                        operation.
                     Gas: The fundamental network cost unit. Paid for exclusively by Ether (as of PoC-4), which is converted freely
                        to and from Gas as required. Gas does not exist outside of the internal Ethereum computation engine; its price
                        is set by the Transaction and miners are free to ignore Transactions whose Gas price is too low.
                     Contract: Informal term used to mean both a piece of EVM Code that may be associated with an Account or an
                        Autonomous Object.
                     Object: Synonym for Autonomous Object.
                            ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                                     EIP-150 REVISION             16
                       App: An end-user-visible application hosted in the Ethereum Browser.
                       Ethereum Browser: (akaEthereumReferenceClient)Across-platformGUIofaninterfacesimilartoasimpliﬁed
                           browser (a la Chrome) that is able to host sandboxed applications whose backend is purely on the Ethereum
                           protocol.
                       Ethereum Virtual Machine: (aka EVM) The virtual machine that forms the key part of the execution model
                           for an Account’s associated EVM Code.
                       Ethereum Runtime Environment: (aka ERE) The environment which is provided to an Autonomous Object
                           executing in the EVM. Includes the EVM but also the structure of the world state on which the EVM relies for
                           certain I/O instructions including CALL & CREATE.
                       EVMCode: Thebytecode that the EVM can natively execute. Used to formally specify the meaning and rami-
                           ﬁcations of a message to an Account.
                       EVMAssembly: The human-readable form of EVM-code.
                       LLL: TheLisp-likeLow-levelLanguage,ahuman-writablelanguageusedforauthoringsimplecontractsandgeneral
                           low-level language toolkit for trans-compiling to.
                                                              Appendix B. Recursive Length Prefix
                     This is a serialisation method for encoding arbitrarily structured binary data (byte arrays).
                     Wedeﬁne the set of possible structures T:
                 (161)                                   T ≡ L∪B
                 (162)                                   L ≡ {t:t=(t[0],t[1],...) ∧ ∀                    t[n] ∈ T}
                                                                                                  n<ktk
                 (163)                                   B ≡ {b:b=(b[0],b[1],...) ∧ ∀                      b[n] ∈ O}
                                                                                                    n<kbk
                     Where O is the set of bytes. Thus B is the set of all sequences of bytes (otherwise known as byte-arrays, and a leaf if
                 imagined as a tree), L is the set of all tree-like (sub-)structures that are not a single leaf (a branch node if imagined as
                 a tree) and T is the set of all byte-arrays and such structural sequences.
                     We deﬁne the RLP function as RLP through two sub-functions, the ﬁrst handling the instance when the value is a
                 byte array, the second when it is a sequence of further values:
                                                                                  (
                 (164)                                                 RLP(x) ≡     Rb(x) if x∈B
                                                                                    Rl(x)     otherwise
                     If the value to be serialised is a byte-array, the RLP serialisation takes one of three forms:
                        • If the byte-array contains solely a single byte and that single byte is less than 128, then the input is exactly
                           equal to the output.
                        • If the byte-array contains fewer than 56 bytes, then the output is equal to the input preﬁxed by the byte equal
                           to the length of the byte array plus 128.
                        • Otherwise, the output is equal to the input preﬁxed by the minimal-length byte-array which when interpreted
                           as a big-endian integer is equal to the length of the input byte array, which is itself preﬁxed by the number of
                           bytes required to faithfully encode this length value plus 183.
                     Formally, we deﬁne Rb:
                                                                  
                                                                  
                                                                    x                                       if  kxk = 1∧x[0] < 128
                 (165)                             R (x)     ≡ 
                                                     b              (128+kxk)·x                             else if  kxk < 56
                                                                                      
                                                                                         
                                                                                      
                                                                     183+ BE(kxk)          · BE(kxk) · x    otherwise
                                                                                               n<kbk
                 (166)                             BE(x)     ≡ (b0,b1,...) : b0 6= 0 ∧ x = X bn ·256kbk−1−n
                                                                                                n=0
                 (167)                 (a) · (b,c) · (d,e)   = (a,b,c,d,e)
                     Thus BE is the function that expands a positive integer value to a big-endian byte array of minimal length and the
                 dot operator performs sequence concatenation.
                     If instead, the value to be serialised is a sequence of other items then the RLP serialisation takes one of two forms:
                        • If the concatenated serialisations of each contained item is less than 56 bytes in length, then the output is equal
                           to that concatenation preﬁxed by the byte equal to the length of this byte array plus 192.
                        • Otherwise, the output is equal to the concatenated serialisations preﬁxed by the minimal-length byte-array
                           which when interpreted as a big-endian integer is equal to the length of the concatenated serialisations byte
                           array, which is itself preﬁxed by the number of bytes required to faithfully encode this length value plus 247.
                     Thus we ﬁnish by formally deﬁning Rl:
                                                            ((192+ks(x)k)·s(x)                                  if  ks(x)k < 56
                 (168)                       Rl(x)     ≡                            
                                                                                    
                                                               247+ BE(ks(x)k)          · BE(ks(x)k) · s(x)     otherwise
                 (169)                         s(x)    ≡ RLP(x )·RLP(x )...
                                                                   0          1
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION         17
                  If RLP is used to encode a scalar, deﬁned only as a positive integer (P or any x for Px), it must be speciﬁed as the
               shortest byte array such that the big-endian interpretation of it is equal. Thus the RLP of some positive integer i is
               deﬁned as:
               (170)                                            RLP(i : i ∈ P) ≡ RLP(BE(i))
                  Wheninterpreting RLP data, if an expected fragment is decoded as a scalar and leading zeroes are found in the byte
               sequence, clients are required to consider it non-canonical and treat it in the same manner as otherwise invalid RLP
               data, dismissing it completely.
                  There is no speciﬁc canonical encoding format for signed or ﬂoating-point values.
                                                         Appendix C. Hex-Prefix Encoding
                  Hex-preﬁx encoding is an eﬃcient method of encoding an arbitrary number of nibbles as a byte array. It is able to
               store an additional ﬂag which, when used in the context of the trie (the only context in which it is used), disambiguates
               between node types.
                  It is deﬁned as the function HP which maps from a sequence of nibbles (represented by the set Y) together with a
               boolean value to a sequence of bytes (represented by the set B):
               (171)          HP(x,t) : x ∈ Y   ≡ ((16f(t),16x[0]+x[1],16x[2]+x[3],...)                      if  kxk is even
                                                      (16(f(t) +1)+x[0],16x[1]+x[2],16x[3]+x[4],...)         otherwise
               (172)                     f(t)   ≡ (2 if t6=0
                                                      0   otherwise
                  Thus the high nibble of the ﬁrst byte contains two ﬂags; the lowest bit encoding the oddness of the length and the
               second-lowest encoding the ﬂag t. The low nibble of the ﬁrst byte is zero in the case of an even number of nibbles and the
               ﬁrst nibble in the case of an odd number. All remaining nibbles (now an even number) ﬁt properly into the remaining
               bytes.
                                                   Appendix D. Modified Merkle Patricia Tree
                  The modiﬁed Merkle Patricia tree (trie) provides a persistent data structure to map between arbitrary-length binary
               data (byte arrays). It is deﬁned in terms of a mutable data structure to map between 256-bit binary fragments and
               arbitrary-length binary data, typically implemented as a database. The core of the trie, and its sole requirement in terms
               of the protocol speciﬁcation is to provide a single value that identiﬁes a given set of key-value pairs, which may be either
               a 32 byte sequence or the empty byte sequence. It is left as an implementation consideration to store and maintain the
               structure of the trie in a manner the allows eﬀective and eﬃcient realisation of the protocol.
                  Formally, we assume the input value I, a set containing pairs of byte sequences:
               (173)                                   I = {(k ∈ B,v ∈ B),(k ∈ B,v ∈ B),...}
                                                               0       0         1       1
                  When considering such a sequence, we use the common numeric subscript notation to refer to a tuple’s key or value,
               thus:
               (174)                                                 ∀    I ≡ (I ,I )
                                                                       I∈I      0   1
                  Any series of bytes may also trivially be viewed as a series of nibbles, given an endian-speciﬁc notation; here we
               assume big-endian. Thus:
                                                                            ′                 ′
               (175)                                         y(I)   = {(k ∈Y,v ∈B),(k ∈Y,v ∈B),...}
                                                                        ( 0         0         1       1
                                                                          ⌊k [i÷2]÷16⌋          if i is even
               (176)                       ∀    ∀           k′ [i]  ≡       n
                                            n    i:i<2kk k    n
                                                       n                  k [⌊i÷2⌋] mod 16 otherwise
                                                                           n
                  We deﬁne the function TRIE, which evaluates to the root of the trie that represents this set when encoded in this
               structure:
               (177)                                              TRIE(I) ≡ KEC(c(I,0))
                  We also assume a function n, the trie’s node cap function. When composing a node, we use RLP to encode the
               structure. As a means of reducing storage complexity, for nodes whose composed RLP is fewer than 32 bytes, we store
               the RLP directly; for those larger we assert prescience of the byte array whose Keccak hash evaluates to our reference.
               Thus we deﬁne in terms of c, the node composition function:
                                                                 
                                                                 
                                                                    ()           if  I = ∅
               (178)                                    n(I,i) ≡ 
                                                                    c(I,i)       if  kc(I,i)k < 32
                                                                 
                                                                 
                                                                    KEC(c(I,i))  otherwise
                  In a manner similar to a radix tree, when the trie is traversed from root to leaf, one may build a single key-value
               pair. The key is accumulated through the traversal, acquiring a single nibble from each branch node (just as with a
               radix tree). Unlike a radix tree, in the case of multiple keys sharing the same preﬁx or in the case of a single key having
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION         18
               a unique suﬃx, two optimising nodes are provided. Thus while traversing, one may potentially acquire multiple nibbles
               from each of the other two node types, extension and leaf. There are three kinds of nodes in the trie:
                     Leaf: A two-item structure whose ﬁrst item corresponds to the nibbles in the key not already accounted for by the
                        accumulation of keys and branches traversed from the root. The hex-preﬁx encoding method is used and the
                        second parameter to the function is required to be true.
                     Extension: A two-item structure whose ﬁrst item corresponds to a series of nibbles of size greater than one that
                        are shared by at least two distinct keys past the accumulation of nibbles keys and branches as traversed from
                        the root. The hex-preﬁx encoding method is used and the second parameter to the function is required to be
                        false.
                     Branch: A 17-item structure whose ﬁrst sixteen items correspond to each of the sixteen possible nibble values for
                        the keys at this point in their traversal. The 17th item is used in the case of this being a terminator node and
                        thus a key being ended at this point in its traversal.
                  Abranch is then only used when necessary; no branch nodes may exist that contain only a single non-zero entry. We
               may formally deﬁne this structure with the structural composition function c:
               (179)                                        
                                                            
                           RLP  HP(I [i..(kI k − 1)],true),I        if  kIk = 1    where ∃I : I ∈ I
                                   0       0               1
                                                               
                                                               
                        
                        
                        
                           RLP  HP(I [i..(j − 1)],false),n(I,j)     if  i 6= j  where j = argmax : ∃l : klk = x : ∀      : I [0..(x − 1)] = l
                                  0                                                             x                 I∈I    0
               c(I,i) ≡    RLP (u(0),u(1),...,u(15),v)              otherwise    where u(j)    ≡ n({I : I ∈ I∧I [i] = j},i+1)
                                                                                                  (               0
                        
                        
                        
                                                                                                    I    if  ∃I : I ∈ I ∧ kI k = i
                                                                                                     1                     0
                                                                                          v   =
                                                                                                    ()   otherwise
               D.1. Trie Database. Thus no explicit assumptions are made concerning what data is stored and what is not, since
               that is an implementation-speciﬁc consideration; we simply deﬁne the identity function mapping the key-value set I
               to a 32-byte hash and assert that only a single such hash exists for any I, which though not strictly true is accurate
               within acceptable precision given the Keccak hash’s collision resistance. In reality, a sensible implementation will not
               fully recompute the trie root hash for each set.
                  A reasonable implementation will maintain a database of nodes determined from the computation of various tries
               or, more formally, it will memoise the function c. This strategy uses the nature of the trie to both easily recall the
               contents of any previous key-value set and to store multiple such sets in a very eﬃcient manner. Due to the dependency
               relationship, Merkle-proofs may be constructed with an O(logN) space requirement that can demonstrate a particular
               leaf must exist within a trie of a given root hash.
                                                        Appendix E. Precompiled Contracts
                  For each precompiled contract, we make use of a template function, ΞPRE, which implements the out-of-gas checking.
                                                                     (         0
               (180)                                  Ξ (σ,g,I)≡ (∅,0,A ,())               if  g < gr
                                                       PRE                          0
                                                                       (σ,g −gr,A ,o) otherwise
                  The precompiled contracts each use these deﬁnitions and provide speciﬁcations for the o (the output data) and gr,
               the gas requirements.
                  For the elliptic curve DSA recover VM execution function, we also deﬁne d to be the input data, well-deﬁned for an
               inﬁnite length by appending zeroes as required. Importantly in the case of an invalid signature (ECDSARECOVER(h,v,r,s) =
               ∅), then we have no output.
               (181)                                Ξ        ≡ Ξ        where:
                                                      ECREC        PRE
               (182)                                    gr   = 3000
               (183)                                   |o|   = (0 if ECDSARECOVER(h,v,r,s)=∅
                                                                   32   otherwise
               (184)                         if  |o| = 32 :
               (185)                               o[0..11]  = 0                              
               (186)                             o[12..31]   = KEC ECDSARECOVER(h,v,r,s) [12..31]        where:
               (187)                       d[0..(|I | − 1)]  = I
                                                  d               d
               (188)                              d[|I |..]  = (0,0,...)
                                                      d
               (189)                                     h = d[0..31]
               (190)                                     v   = d[32..63]
               (191)                                     r   = d[64..95]
               (192)                                     s   = d[96..127]
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION         19
                  The two hash functions, RIPEMD-160 and SHA2-256 are more trivially deﬁned as an almost pass-through operation.
               Their gas usage is dependent on the input data size, a factor rounded up to the nearest number of words.
               (193)                                           ΞSHA256   ≡ ΞPRE where:
                                                                                     l|I |m
               (194)                                                g    = 60+12 d
                                                                     r                 32
               (195)                                          o[0..31]   = SHA256(Id)
               (196)                                           ΞRIP160   ≡ ΞPRE where:
                                                                                       l|I |m
               (197)                                                g    = 600+120        d
                                                                     r                   32
               (198)                                          o[0..11]   = 0
               (199)                                         o[12..31]   = RIPEMD160(I )
                                                                                          d
               (200)
                  For the purposes here, we assume we have well-deﬁned standard cryptographic functions for RIPEMD-160 and SHA2-
               256 of the form:
               (201)                                             SHA256(i ∈ B)    ≡ o∈B
                                                                                            32
               (202)                                         RIPEMD160(i ∈ B)     ≡ o∈B
                                                                                            20
                  Finally, the fourth contract, the identity function ΞID simply deﬁnes the output as the input:
               (203)                                              Ξ     ≡ Ξ        where:
                                                                   ID         PRE
                                                                                   l|I |m
               (204)                                               g    = 15+3 d
                                                                    r                32
               (205)                                                o = I
                                                                             d
                                                         Appendix F. Signing Transactions
                  The method of signing transactions is similar to the ‘Electrum style signatures’; it utilises the SECP-256k1 curve as
               described by Gura et al. [2004].
                  It is assumed that the sender has a valid private key pr, which is a randomly selected positive integer (represented as
               a byte array of length 32 in big-endian form) in the range [1,secp256k1n−1].
                  Weassert the functions ECDSASIGN, ECDSARESTORE and ECDSAPUBKEY. These are formally deﬁned in the literature.
               (206)                                          ECDSAPUBKEY(p ∈ B )       ≡ p ∈B
                                                                             r     32         u     64
               (207)                                   ECDSASIGN(e ∈ B ,p ∈ B )         ≡ (v∈B ,r∈B ,s∈B )
                                                                         32  r     32              1       32       32
               (208)                ECDSARECOVER(e ∈ B ,v ∈ B ,r ∈ B ,s ∈ B )           ≡ p ∈B
                                                          32      1       32       32         u     64
                  Where p is the public key, assumed to be a byte array of size 64 (formed from the concatenation of two positive
                           u
               integers each < 2256) and p is the private key, a byte array of size 32 (or a single positive integer in the aforementioned
                                           r
               range). It is assumed that v is the ‘recovery id’, a 1 byte value specifying the sign and ﬁniteness of the curve point; this
               value is in the range of [27,30], however we declare the upper two possibilities, representing inﬁnite values, invalid.
                  Wedeclare that a signature is invalid unless all the following conditions are true:
               (209)                                    0 < r < secp256k1n
                                                                 secp256k1n         if  H <N
                                                                                           i     H
               (210)                                    0 < s <    secp256k1n÷2 otherwise
               (211)                                        v ∈ {27,28}
               where:
               (212)      secp256k1n = 115792089237316195423570985008687907852837564279074904382605163141518161494337
                  For a given private key, p , the Ethereum address A(p ) (a 160-bit value) to which it corresponds is deﬁned as the
                                             r                              r
               right most 160-bits of the Keccak hash of the corresponding ECDSA public key:
                                                                                                
               (213)                                    A(p ) = B         KEC ECDSAPUBKEY(p )
                                                            r      96..255                    r
                  The message hash, h(T), to be signed is the Keccak hash of the transaction without the latter three signature
               components, formally described as T , T and T :
                                                     r   s       w
                                                                  ((T ,T ,T ,T ,T ,T )      if T = 0
               (214)                                L (T) ≡           n   p  g   t  v   i       t
                                                      S             (T ,T ,T ,T ,T ,T )     otherwise
                                                                      n   p  g   t  v   d
               (215)                                  h(T)   ≡ KEC(L (T))
                                                                        S
                  The signed transaction G(T,p ) is deﬁned as:
                                                  r
               (216)                                                  G(T,p ) ≡ T     except:
                                                                            r
               (217)                                     (Tw,Tr,Ts) = ECDSASIGN(h(T),pr)
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION          20
                   Wemaythen deﬁne the sender function S of the transaction as:
                                                                                                          
               (218)                              S(T) ≡ B96..255 KEC ECDSARECOVER(h(T),Tw,Tr,Ts)
                   The assertion that the sender of the a signed transaction equals the address of the signer should be self-evident:
               (219)                                           ∀T : ∀p : S(G(T,p )) ≡ A(p )
                                                                       r           r         r
                                                               Appendix G. Fee Schedule
                   The fee schedule G is a tuple of 31 scalar values corresponding to the relative costs, in gas, of a number of abstract
               operations that a transaction may eﬀect.
                    Name              Value   Description*
                    G                     0   Nothing paid for operations of the set W        .
                      zero                                                                zero
                    G                     2   Amount of gas to pay for operations of the set W         .
                      base                                                                         base
                    G                     3   Amount of gas to pay for operations of the set W            .
                      verylow                                                                      verylow
                    G                     5   Amount of gas to pay for operations of the set W        .
                      low                                                                          low
                    G                     8   Amount of gas to pay for operations of the set W        .
                      mid                                                                          mid
                    G                    10   Amount of gas to pay for operations of the set W         .
                      high                                                                         high
                    G                   700   Amount of gas to pay for operations of the set W           .
                      extcode                                                                      extcode
                    G                   400   Amount of gas to pay for a BALANCE operation.
                      balance
                    G                   200   Paid for a SLOAD operation.
                      sload
                    G                     1   Paid for a JUMPDEST operation.
                      jumpdest
                    G                 20000   Paid for an SSTORE operation when the storage value is set to non-zero from zero.
                      sset
                    G                  5000   Paid for an SSTORE operation when the storage value’s zeroness remains unchanged or is set to zero.
                      sreset
                    Rsclear           15000   Refund given (added into refund counter) when the storage value is set to zero from non-zero.
                    Rsuicide          24000   Refund given (added into refund counter) for suiciding an account.
                    G                  5000   Amount of gas to pay for a SUICIDE operation.
                      suicide
                    G                 32000   Paid for a CREATE operation.
                      create
                    G                   200   Paid per byte for a CREATE operation to succeed in placing code into state.
                      codedeposit
                    G                   700   Paid for a CALL operation.
                      call
                    G                  9000   Paid for a non-zero value transfer as part of the CALL operation.
                      callvalue
                    G                  2300   Astipend for the called contract subtracted from G               for a non-zero value transfer.
                      callstipend                                                                     callvalue
                    G                 25000   Paid for a CALL or SUICIDE operation which creates an account.
                      newaccount
                    G                    10   Partial payment for an EXP operation.
                      exp
                    G                    10   Partial payment when multiplied by ⌈log        (exponent)⌉ for the EXP operation.
                      expbyte                                                             256
                    G                     3   Paid for every additional word when expanding memory.
                      memory
                    G                 32000   Paid by all contract-creating transactions after the Homestead transition.
                      txcreate
                    G                     4   Paid for every zero byte of data or code for a transaction.
                      txdatazero
                    G                    68   Paid for every non-zero byte of data or code for a transaction.
                      txdatanonzero
                    G                 21000   Paid for every transaction.
                      transaction
                    G                   375   Partial payment for a LOG operation.
                      log
                    G                     8   Paid for each byte in a LOG operation’s data.
                      logdata
                    G                   375   Paid for each topic of a LOG operation.
                      logtopic
                    G                    30   Paid for each SHA3 operation.
                      sha3
                    G                     6   Paid for each word (rounded up) for input data to a SHA3 operation.
                      sha3word
                    G                     3   Partial payment for *COPY operations, multiplied by words copied, rounded up.
                      copy
                    G                    20   Payment for BLOCKHASH operation.
                      blockhash
                                                     Appendix H. Virtual Machine Specification
                   When interpreting 256-bit binary values as integers, the representation is big-endian.
                   Whena256-bit machine datum is converted to and from a 160-bit address or hash, the rightwards (low-order for BE)
               20 bytes are used and the left most 12 are discarded or ﬁlled with zeroes, thus the integer values (when the bytes are
               interpreted as big-endian) are equivalent.
               H.1. Gas Cost. The general gas cost function, C, is deﬁned as:
                                    ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                                                               EIP-150 REVISION                     21
                      (220)                                                  
                                                                             
                                                                                CSSTORE(σ,µ)                                                  if   w=SSTORE
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                Gexp                                                          if   w=EXP∧µ[1]=0
                                                                                                                                                                      s
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                Gexp +G                 ×(1+⌊log             (µ [1])⌋)        if   w=EXP∧µ[1]>0
                                                                                             expbyte                    256     s                                     s
                                                                             
                                                                             
                                                                             
                                                                                G             +G          ×⌈µ [2]÷32⌉                         if   w=CALLDATACOPY∨CODECOPY
                                                                              verylow              copy          s
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G            +G           ×⌈µ [3]÷32⌉                         if   w=EXTCODECOPY
                                                                              extcode             copy          s
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G +G                    ×µ[1]                                 if   w=LOG0
                                                                              log           logdata         s
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G +G                    ×µ[1]+G                               if   w=LOG1
                                                                              log           logdata         s           logtopic
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G +G                    ×µ[1]+2G                              if   w=LOG2
                                                                              log           logdata         s             logtopic
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G +G                    ×µ[1]+3G                              if   w=LOG3
                                                                              log           logdata         s             logtopic
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G +G                    ×µ[1]+4G                              if   w=LOG4
                                                                              log           logdata         s             logtopic
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                CCALL(σ,µ)                                                    if   w=CALL∨CALLCODE∨DELEGATECALL
                                                                             
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                CSUICIDE(σ,µ)                                                 if   w=SUICIDE
                                                      ′                      
                      C(σ,µ,I) ≡ Cmem(µ )−Cmem(µ )+ Gcreate                                                                                   if   w=CREATE
                                                      i                 i    
                                                                             
                                                                             
                                                                                G        +G                 ⌈s[1] ÷ 32⌉                       if   w=SHA3
                                                                              sha3             sha3word
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w=JUMPDEST
                                                                              jumpdest
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w=SLOAD
                                                                              sload
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              zero                                                                          zero
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              base                                                                          base
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              verylow                                                                       verylow
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              low                                                                           low
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              mid                                                                           mid
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              high                                                                          high
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w∈W
                                                                              extcode                                                                       extcode
                                                                             
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w=BALANCE
                                                                              balance
                                                                             
                                                                             
                                                                             
                                                                                G                                                             if   w=BLOCKHASH
                                                                                   blockhash
                                                                                               (
                                                                                                  I [µ ] if µ <kI k
                      (221)                                                             w≡ b pc                         pc         b
                                                                                                  STOP          otherwise
                          where:
                      (222)                                                            C        (a) ≡ G                · a + j a2 k
                                                                                         mem               memory                512
                          with CCALL, CSUICIDE and CSSTORE as speciﬁed in the appropriate section below. We deﬁne the following subsets of
                      instructions:
                          Wzero = {STOP, RETURN}
                          Wbase = {ADDRESS, ORIGIN, CALLER, CALLVALUE, CALLDATASIZE, CODESIZE, GASPRICE, COINBASE,
                                 TIMESTAMP, NUMBER, DIFFICULTY, GASLIMIT, POP, PC, MSIZE, GAS}
                          Wverylow = {ADD, SUB, NOT, LT, GT, SLT, SGT, EQ, ISZERO, AND, OR, XOR, BYTE, CALLDATALOAD,
                                 MLOAD, MSTORE, MSTORE8, PUSH*, DUP*, SWAP*}
                          Wlow = {MUL, DIV, SDIV, MOD, SMOD, SIGNEXTEND}
                          Wmid = {ADDMOD, MULMOD, JUMP}
                          Whigh = {JUMPI}
                          Wextcode = {EXTCODESIZE}
                          Notethememorycostcomponent,givenastheproductofG                                                      andthemaximumof0&theceilingofthenumber
                                                                                                                   memory
                      of words in size that the memory must be over the current number of words, µ in order that all accesses reference valid
                                                                                                                                            i
                      memory whether for read or write. Such accesses must be for non-zero number of bytes.
                          Referencing a zero length range (e.g. by attempting to pass it as the input range to a CALL) does not require memory
                                                                                               ′
                      to be extended to the beginning of the range. µ is deﬁned as this new maximum number of words of active memory;
                                                                                               i
                      special-cases are given where these two are not equal.
                          Note also that Cmem is the memory cost function (the expansion function being the diﬀerence between the cost before
                      andafter). It is a polynomial, with the higher-order coeﬃcient divided and ﬂoored, and thus linear up to 724B of memory
                      used, after which it costs substantially more.
                          While deﬁning the instruction set, we deﬁned the memory-expansion for range function, M, thus:
                                                                                              (
                      (223)                                                M(s,f,l) ≡            s                                   if    l = 0
                                                                                                 max(s,⌈(f +l)÷32⌉) otherwise
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION          22
                  Another useful function is “all but one 64th” function L deﬁned as:
               (224)                                                L(n) ≡ n−⌊n/64⌋
               H.2. Instruction Set. As previously speciﬁed in section 9, these deﬁnitions take place in the ﬁnal context there. In
               particular we assume O is the EVM state-progression function and deﬁne the terms pertaining to the next cycle’s state
                  ′  ′
               (σ ,µ ) such that:
                                                                    ′  ′   ′
               (225)                            O(σ,µ,A,I)≡(σ ,µ,A,I) with exceptions, as noted
                  Here given are the various exceptions to the state transition rules given in section 9 speciﬁed for each instruction,
               together with the additional instruction-speciﬁc deﬁnitions of J and C. For each instruction, also speciﬁed is α, the
               additional items placed on the stack and δ, the items removed from stack, as deﬁned in section 9.
                                                          0s: Stop and Arithmetic Operations
                                               256
                    All arithmetic is modulo 2     unless otherwise noted.
                    Value Mnemonic             δ  α Description
                      0x00   STOP              0   0   Halts execution.
                      0x01   ADD               2   1   Addition operation.
                                                        ′
                                                       µ [0] ≡ µ [0] +µ [1]
                                                        s        s       s
                      0x02   MUL               2   1   Multiplication operation.
                                                        ′
                                                       µ [0] ≡ µ [0] ×µ [1]
                                                        s        s       s
                      0x03   SUB               2   1   Subtraction operation.
                                                        ′
                                                       µ [0] ≡ µ [0] −µ [1]
                                                        s        s       s
                      0x04   DIV               2   1   Integer division operation.
                                                               (
                                                                 0                 if  µ [1] = 0
                                                        ′                               s
                                                       µ [0] ≡
                                                        s        ⌊µ [0] ÷µ [1]⌋    otherwise
                                                                    s       s
                      0x05   SDIV              2   1   Signed integer division operation (truncated).
                                                               
                                                               
                                                                 0                                      if µ [1] = 0
                                                                                                            s
                                                        ′           255                                                255
                                                       µ [0] ≡   −2                                     if µ [0] = −2     ∧ µ[1]=−1
                                                        s                                                   s                   s
                                                               
                                                                 sgn(µ [0]÷µ [1])⌊|µ [0]÷µ [1]|⌋        otherwise
                                                                        s       s       s       s
                                                       Where all values are treated as two’s complement signed 256-bit integers.
                                                       Note the overﬂow semantic when −2255 is negated.
                      0x06   MOD               2   1   Modulo remainder operation.
                                                               (
                                                                 0                  if µ [1] = 0
                                                        ′                                s
                                                       µ [0] ≡
                                                        s        µ [0] mod µ [1]    otherwise
                                                                   s          s
                      0x07   SMOD              2   1   Signed modulo remainder operation.
                                                               (
                                                                 0                               if  µ [1] = 0
                                                        ′                                              s
                                                       µ [0] ≡
                                                        s        sgn(µ [0])|µ [0]| mod |µ [1]|   otherwise
                                                                        s     s            s
                                                       Where all values are treated as two’s complement signed 256-bit integers.
                      0x08   ADDMOD            3   1   Modulo addition operation.
                                                               (
                                                        ′        0                             if  µs[2] = 0
                                                       µ [0] ≡
                                                        s        (µ [0] +µ [1]) mod µ [2]      otherwise
                                                                    s       s            s
                                                                                                                                 256
                                                       All intermediate calculations of this operation are not subject to the 2     modulo.
                      0x09   MULMOD            3   1   Modulo multiplication operation.
                                                               (
                                                        ′        0                             if  µs[2] = 0
                                                       µ [0] ≡
                                                        s        (µ [0] ×µ [1]) mod µ [2]      otherwise
                                                                    s       s            s
                                                                                                                                 256
                                                       All intermediate calculations of this operation are not subject to the 2     modulo.
                      0x0a   EXP               2   1   Exponential operation.
                                                        ′           µ [1]
                                                       µ [0] ≡ µ [0] s
                                                        s        s
                     0x0b    SIGNEXTEND 2 1 Extend length of two’s complement signed integer.
                                                                              (
                                                                                µ [1]    if  i 6 t  where t = 256−8(µ [0]+1)
                                                                       ′          s   t                                  s
                                                       ∀i ∈ [0..255] : µ [0] ≡
                                                                       s  i     µ [1]    otherwise
                                                                                  s   i
                    µ [x]i gives the ith bit (counting from zero) of µ [x]
                     s                                                 s
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                       EIP-150 REVISION         23
                                                        10s: Comparison & Bitwise Logic Operations
                   Value Mnemonic δ α Description
                     0x10   LT             2   1   Less-than comparision.
                                                           (1 if µ [0] < µ [1]
                                                     ′                s        s
                                                   µ [0] ≡
                                                     s       0   otherwise
                     0x11   GT             2   1   Greater-than comparision.
                                                           (1 if µ [0] > µ [1]
                                                     ′                s        s
                                                   µ [0] ≡
                                                     s       0   otherwise
                     0x12   SLT            2   1   Signed less-than comparision.
                                                           (1 if µ [0] < µ [1]
                                                     ′                s        s
                                                   µ [0] ≡
                                                     s       0   otherwise
                                                   Where all values are treated as two’s complement signed 256-bit integers.
                     0x13   SGT            2   1   Signed greater-than comparision.
                                                           (1 if µ [0] > µ [1]
                                                     ′                s        s
                                                   µ [0] ≡
                                                     s       0   otherwise
                                                   Where all values are treated as two’s complement signed 256-bit integers.
                     0x14   EQ             2   1   Equality comparision.
                                                           (1 if µ [0] = µ [1]
                                                     ′                s        s
                                                   µ [0] ≡
                                                     s       0   otherwise
                     0x15   ISZERO         1   1   Simple not operator.
                                                           (1 if µ [0] = 0
                                                     ′                s
                                                   µ [0] ≡
                                                     s       0   otherwise
                     0x16   AND            2   1   Bitwise AND operation.
                                                   ∀i ∈ [0..255] : µ′[0] ≡ µ [0] ∧ µ [1]
                                                                   s   i    s   i    s  i
                     0x17   OR             2   1   Bitwise OR operation.
                                                   ∀i ∈ [0..255] : µ′[0] ≡ µ [0] ∨ µ [1]
                                                                   s   i    s   i    s  i
                     0x18   XOR            2   1   Bitwise XOR operation.
                                                   ∀i ∈ [0..255] : µ′[0] ≡ µ [0] ⊕ µ [1]
                                                                   s   i    s   i    s  i
                     0x19   NOT            1   1   Bitwise NOT operation.
                                                                           (1 if µ [0]i = 0
                                                   ∀i ∈ [0..255] : µ′[0] ≡           s
                                                                   s   i    0   otherwise
                     0x1a   BYTE           2   1   Retrieve single byte from word.
                                                                           (µ [1](i+8µ [0])  if  i < 8 ∧ µ [0] < 32
                                                   ∀i ∈ [0..255] : µ′[0] ≡    s        s                  s
                                                                   s   i    0                otherwise
                                                   For Nth byte, we count from the left (i.e. N=0 would be the most signiﬁcant in big endian).
                                                     20s: SHA3
                   Value Mnemonic δ α Description
                     0x20   SHA3           2   1   Compute Keccak-256 hash.
                                                     ′
                                                   µ [0] ≡ Keccak(µ [µ [0]...(µ [0]+µ [1]−1)])
                                                     s               m s           s       s
                                                     ′
                                                   µ ≡M(µ,µ [0],µ [1])
                                                     i        i  s      s
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                            EIP-150 REVISION          24
                                                                   30s: Environmental Information
                    Value Mnemonic                  δ   α Description
                      0x30    ADDRESS               0   1   Get address of currently executing account.
                                                              ′
                                                            µ [0] ≡ I
                                                              s       a
                      0x31    BALANCE               1   1   Get balance of the given account.
                                                                     (                                 160
                                                                       σ[µ [0]]    if  σ[µ [0] mod 2      ] 6= ∅
                                                              ′            s   b           s
                                                            µ [0] ≡
                                                              s        0           otherwise
                      0x32    ORIGIN                0   1   Get execution origination address.
                                                              ′
                                                            µ [0] ≡ I
                                                              s       o
                                                            This is the sender of original transaction; it is never an account with non-empty
                                                            associated code.
                      0x33    CALLER                0   1   Get caller address.
                                                              ′
                                                            µ [0] ≡ I
                                                              s       s
                                                            This is the address of the account that is directly responsible for this execution.
                      0x34    CALLVALUE             0   1   Get deposited value by the instruction/transaction responsible for this execution.
                                                              ′
                                                            µ [0] ≡ I
                                                              s       v
                      0x35    CALLDATALOAD 1 1 Getinput data of current environment.
                                                              ′
                                                            µ [0] ≡ I [µ [0]...(µ [0] + 31)]     with   I [x] = 0   if  x>kI k
                                                              s       d   s         s                    d                     d
                                                            This pertains to the input data passed with the message call instruction or transaction.
                      0x36    CALLDATASIZE          0   1   Get size of input data in current environment.
                                                              ′
                                                            µ [0] ≡ kIdk
                                                              s
                                                            This pertains to the input data passed with the message call instruction or transaction.
                      0x37    CALLDATACOPY 3 0 Copyinput data in current environment to memory.
                                                                                             (
                                                                                               I [µ [1] + i]   if  µ [1] +i < kI k
                                                                             ′                  d   s               s            d
                                                            ∀i∈{0...µ [2]−1}µ [µ [0] + i] ≡
                                                                     s       m s               0               otherwise
                                                              ′
                                                            µ ≡M(µ,µ [0],µ [2])
                                                              i        i   s     s
                                                            This pertains to the input data passed with the message call instruction or transaction.
                      0x38    CODESIZE              0   1   Get size of code running in current environment.
                                                              ′
                                                            µ [0] ≡ kIbk
                                                              s
                      0x39    CODECOPY              3   0   Copy code running in current environment to memory.
                                                                                             (
                                                                                               I [µ [1] + i]   if  µ [1] +i < kI k
                                                                             ′                  b   s               s            b
                                                            ∀i∈{0...µ [2]−1}µ [µ [0] + i] ≡
                                                                     s       m s               STOP            otherwise
                                                              ′
                                                            µ ≡M(µ,µ [0],µ [1])
                                                              i        i   s     s
                      0x3a    GASPRICE              0   1   Get price of gas in current environment.
                                                              ′
                                                            µ [0] ≡ I
                                                              s       p
                                                            This is gas price speciﬁed by the originating transaction.
                      0x3b    EXTCODESIZE           1   1   Get size of an account’s code.
                                                              ′                       160
                                                            µ [0] ≡ kσ[µ [0] mod 2       ] k
                                                              s           s               c
                      0x3c    EXTCODECOPY           4   0   Copy an account’s code to memory.
                                                                                             (
                                                                                               c[µ [2] + i]  if  µ [2] +i < kck
                                                                             ′                     s               s
                                                            ∀i∈{0...µ [3]−1}µ [µ [1] + i] ≡
                                                                     s       m s               STOP          otherwise
                                                            where c ≡ σ[µ [0] mod 2160]
                                                                            s               c
                                                              ′
                                                            µ ≡M(µ,µ [1],µ [3])
                                                              i        i   s     s
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION          25
                                                                        40s: Block Information
                    Value Mnemonic            δ   α Description
                      0x40   BLOCKHASH 1 1 Getthehash of one of the 256 most recent complete blocks.
                                                      µ′[0] ≡ P(IH ,µ [0],0)
                                                        s           p   s
                                                      where P is the hash of a block of a particular number, up to a maximum age.
                                                      0 is left on the stack if the looked for block number is greater than the current block number
                                                      or more than 256 blocks behind the current block.
                                                                    
                                                                    
                                                                      0                 if  n>Hi∨a=256∨h=0
                                                      P(h,n,a) ≡ 
                                                                      h                 if  n=H
                                                                                                  i
                                                                    
                                                                      P(Hp,n,a+1) otherwise
                                                      and we assert the header H can be determined as its hash is the parent hash
                                                      in the block following it.
                      0x41   COINBASE         0    1  Get the block’s beneﬁciary address.
                                                      µ′[0] ≡ I
                                                        s       Hc
                      0x42   TIMESTAMP 0 1 Gettheblock’s timestamp.
                                                      µ′[0] ≡ I
                                                        s       Hs
                      0x43   NUMBER           0    1  Get the block’s number.
                                                      µ′[0] ≡ I
                                                        s       Hi
                      0x44   DIFFICULTY       0    1  Get the block’s diﬃculty.
                                                      µ′[0] ≡ I
                                                        s       Hd
                      0x45   GASLIMIT         0    1  Get the block’s gas limit.
                                                      µ′[0] ≡ I
                                                        s       Hl
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                           EIP-150 REVISION          26
                                            50s: Stack, Memory, Storage and Flow Operations
                    Value Mnemonic δ α Description
                      0x50    POP            1    0   Remove item from stack.
                      0x51    MLOAD          1    1   Load word from memory.
                                                       ′
                                                      µ [0] ≡ µ [µ [0]...(µ [0]+31)]
                                                       s        m s           s
                                                       ′
                                                      µ ≡max(µ ,⌈(µ [0]+32)÷32⌉)
                                                       i           i    s
                                                                                            ′                         256
                                                      The addition in the calculation of µ is not subject to the 2        modulo.
                                                                                            i
                      0x52    MSTORE         2    0   Save word to memory.
                                                       ′
                                                      µ [µ [0]...(µ [0]+31)] ≡ µ [1]
                                                       m s            s              s
                                                       ′
                                                      µ ≡max(µ ,⌈(µ [0]+32)÷32⌉)
                                                       i           i    s
                                                                                            ′                         256
                                                      The addition in the calculation of µ is not subject to the 2        modulo.
                                                                                            i
                      0x53    MSTORE8        2    0   Save byte to memory.
                                                       ′
                                                      µ [µ [0]] ≡ (µ [1] mod 256)
                                                       m s            s
                                                       ′
                                                      µ ≡max(µ ,⌈(µ [0]+1)÷32⌉)
                                                       i           i    s
                                                                                            ′                         256
                                                      The addition in the calculation of µ is not subject to the 2        modulo.
                                                                                            i
                      0x54    SLOAD          1    1   Load word from storage.
                                                       ′
                                                      µ [0] ≡ σ[I ] [µ [0]]
                                                       s          a s  s
                      0x55    SSTORE         2    0   Save word to storage.
                                                      σ′[I ] [µ [0]] ≡ µ [1]
                                                          a s  s        s
                                                                        (
                                                                          G         if  µ [1] 6= 0 ∧ σ[I ] [µ [0]] = 0
                                                      C        (σ,µ) ≡      sset          s               a s  s
                                                       SSTORE             G         otherwise
                                                                  (         sreset
                                                                    R         if  µ [1] = 0 ∧ σ[I ] [µ [0]] 6= 0
                                                       ′              sclear       s               a s  s
                                                      A ≡A +
                                                       r      r     0         otherwise
                      0x56    JUMP           1    0   Alter the program counter.
                                                      J     (µ) ≡ µ [0]
                                                       JUMP          s
                                                      This has the eﬀect of writing said value to µ . See section 9.
                                                                                                      pc
                      0x57    JUMPI          2    0   Conditionally alter the program counter.
                                                                    (µ [0]      if  µ [1] 6= 0
                                                      J      (µ) ≡     s              s
                                                       JUMPI          µ +1 otherwise
                                                                       pc
                                                      This has the eﬀect of writing said value to µ . See section 9.
                                                                                                      pc
                      0x58    PC             0    1   Get the value of the program counter prior to the increment
                                                      corresponding to this instruction.
                                                       ′
                                                      µ [0] ≡ µ
                                                       s        pc
                      0x59    MSIZE          0    1   Get the size of active memory in bytes.
                                                       ′
                                                      µ [0] ≡ 32µ
                                                       s          i
                      0x5a    GAS            0    1   Get the amount of available gas, including the corresponding reduction
                                                      for the cost of this instruction.
                                                       ′
                                                      µ [0] ≡ µ
                                                       s        g
                      0x5b    JUMPDEST 0 0 Markavalid destination for jumps.
                                                      This operation has no eﬀect on machine state during execution.
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                       EIP-150 REVISION        27
                                                          60s & 70s: Push Operations
                   Value Mnemonic δ α Description
                     0x60   PUSH1          0   1   Place 1 byte item on stack.
                                                     ′
                                                   µ [0] ≡ c(µ   +1)
                                                     s         pc (
                                                                    I [x]   if x<kI k
                                                   where c(x) ≡      b                b
                                                                    0       otherwise
                                                   The bytes are read in line from the program code’s bytes array.
                                                   The function c ensures the bytes default to zero if they extend past the limits.
                                                   The byte is right-aligned (takes the lowest signiﬁcant place in big endian).
                     0x61   PUSH2          0   1   Place 2-byte item on stack.
                                                     ′                              
                                                   µ [0] ≡ c (µ   +1)...(µ +2)
                                                     s          pc           pc
                                                   with c(x) ≡ (c(x0),...,c(xkxk−1)) with c as deﬁned as above.
                                                   The bytes are right-aligned (takes the lowest signiﬁcant place in big endian).
                      .           .         .   .                                          .
                      .           .         .   .                                          .
                      .           .         .   .                                          .
                     0x7f   PUSH32         0   1   Place 32-byte (full word) item on stack.
                                                     ′                               
                                                   µ [0] ≡ c (µ   +1)...(µ +32)
                                                     s          pc           pc
                                                   where c is deﬁned as above.
                                                   The bytes are right-aligned (takes the lowest signiﬁcant place in big endian).
                                 80s: Duplication Operations
                   Value Mnemonic           δ    α Description
                     0x80   DUP1            1    2   Duplicate 1st stack item.
                                                       ′
                                                     µ [0] ≡ µ [0]
                                                       s       s
                     0x81   DUP2            2    3   Duplicate 2nd stack item.
                                                       ′
                                                     µ [0] ≡ µ [1]
                                                       s       s
                      .           .          .    .               .
                      .           .          .    .               .
                      .           .          .    .               .
                     0x8f   DUP16          16   17   Duplicate 16th stack item.
                                                       ′
                                                     µ [0] ≡ µ [15]
                                                       s       s
                                      90s: Exchange Operations
                   Value Mnemonic           δ    α Description
                     0x90   SWAP1           2    2   Exchange 1st and 2nd stack items.
                                                       ′
                                                     µ [0] ≡ µ [1]
                                                       s       s
                                                       ′
                                                     µ [1] ≡ µ [0]
                                                       s       s
                     0x91   SWAP2           3    3   Exchange 1st and 3rd stack items.
                                                       ′
                                                     µ [0] ≡ µ [2]
                                                       s       s
                                                       ′
                                                     µ [2] ≡ µ [0]
                                                       s       s
                      .           .          .    .                    .
                      .           .          .    .                    .
                      .           .          .    .                    .
                     0x9f   SWAP16         17   17   Exchange 1st and 17th stack items.
                                                       ′
                                                     µ [0] ≡ µ [16]
                                                       s       s
                                                       ′
                                                     µ [16] ≡ µ [0]
                                                       s        s
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                         EIP-150 REVISION          28
                                                               a0s: Logging Operations
                    For all logging operations, the state change is to append an additional log entry on to the substate’s log series:
                     ′
                    A ≡A ·(I ,t,µ [µ [0]...(µ [0]+µ [1]−1)])
                     l     l    a     m s           s       s
                    The entry’s topic series, t, diﬀers accordingly:
                    Value Mnemonic δ α Description
                      0xa0   LOG0           2   0   Append log record with no topics.
                                                    t ≡ ()
                      0xa1   LOG1           3   0   Append log record with one topic.
                                                    t ≡ (µ [2])
                                                           s
                       .           .         .   .                                            .
                       .           .         .   .                                            .
                       .           .         .   .                                            .
                      0xa4   LOG4           6   0   Append log record with four topics.
                                                    t ≡ (µ [2],µ [3],µ [4],µ [5])
                                                           s     s      s     s
                         ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION          29
                                                                     f0s: System operations
                    Value Mnemonic δ α Description
                      0xf0   CREATE          3   1   Create a new account with associated code.
                                                     i ≡ µ [µ [1]...(µ [1]+µ [2]−1)]
                                                          m s        ( s         s
                                                                      Λ(σ∗,I ,I ,L(µ ),I ,µ [0],i,I +1)         if  µ [0] 6 σ[I ]   ∧ I <1024
                                                       ′   ′   +              a o      g   p   s      e              s         a b     e
                                                     (σ ,µ ,A ) ≡
                                                           g            σ,µ ,∅                                  otherwise
                                                                            g
                                                     σ∗ ≡σ except σ∗[I ] =σ[I ] +1
                                                                             a n      a n
                                                      ′          +                   ′          +          ′         +          ′           +
                                                     A ≡A⋒A whichimplies: A ≡A ∪A                    ∧ A ≡A ·A            ∧ A ≡A +A
                                                                                     s     s    s          l     l   l          r     r     r
                                                      ′
                                                     µ [0] ≡ x
                                                      s
                                                     where x = 0 if the code execution for this operation failed due to an exceptional halting
                                                     Z(σ∗,µ,I) = ⊤ or I = 1024
                                                                          e
                                                     (the maximum call depth limit is reached) or µ [0] > σ[Ia] (balance of the caller is too
                                                                                                       s           b
                                                     low to fulﬁl the value transfer); and otherwise x = A(I ,σ[I ] ), the address of the newly
                                                                                                              a     a n
                                                     created account, otherwise.
                                                      ′
                                                     µ ≡M(µ,µ [1],µ [2])
                                                      i         i  s     s
                                                     Thus the operand order is: value, input oﬀset, input size.
                      0xf1   CALL            7   1   Message-call into an account.
                                                     i ≡ µ [µ [3]...(µ [3]+µ [4]−1)]
                                                          m s         s         s
                                                                       Θ(σ,I ,I ,t,t,                                   if  µ [2] 6 σ[I ] ∧
                                                                               a   o                                         s         a b
                                                       ′  ′   +
                                                     (σ ,g ,A ,o) ≡         C         (µ),I ,µ [2],µ [2],i,I +1)              I <1024
                                                                             CALLGAS       p   s     s       e                e
                                                                      
                                                                        (σ,g,∅,o)                                      otherwise
                                                     n≡min({µ [6],|o|})
                                                                 s
                                                      ′
                                                     µ [µ [5]...(µ [5]+n−1)] = o[0...(n−1)]
                                                      m s           s
                                                      ′           ′
                                                     µ ≡µ +g
                                                      g     g
                                                      ′
                                                     µ [0] ≡ x
                                                      s
                                                      ′          +
                                                     A ≡A⋒A           160
                                                     t ≡ µ [1] mod 2
                                                          s
                                                     where x = 0 if the code execution for this operation failed due to an exceptional halting
                                                     Z(σ,µ,I) = ⊤ or if
                                                     µ [2] > σ[I ] (not enough funds) or I = 1024 (call depth limit reached); x = 1
                                                      s         a b                          e
                                                     otherwise.
                                                      ′
                                                     µ ≡M(M(µ,µ [3],µ [4]),µ [5],µ [6])
                                                      i            i   s     s      s      s
                                                     Thus the operand order is: gas, to, value, in oﬀset, in size, out oﬀset, out size.
                                                     CCALL(σ,µ) ≡ CGASCAP(σ,µ)+CEXTRA(σ,µ)
                                                                        (
                                                                          CGASCAP(σ,µ)+G                   if  µ [2] 6= 0
                                                     C         (σ,µ) ≡                         callstipend      s
                                                      CALLGAS             C        (σ,µ)                   otherwise
                                                                       ( GASCAP
                                                                         min{L(µ −CEXTRA(σ,µ)),µ [0]} if µ ≥CEXTRA(σ,µ)
                                                     C        (σ,µ) ≡              g                     s            g
                                                      GASCAP             µ [0]                                  otherwise
                                                                           s
                                                     CEXTRA(σ,µ) ≡ Gcall +CXFER(µ)+CNEW(σ,µ)
                                                                  (G            if  µ [2] 6= 0
                                                     C     (µ) ≡      callvalue       s
                                                      XFER          0           otherwise
                                                                    (                                    160
                                                                      G              if  σ[µ [1] mod 2      ] = ∅
                                                     C     (σ,µ) ≡      newaccount           s
                                                      NEW             0              otherwise
                      0xf2   CALLCODE 7 1 Message-call into this account with an alternative account’s code.
                                                     Exactly equivalent to CALL except:
                                                                             ∗
                                                                       Θ(σ ,I ,I ,I ,t,                                 if  µ [2] 6 σ[I ] ∧
                                                                                a   o  a                                     s         a b
                                                       ′  ′   +
                                                     (σ ,g ,A ,o) ≡         C         (µ),I ,µ [2],µ [2],i,I +1)              I <1024
                                                                             CALLGAS       p   s     s       e                e
                                                                      
                                                                        (σ,g,∅,o)                                      otherwise
                                                     Note the change in the fourth parameter to the call Θ from the 2nd stack value µ [1]
                                                                                                                                           s
                                                     (as in CALL) to the present address I . This means that the recipient is in fact the
                                                                                            a
                                                     same account as at present, simply that the code is overwritten.
                      0xf3   RETURN          2   0   Halt execution returning output data.
                                                     H        (µ) ≡ µ [µ [0]...(µ [0]+µ [1]−1)]
                                                       RETURN          m s           s       s
                                                     This has the eﬀect of halting the execution at this point with output deﬁned.
                                                     See section 9.
                                                      ′
                                                     µ ≡M(µ,µ [0],µ [1])
                                                      i         i  s     s
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                            EIP-150 REVISION          30
                    0xf4    DELEGATECALL 6 1 Message-call into this account with an alternative account’s code, but persisting
                                                         the current values for sender and value.
                                                         Compared with CALL, DELEGATECALL takes one fewer arguments. The omitted
                                                         argument is µ [2]. As a result, µ [3], µ [4], µ [5] and µ [6] in the deﬁnition of CALL
                                                                        s                    s      s      s          s
                                                         should respectively be replaced with µ [2], µ [3], µ [4] and µ [5].
                                                                                                   s      s      s          s
                                                         Otherwise exactly equivalent to CALL except:
                                                                                  ∗
                                                                            Θ(σ ,Is,Io,Ia,t,
                                                                                                             if  I 6σ[I ] ∧ I <1024
                                                            ′  ′   +                                               v       a b     e
                                                         (σ ,g ,A ,o) ≡          µ [0],I ,0,I ,i,I +1)
                                                                                  s     p    v     e
                                                                           
                                                                             (σ,g,∅,o)                        otherwise
                                                         Note the changes (in addition to that of the fourth parameter) to the second
                                                         and ninth parameters to the call Θ.
                                                         This means that the recipient is in fact the same account as at present, simply
                                                         that the code is overwritten and the context is almost entirely identical.
                     0xﬀ    SUICIDE              1   0   Halt execution and register account for later deletion.
                                                           ′
                                                         A ≡A ∪{I }
                                                           s     s     a
                                                           ′              160                     160
                                                         σ[µ [0] mod 2       ]  ≡σ[µ [0] mod 2        ] +σ[Ia]
                                                              s               b       s               b         b
                                                         σ′[Ia] ≡ 0
                                                               b     (
                                                                       R          if  I ∈/ A
                                                           ′             suicide       a     s
                                                         A ≡A +
                                                           r     r     0          otherwise
                                                                                        (                                    160
                                                                                          G              if  σ[µ [1] mod 2      ] = ∅
                                                         C        (σ,µ) ≡ G          +      newaccount           s
                                                           SUICIDE            suicide     0              otherwise
                                                                Appendix I. Genesis Block
                   The genesis block is 15 items, and is speciﬁed thus:
                                                                               17                                              
                (226)          0    , KEC RLP ()   , 0  , stateRoot,0,0,0      , 2  , 0, 0, 3141592,time,0,0    , KEC (42)   , (), ()
                                 256                 160                   2048                              256
                   Where0       refers to the parent hash, a 256-bit hash which is all zeroes; 0     refers to the beneﬁciary address, a 160-bit
                            256                                                                  160
                                                                                                    17
                hash which is all zeroes; 0      refers to the log bloom, 2048-bit of all zeros; 2     refers to the diﬃculty; the transaction
                                            2048
                trie root, receipt trie root, gas used, block number and extradata are both 0, being equivalent to the empty byte array.
                                                                                                                    
                The sequences of both ommers and transactions are empty and represented by (). KEC (42) refers to the Keccak hash
                                                                                                                              
                of a byte array of length one whose ﬁrst and only byte is of value 42, used for the nonce. KEC RLP ()             value refers to
                the hash of the ommer lists in RLP, both empty lists.
                   The proof-of-concept series include a development premine, making the state root hash some value stateRoot. Also
                time will be set to the intial timestamp of the genesis block. The latest documentation should be consulted for those
                values.
                                                                     Appendix J. Ethash
                J.1. Deﬁnitions. We employ the following deﬁnitions:
                    Name              Value   Description
                    Jwordbytes            4   Bytes in word.
                                          30
                    Jdatasetinit        2     Bytes in dataset at genesis.
                                          23
                    Jdatasetgrowth      2     Dataset growth per epoch.
                                          24
                    Jcacheinit          2     Bytes in cache at genesis.
                                          17
                    Jcachegrowth        2     Cache growth per epoch.
                    Jepoch            30000   Blocks per epoch.
                    Jmixbytes           128   mix length in bytes.
                    Jhashbytes           64   Hash length in bytes.
                    Jparents            256   Number of parents of each dataset element.
                    Jcacherounds          3   Number of rounds in cache production.
                    Jaccesses            64   Number of accesses in hashimoto loop.
                J.2. Size of dataset and cache. The size for Ethash’s cache c ∈ B and dataset d ∈ B depend on the epoch, which in
                turn depends on the block number.
                (227)                                               E      (Hi) =  Hi 
                                                                      epoch          J
                                                                                      epoch
                The size of the dataset growth by Jdatasetgrowth bytes, and the size of the cache by Jcachegrowth bytes, every epoch. In
                order to avoid regularity leading to cyclic behavior, the size must be a prime number. Therefore the size is reduced by
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                            EIP-150 REVISION          31
                a multiple of J         , for the dataset, and J           for the cache. Let d      =kdk be the size of the dataset. Which
                                mixbytes                         hashbytes                       size
                is calculated using
                (228)                    d     =E        (J           +J               · E      −J          , J        )
                                          size     prime   datasetinit    datasetgrowth   epoch     mixbytes   mixbytes
                The size of the cache, c     , is calculated using
                                         size
                (229)                     c    =E        (J          +J              · E      −J           , J        )
                                           size     prime   cacheinit    cachegrowth    epoch    hashbytes   hashbytes
                (230)                                E       (x,y) = (x                        if  x/y ∈ P
                                                       prime            E      (x−1·y,y) otherwise
                                                                          prime
                J.3. Dataset generation. In order the generate the dataset we need the cache c, which is an array of bytes. It depends
                on the cache size c     and the seed hash s ∈ B .
                                    size                           32
                J.3.1. Seed hash. The seed hash is diﬀerent for every epoch. For the ﬁrst epoch it is the Keccak-256 hash of a series of
                32 bytes of zeros. For every other epoch it is always the Keccak-256 hash of the previous seed hash:
                (231)                                                  s = Cseedhash(Hi)
                                                              (
                                                                KEC(0 )                          if  E      (H ) = 0
                (232)                       C         (H ) =          32                              epoch    i
                                              seedhash   i      KEC(C          (H −J        ))   otherwise
                                                                       seedhash   i    epoch
                With 032 being 32 bytes of zeros.
                J.3.2. Cache. The cache production process involves using the seed hash to ﬁrst sequentially ﬁlling up c                 bytes of
                                                                                                                                    size
                memory, then performing Jcacherounds passes of the RandMemoHash algorithm created by Lerner [2014]. The intial
                        ′
                cache c , being an array of arrays of single bytes, will be constructed as follows.
                   Wedeﬁne the array c , consisting of 64 single bytes, as the ith element of the intial cache:
                                          i                          (
                (233)                                          c = KEC512(s)           if  i = 0
                                                                 i     KEC512(c     )  otherwise
                                                                                i−1
                Therefore c′ can be deﬁned as
                                                                       ′
                (234)                                                 c [i] = ci  ∀ i<n
                                                                                c      
                (235)                                                  n=         size
                                                                              Jhashbytes
                The cache is calculated by performing Jcacherounds rounds of the RandMemoHash algorithm to the inital cache c′:
                (236)                                          c = E             (c′,J           )
                                                                     cacherounds      cacherounds
                                                                    
                                                                    
                                                                       x                                 if  y = 0
                (237)                         Ecacherounds(x,y) = E         (x)                         if  y = 1
                                                                     RMH
                                                                    E              (E     (x),y −1)     otherwise
                                                                        cacherounds    RMH
                Where a single round modiﬁes each subset of the cache as follows:
                                                                                                             
                (238)                              E     (x) = E      (x,0),E      (x,1),...,E     (x,n−1)
                                                    RMH           rmh          rmh             rmh
                                                 ′                          ′  ′
                (239)   Ermh(x,i) = KEC512(x [(i−1+n) mod n]⊕x [x [i][0] mod n])
                                                                                              ′                  ′
                                                                                     with   x =x except x[j]=E               (x,j)   ∀ j <i
                                                                                                                         rmh
                J.3.3. Full dataset calculation. Essentially, we combine data from Jparents pseudorandomly selected cache nodes, and
                hash that to compute the dataset. The entire dataset is then generated by a number of items, each Jhashbytes bytes in
                size:                                                                                  
                                                                                                d
                (240)                                   d[i] = E            (c,i)  ∀ i<          size
                                                                 datasetitem                 J
                                                                                              hashbytes
                In order to calculate the single item we use an algorithm inspired by the FNV hash (Glenn Fowler [1991]) in some cases
                as a non-associative substitute for XOR.
                                                                                                        32
                (241)                                  E     (x,y) = (x·(0x01000193⊕y)) mod 2
                                                         FNV
                The single item of the dataset can now be calculated as:
                (242)                                      E            (c,i) = E        (c,i,−1,∅)
                                                             datasetitem          parents
                                                          (E         (c,i,p +1,E      (m,c,i,p+1)) if p<J                 −2
                (243)              E        (c,i,p,m) =       parents             mix                              parents
                                    parents                 E    (m,c,i,p+1)                             otherwise
                                                              mix
                          ETHEREUM: A SECURE DECENTRALISED GENERALISED TRANSACTION LEDGER                          EIP-150 REVISION          32
                                              (
                                                KEC512(c[i   mod c     ] ⊕ i)                                                  if  p = 0
               (244)      E     (m,c,i,p) =                         size                                                    
                            mix                 E     m,c[E      (i ⊕ p,m[p    mod ⌊J           /J         ⌋])   mod c     ]   otherwise
                                                 FNV          FNV                      hashbytes  wordbytes            size
               J.4. Proof-of-work function. Essentially, we maintain a ”mix” Jmixbytes bytes wide, and repeatedly sequentially fetch
               J          bytes from the full dataset and use the E       function to combine it with the mix. J           bytes of sequential
                 mixbytes                                            FNV                                          mixbytes
               access are used so that each round of the algorithm always fetches a full page from RAM, minimizing translation lookaside
               buﬀer misses which ASICs would theoretically be able to avoid.
                   If the output of this algorithm is below the desired target, then the nonce is valid. Note that the extra application
               of KEC at the end ensures that there exists an intermediate nonce which can be provided to prove that at least a small
               amount of work was done; this quick outer PoW veriﬁcation can be used for anti-DDoS purposes. It also serves to
               provide statistical assurance that the result is an unbiased, 256 bit number.
                   The PoW-function returns an array with the compressed mix as its ﬁrst item and the Keccak-256 hash of the
               concatenation of the compressed mix with the seed hash as the second item:
               (245)
                PoW(H ,H ,d)={m (KEC(RLP(L (H ))),H ,d),KEC(s (KEC(RLP(L (H ))),H )+m (KEC(RLP(L (H ))),H ,d))}
                       n    n          c            H    n       n          h             H   n       n      c            H    n       n
               With H being the hash of the header without the nonce. The compressed mix m is obtained as follows:
                        n                                                                              c
                                                                                  nmix
               (246)                       m(h,n,d)=E               (E        (d, X s (h,n),s (h,n),−1),−4)
                                             c              compress   accesses         h         h
                                                                                   i=0
                   The seed hash being:
               (247)                                         s (h,n) = KEC512(h+E            (n))
                                                              h                        revert
               E       (n) returns the reverted bytes sequence of the nonce n:
                 revert
               (248)                                             E       (n)[i] = n[knk −i]
                                                                   revert
               Wenote that the “+”-operator between two byte sequences results in the concatenation of both sequences.
                   The dataset d is obtained as described in section J.3.3.
                   The number of replicated sequences in the mix is:
               (249)                                                n     =Jmixbytes 
                                                                     mix      J
                                                                               hashbytes
               In order to add random dataset nodes to the mix, the E               function is used:
                                                         (                 accesses
                                                           E           (d,m,s,i)                        if i = Jaccesses − 2
               (250)             E         (d,m,s,i) =      mixdataset
                                   accesses                E        (E           (d,m,s,i),s,i+1) otherwise
                                                            accesses   mixdataset
               (251)                               E           (d,m,s,i) = E       (m,E         (d,m,s,i)
                                                     mixdataset                FNV       newdata
               E          returns an array with n      elements:
                 newdata                           mix
               (252)                                                                                           
                                                                         J                       d    /J
                E        (d,m,s,i)[j] = d[E       (i ⊕ s[0],m[i  mod       mixbytes  ])  mod      size  hashbytes   · n   +j] ∀ j<n
                 newdata                      FNV                        J                            n               mix                  mix
                                                                          wordbytes                     mix
               The mix is compressed as follows:
               (253)                   (
                   E         (m,i) =     m                                                                                if  i > kmk−8
                     compress            E         (E    (E     (E     (m[i+4],m[i+5]),m[i+6]),m[i+7]),i+8) otherwise
                                          compress    FNV   FNV    FNV
