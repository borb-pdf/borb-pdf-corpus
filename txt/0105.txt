                                           Meltdown: ReadingKernelMemoryfromUserSpace
                                                            1                            1                     1                           2
                                           Moritz Lipp , Michael Schwarz , Daniel Gruss , Thomas Prescher ,
                                                                   2                     3                 4                         1
                                                 Werner Haas , Anders Fogh , Jann Horn , Stefan Mangard ,
                                                               5                        6,9                     7                        8
                                              Paul Kocher , Daniel Genkin                  , Yuval Yarom , Mike Hamburg
                                                1Graz University of Technology, 2Cyberus Technology GmbH,
                                                      3G-Data Advanced Analytics, 4Google Project Zero,
                                               5Independent (www.paulkocher.com), 6University of Michigan,
                                    7University of Adelaide & Data61, 8Rambus, Cryptography Research Division
                      Abstract                                                                 sor bit of the processor that deﬁnes whether a memory
                      The security of computer systems fundamentally relies                    page of the kernel can be accessed or not. The basic
                      on memory isolation, e.g., kernel address ranges are                     idea is that this bit can only be set when entering kernel
                      marked as non-accessible and are protected from user                     code and it is cleared when switching to user processes.
                      access. In this paper, we present Meltdown. Meltdown                     This hardware feature allows operating systems to map
                      exploits side effects of out-of-order execution on mod-                  the kernel into the address space of every process and
                      ern processors to read arbitrary kernel-memory locations                 to have very efﬁcient transitions from the user process
                      including personal data and passwords.              Out-of-order         to the kernel, e.g., for interrupt handling. Consequently,
                      execution is an indispensable performance feature and                    in practice, there is no change of the memory mapping
                      present in a wide range of modern processors. The attack                 whenswitching from a user process to the kernel.
                                                                                                                                             10
                      is independent of the operating system, and it does not                     In this work, we present Meltdown . Meltdown is
                      rely on any software vulnerabilities. Meltdown breaks                    a novel attack that allows overcoming memory isolation
                      all security guarantees provided by address space isola-                 completely by providing a simple way for any user pro-
                      tion as well as paravirtualized environments and, thus,                  cess to read the entire kernel memory of the machine it
                      every security mechanism building upon this foundation.                  executes on, including all physical memory mapped in
                      Onaffected systems, Meltdown enables an adversary to                     the kernel region. Meltdown does not exploit any soft-
                      read memory of other processes or virtual machines in                    ware vulnerability, i.e., it works on all major operating
                      the cloud without any permissions or privileges, affect-                 systems. Instead, Meltdown exploits side-channel infor-
                      ing millions of customers and virtually every user of a                  mation available on most modern processors, e.g., mod-
                      personal computer. We show that the KAISER defense                       ern Intel microarchitectures since 2010 and potentially
                      mechanism for KASLR has the important (but inadver-                      onother CPUs of other vendors.
                      tent) side effect of impeding Meltdown. We stress that                      While side-channel attacks typically require very spe-
                      KAISERmustbedeployedimmediatelytopreventlarge-                           ciﬁc knowledge about the target application and are tai-
                      scale exploitation of this severe information leakage.                   lored to only leak information about its secrets, Melt-
                                                                                               down allows an adversary who can run code on the vul-
                      1    Introduction                                                        nerable processor to obtain a dump of the entire kernel
                                                                                               address space, including any mapped physical memory.
                                                                                               The root cause of the simplicity and strength of Melt-
                      A central security feature of today’s operating systems                  downaresideeffects caused by out-of-order execution.
                      is memory isolation. Operating systems ensure that user                     Out-of-order execution is an important performance
                      programs cannot access each other’s memory or kernel                     feature of today’s processors in order to overcome laten-
                      memory. Thisisolationisacornerstoneofourcomputing                        cies of busy execution units, e.g., a memory fetch unit
                      environmentsandallowsrunningmultipleapplicationsat                       needs to wait for data arrival from memory. Instead of
                      the sametimeonpersonaldevicesorexecutingprocesses                        stalling the execution, modern processors run operations
                      of multiple users on a single machine in the cloud.
                         Onmodern processors, the isolation between the ker-                     10Using the practice of responsible disclosure, disjoint groups of au-
                      nel and user processes is typically realized by a supervi-               thors of this paper provided preliminary versions of our results to par-
                                                                                               tially overlapping groups of CPU vendors and other affected compa-
                         9Workwaspartially done while the author was afﬁliated to Univer-      nies. In coordination with industry, the authors participated in an em-
                      sity of Pennsylvania and University of Maryland.                         bargo of the results. Meltdown is documented under CVE-2017-5754.
                   out-of-order i.e., they look ahead and schedule subse-         Linux, and OS X) implemented variants of KAISER and
                   quentoperationstoidleexecutionunitsofthecore. How-             recently rolled out these patches.
                   ever, such operations often have unwanted side-effects,          Meltdown is distinct from the Spectre Attacks [40] in
                   e.g., timing differences [55, 63, 23] can leak information     several ways, notably that Spectre requires tailoring to
                   from both sequential and out-of-order execution.               the victim process’s software environment, but applies
                      Fromasecurityperspective, one observation is partic-        morebroadly to CPUs and is not mitigated by KAISER.
                   ularly signiﬁcant: vulnerable out-of-order CPUs allow
                   an unprivileged process to load data from a privileged         Contributions.    Thecontributions of this work are:
                   (kernel or physical) address into a temporary CPU regis-       1. We describe out-of-order execution as a new, ex-
                   ter. Moreover, the CPU even performs further computa-              tremely powerful, software-based side channel.
                   tions based on this register value, e.g., access to an array   2. We show how out-of-order execution can be com-
                   based on the register value. By simply discarding the              bined with a microarchitectural covert channel to
                   results of the memory lookups (e.g., the modiﬁed regis-            transfer the data from an elusive state to a receiver
                   ter states), if it turns out that an instruction should not        onthe outside.
                   have been executed, the processor ensures correct pro-         3. We present an end-to-end attack combining out-of-
                   gram execution. Hence, on the architectural level (e.g.,           order execution with exception handlers or TSX, to
                   the abstract deﬁnition of how the processor should per-            read arbitrary physical memory without any permis-
                   form computations) no security problem arises.                     sions or privileges, on laptops, desktop machines,
                      However, we observed that out-of-order memory                   mobile phones and on public cloud machines.
                   lookups inﬂuence the cache, which in turn can be de-           4. We evaluate the performance of Meltdown and the
                   tected through the cache side channel. As a result, an             effects of KAISER on it.
                   attacker can dump the entire kernel memory by reading
                   privileged memory in an out-of-order execution stream,         Outline.   The remainder of this paper is structured as
                   and transmit the data from this elusive state via a mi-        follows: In Section 2, we describe the fundamental prob-
                   croarchitectural covert channel (e.g., Flush+Reload) to        lem which is introduced with out-of-order execution. In
                   the outside world. On the receiving end of the covert          Section 3, we provide a toy example illustrating the side
                   channel, the register value is reconstructed. Hence, on        channelMeltdownexploits. InSection4,wedescribethe
                   themicroarchitecturallevel(e.g.,theactualhardwareim-           building blocks of Meltdown. We present the full attack
                   plementation), there is an exploitable security problem.       in Section 5. In Section 6, we evaluate the performance
                      Meltdown breaks all security guarantees provided by         of the Meltdown attack on several different systems and
                   the CPU’s memory isolation capabilities. We evaluated          discuss its limitations. In Section 7, we discuss the ef-
                   the attack on modern desktop machines and laptops, as          fects of the software-based KAISERcountermeasureand
                   well as servers in the cloud. Meltdown allows an unpriv-       propose solutions in hardware. In Section 8, we discuss
                   ileged process to read data mapped in the kernel address       related work and conclude our work in Section 9.
                   space, including the entire physical memory on Linux,
                   Android and OS X, and a large fraction of the physi-
                   cal memory on Windows. This may include the physical           2   Background
                   memory of other processes, the kernel, and in the case
                   of kernel-sharing sandbox solutions (e.g., Docker, LXC)        In this section, we provide background on out-of-order
                   or Xen in paravirtualization mode, the memory of the           execution, address translation, and cache attacks.
                   kernel (or hypervisor), and other co-located instances.
                   While the performance heavily depends on the speciﬁc           2.1    Out-of-order execution
                   machine,e.g.,processorspeed,TLBandcachesizes,and
                   DRAMspeed, we can dump arbitrary kernel and physi-             Out-of-order execution is an optimization technique that
                   cal memorywith3.2KB/sto503KB/s. Hence,anenor-                  allows maximizing the utilization of all execution units
                   mousnumberofsystemsareaffected.                                of a CPU core as exhaustive as possible. Instead of pro-
                      ThecountermeasureKAISER[20],developedinitially              cessing instructions strictly in the sequential program or-
                   to prevent side-channel attacks targeting KASLR, inad-         der, the CPU executes them as soon as all required re-
                   vertently protects against Meltdown as well. Our evalu-        sources are available. While the execution unit of the
                   ation shows that KAISER prevents Meltdown to a large           current operation is occupied, other execution units can
                   extent. Consequently, we stress that it is of utmost im-       run ahead. Hence, instructions can be run in parallel as
                   portancetodeployKAISERonalloperatingsystemsim-                 long as their results follow the architectural deﬁnition.
                   mediately. Fortunately, during a responsible disclosure          In practice, CPUs supporting out-of-order execution
                   window, the three major operating systems (Windows,            allow running operations speculatively to the extent that
                                                                                        ITLB               bus(CDB).Ifanoperandisnotavailable,thereservation
                                                             L1Instruction Cache                           unit can listen on the CDB until it is available and then
                                                                                                           directly begin the execution of the instruction.
                                         Branch               Instruction Fetch & PreDecode                   On the Intel architecture, the pipeline consists of the
                                        Predictor                   Instruction Queue                      front-end, the execution engine (back-end) and the mem-
                                                                                                           ory subsystem [32]. x86 instructions are fetched by the
                               Frontend µOPCache                     4-WayDecode                           front-endfrommemoryanddecodedtomicro-operations
                                              µOPs                µOP    µOP     µOP    µOP                (µOPs)whicharecontinuously sent to the execution en-
                                                               MUX                                         gine. Out-of-order execution is implemented within the
                                                        Allocation Queue                                   execution engine as illustrated in Figure 1. The Reorder
                                                       µOP    µOP     µOP    µOP                           Buffer is responsible for register allocation, register re-
                                                                                                           naming and retiring. Additionally, other optimizations
                           CDB                           Reorder buffer                                    like move elimination or the recognition of zeroing id-
                                        µOP     µOP    µOP    µOP     µOP    µOP    µOP    µOP             ioms are directly handled by the reorder buffer.                       The
                                                            Scheduler                                      µOPs are forwarded to the Uniﬁed Reservation Station
                              Engine    µOP     µOP    µOP    µOP     µOP    µOP    µOP    µOP             (Scheduler) that queues the operations on exit ports that
                                        .      .       .                                                   are connected to Execution Units. Each execution unit
                                        .      .       .
                                        .      .       .                            data
                                                                     data    data          GU              can perform different tasks like ALU operations, AES
                                                       ect,   Branch                       A
                              ecution   AES,   FMA,    V             Load    Load   Store                  operations, address generation units (AGU) or memory
                                        ALU,   ALU,    ALU,   ALU,                                         loads and stores. AGUs, as well as load and store execu-
                              Ex                                                                           tion units, are directly connected to the memory subsys-
                                           Execution Units                                                 temtoprocess its requests.
                                                                                                              Since CPUs usually do not run linear instruction
                                    LoadBuffer   Store Buffer                                              streams, they have branch prediction units that are used
                                                                                                           to obtain an educated guess of which instruction is ex-
                                       L1DataCache      DTLB                 STLB                          ecuted next. Branch predictors try to determine which
                              MemorySubsystem                              L2Cache                         direction of a branch is taken before its condition is ac-
                                                                                                           tually evaluated. Instructions that lie on that path and do
                         Figure1: SimpliﬁedillustrationofasinglecoreoftheIn-                               not have any dependencies can be executed in advance
                         tel’s Skylake microarchitecture. Instructions are decoded                         and their results immediately used if the prediction was
                         into µOPsandexecutedout-of-orderintheexecutionen-                                 correct. If the prediction was incorrect, the reorder buffer
                         gine by individual execution units.                                               allows to rollback to a sane state by clearing the reorder
                                                                                                           buffer and re-initializing the uniﬁed reservation station.
                                                                                                              Therearevariousapproachestopredictabranch: With
                                                                                                           static branch prediction [28], the outcome is predicted
                         the processor’s out-of-order logic processes instructions                         solely based on the instruction itself. Dynamic branch
                         before the CPU is certain that the instruction will be                            prediction [8] gathers statistics at run-time to predict the
                         needed and committed. In this paper, we refer to spec-                            outcome. One-level branch prediction uses a 1-bit or 2-
                         ulative execution in a more restricted meaning, where it                          bit counter to record the last outcome of a branch [45].
                         refers to an instruction sequence following a branch, and                         Modern processors often use two-level adaptive predic-
                         use the term out-of-order execution to refer to any way                           tors [64] with a history of the last n outcomes, allowing to
                         of getting an operation executed before the processor has                         predict regularly recurring patterns. More recently, ideas
                         committed the results of all prior instructions.                                  to use neural branch prediction [62, 38, 60] have been
                            In 1967, Tomasulo [61] developed an algorithm that                             picked up and integrated into CPU architectures [9].
                         enabled dynamic scheduling of instructions to allow out-
                         of-order execution. Tomasulo [61] introduced a uniﬁed                             2.2      Address Spaces
                         reservation station that allows a CPU to use a data value
                         as it has been computed instead of storing it in a reg-                           To isolate processes from each other, CPUs support vir-
                         ister and re-reading it. The reservation station renames                          tual address spaces where virtual addresses are translated
                         registers to allow instructions that operate on the same                          to physical addresses. A virtual address space is divided
                         physicalregisters to use the last logical one to solve read-                      into a set of pages that can be individually mapped to
                         after-write (RAW), write-after-read (WAR) and write-                              physical memory through a multi-level page translation
                         after-write (WAW) hazards. Furthermore, the reserva-                              table.     The translation tables deﬁne the actual virtual
                         tion unit connects all execution units via a common data                          to physical mapping and also protection properties that
                    0                                                       max      data structures. However, side-channel attacks allow to
                                          Physical memory                            detect the exact location of kernel data structures [21, 29,
                                                                                     37] or derandomize ASLR in JavaScript [16]. A com-
                                                                                     bination of a software bug and the knowledge of these
                                User                         Kernel                  addresses can lead to privileged code execution.
                    0                         47  −247                      −1
                                              2
                    Figure 2: The physical memory is directly mapped in the          2.3    CacheAttacks
                    kernelatacertainoffset. Aphysicaladdress(blue)which              In order to speed-up memory accesses and address trans-
                    is mapped accessible to the user space is also mapped in         lation, the CPU contains small memory buffers, called
                    the kernel space through the direct mapping.                     caches, that store frequently used data. CPU caches hide
                                                                                     slow memory access latencies by buffering frequently
                                                                                     used data in smaller and faster internal memory. Mod-
                    are used to enforce privilege checks, such as readable,          ern CPUs have multiple levels of caches that are either
                    writable, executable and user-accessible. The currently          private per core or shared among them. Address space
                    used translation table is held in a special CPU register.        translation tables are also stored in memory and, thus,
                    On each context switch, the operating system updates             also cached in the regular caches.
                    this register with the next process’ translation table ad-          Cache side-channel attacks exploit timing differences
                    dress in order to implement per-process virtual address          that are introduced by the caches. Different cache attack
                    spaces. Because of that, each process can only reference         techniques have been proposed and demonstrated in the
                    data that belongs to its virtual address space. Each vir-        past, including Evict+Time [55], Prime+Probe [55, 56],
                    tual address space itself is split into a user and a kernel      and Flush+Reload [63]. Flush+Reload attacks work on
                    part. While the user address space can be accessed by the        a single cache line granularity. These attacks exploit the
                    runningapplication, the kernel address space can only be         shared, inclusive last-level cache. An attacker frequently
                    accessed if the CPU is running in privileged mode. This          ﬂushes a targeted memory location using the clflush
                    is enforced by the operating system disabling the user-          instruction. By measuring the time it takes to reload the
                    accessible property of the corresponding translation ta-         data, the attacker determines whether data was loaded
                    bles. The kernel address space does not only have mem-           into the cache by another process in the meantime. The
                    ory mapped for the kernel’s own usage, but it also needs         Flush+Reloadattackhasbeenusedforattacksonvarious
                    to perform operations on user pages, e.g., ﬁlling them           computations, e.g., cryptographic algorithms [63, 36, 4],
                    with data. Consequently, the entire physical memory is           web server function calls [65], user input [23, 47, 58],
                    typically mapped in the kernel. On Linux and OS X, this          and kernel addressing information [21].
                    is done via a direct-physical map, i.e., the entire physi-          Aspecial use case of a side-channel attack is a covert
                    cal memory is directly mapped to a pre-deﬁned virtual            channel. Here the attacker controls both, the part that in-
                    address (cf. Figure 2).                                          duces the side effect, and the part that measures the side
                      Instead of a direct-physical map, Windows maintains            effect. This can be used to leak information from one
                    a multiple so-called paged pools, non-paged pools, and           security domain to another, while bypassing any bound-
                    the system cache. These pools are virtual memory re-             aries existing on the architectural level or above. Both
                    gionsinthekerneladdressspacemappingphysicalpages                 Prime+Probe and Flush+Reload have been used in high-
                    to virtual addresses which are either required to remain         performance covert channels [48, 52, 22].
                    in the memory(non-pagedpool)orcanberemovedfrom
                    the memory because a copy is already stored on the disk          3    AToyExample
                    (paged pool). The system cache further contains map-
                    pings of all ﬁle-backed pages. Combined, these memory            In this section, we start with a toy example, i.e., a simple
                    pools will typically map a large fraction of the physical        codesnippet, to illustrate that out-of-order execution can
                    memoryintothekernel address space of every process.              change the microarchitectural state in a way that leaks
                      The exploitation of memory corruption bugs often re-           information. However, despite its simplicity, it is used as
                    quires knowledge of addresses of speciﬁc data. In or-            a basis for Section 4 and Section 5, where we show how
                    der to impede such attacks, address space layout ran-            this change in state can be exploited for an attack.
                    domization (ASLR) has been introduced as well as non-               Listing 1 shows a simple code snippet ﬁrst raising an
                    executable stacks and stack canaries.       To protect the       (unhandled) exception and then accessing an array. The
                    kernel, kernel ASLR (KASLR) randomizes the offsets               property of an exception is that the control ﬂow does not
                    where drivers are located on every boot, making attacks          continue with the code after the exception, but jumps to
                    harder as they now require to guess the location of kernel       anexceptionhandlerintheoperatingsystem. Regardless
                                 1  raise_exception();
                                 2  // the line below is never reached                                                              time   500
                                 3  access(probe_array[data * 4096]);                                                                      400
                                                                                                                                        ycles]300
                             Listing 1: A toy example to illustrate side-effects of out-                                                [c 200
                                                                                                                                    Access
                             of-order execution.                                                                                                0            50          100           150          200          250
                                                                                                                                                                                Page
                                                                             <instr.>                                          Figure 4: Even if a memory location is only accessed
                                                                             <instr.>                D
                                                                                                     E                         during out-of-order execution, it remains cached. Iterat-
                                                                                    .                T
                                                                                    .                U
                                                                                    .                C
                                                                                                     E                         ingoverthe256pagesofprobe arrayshowsonecache
                                          EXCEPTION                                                  X
                                            HANDLER                          <instr.>                E                         hit, exactly on the page that was accessed during the out-
                                           <instr.>                          [ Exception ]
                                                                                                     D                         of-order execution.
                                           <instr.>                          <instr.>                E F  R
                                                                                                     T O  E
                                          [ Terminate ]                      <instr.>                U T  D
                                                                                                     C U  R
                                                                                                     E O  O
                                                                             <instr.>                X
                                                                                                     E
                                                                                                                                   Basedonthevalueofdatainthisexample,adifferent
                             Figure 3: If an executed instruction causes an exception,                                         part of the cache is accessed when executing the memory
                             diverting the control ﬂow to an exception handler, the                                            access out of order. As data is multiplied by 4096, data
                             subsequent instruction must not be executed. Due to out-                                          accesses to probe array are scattered over the array
                             of-order execution, the subsequent instructions may al-                                           with a distance of 4KB (assuming an 1B data type for
                             ready have been partially executed, but not retired. How-                                         probe array). Thus, there is an injective mapping from
                             ever, architectural effects of the execution are discarded.                                       the value of data to a memory page, i.e., different values
                                                                                                                               for data never result in an access to the same page. Con-
                                                                                                                               sequently, if a cache line of a page is cached, we know
                             of whether this exception is raised due to a memory ac-                                           the value of data. The spreading over pages eliminates
                             cess, e.g., by accessing an invalid address, or due to any                                        false positives due to the prefetcher, as the prefetcher
                             other CPUexception, e.g., a division by zero, the control                                         cannot access data across page boundaries [32].
                             ﬂow continues in the kernel and not with the next user                                                Figure 4 shows the result of a Flush+Reload measure-
                             space instruction.                                                                                ment iterating over all pages, after executing the out-of-
                                 Thus, our toy example cannot access the array in the-                                         order snippet with data = 84. Although the array ac-
                             ory, as the exception immediately traps to the kernel and                                         cess should not have happened due to the exception, we
                             terminates the application. However, due to the out-of-                                           can clearly see that the index which would have been ac-
                             order execution, the CPU might have already executed                                              cessed is cached. Iterating over all pages (e.g., in the
                             the following instructions as there is no dependency on                                           exception handler) shows only a cache hit for page 84
                             the instruction triggering the exception.                             This is illus-              This shows that even instructions which are never actu-
                             trated in Figure 3. Due to the exception, the instructions                                        ally executed, change the microarchitectural state of the
                             executedoutoforderarenotretiredand,thus,neverhave                                                 CPU. Section 4 modiﬁes this toy example not to read a
                             architectural effects.                                                                            value but to leak an inaccessible secret.
                                 Although the instructions executed out of order do not
                             haveanyvisible architectural effect on registers or mem-                                          4      Building Blocks of the Attack
                             ory, they have microarchitectural side effects. During the
                             out-of-orderexecution, thereferencedmemoryisfetched                                               ThetoyexampleinSection 3 illustrated that side-effects
                             into a register and also stored in the cache. If the out-                                         of out-of-order execution can modify the microarchitec-
                             of-order execution has to be discarded, the register and                                          tural state to leak information. While the code snippet
                             memorycontentsarenevercommitted. Nevertheless,the                                                 reveals the data value passed to a cache-side channel, we
                             cached memory contents are kept in the cache. We can                                              wanttoshowhowthistechniquecanbeleveragedtoleak
                             leverage a microarchitectural side-channel attack such                                            otherwise inaccessible secrets. In this section, we want
                             as Flush+Reload [63], which detects whether a speciﬁc                                             to generalize and discuss the necessary building blocks
                             memory location is cached, to make this microarchitec-                                            to exploit out-of-order execution for an attack.
                             tural state visible. Other side channels can also detect                                              Theadversary targets a secret value that is kept some-
                             whether a speciﬁc memory location is cached, including                                            where in physical memory. Note that register contents
                             Prime+Probe [55, 48, 52], Evict+Reload [47], or Flush+                                            are also stored in memory upon context switches, i.e.,
                             Flush[22]. As Flush+Reloadisthemostaccurateknown                                                  they are also stored in physical memory. As described in
                             cachesidechannelandissimpletoimplement,wedonot                                                    Section 2.2, the address space of every process typically
                             consider any other side channel for this example.                                                 includes the entire user space, as well as the entire kernel
                                            Exception Handling/                                                       building blocks to run a transient instruction sequence
                                                Suppression                                                           with a dependency on a secret value.
                                                 Transient              Accessed   Secret                                 The second building block of Meltdown is to transfer
                                               Instructions                                                           the microarchitectural side effect of the transient instruc-
                                               Microarchitectural                                                     tion sequence to an architectural state to further process
                                                 State Change                                                         the leaked secret. Thus, the second building described
                                                                                          Leak
                                        Section 4.1                                       ed                          in Section 4.2 describes building blocks to transfer a mi-
                                                                                                                      croarchitectural side effect to an architectural state using
                                               Transfer (Covert Channel)                                              a covert channel.
                                               Architectural          Recovery    Recovered
                                                    State                         Secret
                                        Section 4.2                                                                   4.1       Executing Transient Instructions
                           Figure 5: The Meltdown attack uses exception handling                                      The ﬁrst building block of Meltdown is the execution
                           or suppression, e.g., TSX, to run a series of transient in-                                of transient instructions. Transient instructions occur all
                           structions. These transient instructions obtain a (persis-                                 the time, as the CPU continuously runs ahead of the
                           tent) secret value and change the microarchitectural state                                 current instruction to minimize the experienced latency
                           of the processor based on this secret value. This forms                                    and, thus, to maximize the performance (cf. Section 2.1).
                           the sending part of a microarchitectural covert chan-                                      Transientinstructionsintroduceanexploitablesidechan-
                           nel. Thereceivingsidereadsthemicroarchitecturalstate,                                      nel if their operation depends on a secret value. We focus
                           making it architectural and recovers the secret value.                                     on addresses that are mapped within the attacker’s pro-
                                                                                                                      cess, i.e., the user-accessible user space addresses as well
                           space, which typically also has all physical memory (in-                                   astheuser-inaccessiblekernelspaceaddresses. Notethat
                           use) mapped. However, these memory regions are only                                        attacks targeting code that is executed within the context
                           accessible in privileged mode (cf. Section 2.2).                                           (i.e., address space) of another process are possible [40],
                                                                                                                      but out of scope in this work, since all physical memory
                               In this work, we demonstrate leaking secrets by by-                                    (including the memory of other processes) can be read
                           passing the privileged-mode isolation, giving an attacker                                  through the kernel address space regardless.
                           full read access to the entire kernel space, including                                         Accessing user-inaccessible pages, such as kernel
                           any physical memory mapped and, thus, the physical                                         pages, triggers an exception which generally terminates
                           memory of any other process and the kernel. Note that                                      the application. If the attacker targets a secret at a user-
                           Kocher et al. [40] pursue an orthogonal approach, called                                   inaccessible address, the attacker has to cope with this
                           Spectre Attacks, which trick speculatively executed in-                                    exception.        We propose two approaches: With excep-
                           structions into leaking information that the victim pro-                                   tion handling, we catch the exception effectively occur-
                           cess is authorized to access. As a result, Spectre Attacks                                 ring after executing the transient instruction sequence,
                           lack the privilege escalation aspect of Meltdown and re-                                   and with exception suppression, we prevent the excep-
                           quire tailoring to the victim process’s software environ-                                  tion from occurring at all and instead redirect the control
                           ment, but apply more broadly to CPUs that support spec-                                    ﬂow after executing the transient instruction sequence.
                           ulative execution and are not prevented by KAISER.                                         Wediscuss these approaches in detail in the following.
                               The full Meltdown attack consists of two building
                           blocks, as illustrated in Figure 5. The ﬁrst building block
                           of Meltdown is to make the CPU execute one or more                                         Exception handling.                 Atrivial approach is to fork the
                           instructions that would never occur in the executed path.                                  attacking application before accessing the invalid mem-
                           In the toy example (cf. Section 3), this is an access to                                   ory location that terminates the process and only access
                           an array, which would normally never be executed, as                                       the invalid memory location in the child process. The
                           the previous instruction always raises an exception. We                                    CPU executes the transient instruction sequence in the
                           call such an instruction, which is executed out of order                                   child process before crashing. The parent process can
                           and leaving measurable side effects, a transient instruc-                                  then recover the secret by observing the microarchitec-
                           tion. Furthermore, we call any sequence of instructions                                    tural state, e.g., through a side-channel.
                           containing at least one transient instruction a transient                                      It is also possible to install a signal handler that is exe-
                           instruction sequence.                                                                      cuted when a certain exception occurs, e.g., a segmenta-
                               Inordertoleveragetransientinstructionsforanattack,                                     tion fault. This allows the attacker to issue the instruction
                           the transient instruction sequence must utilize a secret                                   sequence and prevent the application from crashing, re-
                           valuethatanattackerwantstoleak. Section4.1describes                                        ducing the overhead as no new process has to be created.
                    Exception suppression.       Adifferent approach to deal            Using multiple different cache lines, as in our toy ex-
                    with exceptions is to prevent them from being raised in          ample in Section 3, allows to transmit multiple bits at
                    the ﬁrst place. Transactional memory allows to group             once. For every of the 256 different byte values, the
                    memory accesses into one seemingly atomic operation,             sender accesses a different cache line. By performing
                    giving the option to roll-back to a previous state if an er-     a Flush+Reload attack on all of the 256 possible cache
                    ror occurs. If an exception occurs within the transaction,       lines, the receiver can recover a full byte instead of just
                    the architectural state is reset, and the program execution      one bit. However, since the Flush+Reload attack takes
                    continues without disruption.                                    much longer (typically several hundred cycles) than the
                      Furthermore, speculative execution issues instructions         transient instruction sequence, transmitting only a single
                    that might not occur on the executed code path due to            bit at once is more efﬁcient. The attacker can simply do
                    a branch misprediction. Such instructions depending on           that by shifting and masking the secret value accordingly.
                    a preceding conditional branch can be speculatively ex-             Note that the covert channel is not limited to microar-
                    ecuted. Thus, the invalid memory access is put within            chitectural states which rely on the cache. Any microar-
                    a speculative instruction sequence that is only executed         chitectural state which can be inﬂuenced by an instruc-
                    if a prior branch condition evaluates to true. By making         tion (sequence) and is observable through a side channel
                    sure that the condition never evaluates to true in the ex-       can be used to build the sending end of a covert channel.
                    ecuted code path, we can suppress the occurring excep-           The sender could, for example, issue an instruction (se-
                    tion as the memory access is only executed speculatively.        quence) which occupies a certain execution port such as
                    This technique may require sophisticated training of the         the ALU to send a ‘1’-bit. The receiver measures the la-
                    branch predictor. Kocher et al. [40] pursue this approach        tency when executing an instruction (sequence) on the
                    in orthogonal work, since this construct can frequently          same execution port. A high latency implies that the
                    be found in code of other processes.                             sender sends a ‘1’-bit, whereas a low latency implies
                                                                                     that sender sends a ‘0’-bit. The advantage of the Flush+
                                                                                     Reload cache covert channel is the noise resistance and
                    4.2    Building a Covert Channel                                 the high transmission rate [22]. Furthermore, the leakage
                                                                                     canbeobservedfromanyCPUcore[63],i.e.,reschedul-
                    The second building block of Meltdown is the transfer            ing events do not signiﬁcantly affect the covert channel.
                    of the microarchitectural state, which was changed by
                    the transient instruction sequence, into an architectural        5    Meltdown
                    state (cf. Figure 5). The transient instruction sequence
                    can be seen as the sending end of a microarchitectural           In this section, we present Meltdown, a powerful at-
                    covert channel. The receiving end of the covert channel          tack allowing to read arbitrary physical memory from
                    receives the microarchitectural state change and deduces         an unprivileged user program, comprised of the build-
                    the secret from the state. Note that the receiver is not         ing blocks presented in Section 4. First, we discuss the
                    part of the transient instruction sequence and can be a          attack setting to emphasize the wide applicability of this
                    different threadorevenadifferentprocesse.g.,theparent            attack. Second, we present an attack overview, show-
                    process in the fork-and-crash approach.                          ing how Meltdown can be mounted on both Windows
                      We leverage techniques from cache attacks, as the              and Linux on personal computers, on Android on mo-
                    cache state is a microarchitectural state which can be re-       bile phones as well as in the cloud. Finally, we discuss a
                    liably transferred into an architectural state using vari-       concrete implementation of Meltdown allowing to dump
                    ous techniques [55, 63, 22]. Speciﬁcally, we use Flush+          arbitrary kernel memory with 3.2KB/s to 503KB/s.
                    Reload [63], as it allows to build a fast and low-noise
                    covert channel. Thus, depending on the secret value, the
                    transient instruction sequence (cf. Section 4.1) performs        Attack setting.     In our attack, we consider personal
                    a regular memory access, e.g., as it does in the toy exam-       computers and virtual machines in the cloud.          In the
                    ple (cf. Section 3).                                             attack scenario, the attacker has arbitrary unprivileged
                      After the transient instruction sequence accessed an           code execution on the attacked system, i.e., the attacker
                    accessible address, i.e., this is the sender of the covert       can run any code with the privileges of a normal user.
                    channel; the address is cached for subsequent accesses.          However, the attacker has no physical access to the ma-
                    The receiver can then monitor whether the address has            chine. Furthermore, we assume that the system is fully
                    been loaded into the cache by measuring the access time          protected with state-of-the-art software-based defenses
                    to the address. Thus, the sender can transmit a ‘1’-bit by       such as ASLR and KASLR as well as CPU features like
                    accessing an address which is loaded into the monitored          SMAP, SMEP, NX, and PXN. Most importantly, we as-
                    cache, and a ‘0’-bit by not accessing such an address.           sume a completely bug-free operating system, thus, no
                                 1  ; rcx = kernel address, rbx = probe array                                                  dress, i.e., whether this virtual address is user accessible
                                 2  xor rax, rax                                                                               or only accessible by the kernel. As already discussed in
                                 3  retry:                                                                                     Section 2.2, this hardware-based isolation through a per-
                                 4  mov al, byte [rcx]                                                                         missionbitisconsideredsecureandrecommendedbythe
                                 5  shl rax, 0xc                                                                               hardware vendors. Hence, modern operating systems al-
                                 6  jz retry
                                 7  mov rbx, qword [rbx + rax]                                                                 waysmaptheentirekernel into the virtual address space
                             Listing 2: The core of Meltdown. An inaccessible kernel                                           of every user process.
                             address is moved to a register, raising an exception.                                                 Asaconsequence, all kernel addresses lead to a valid
                             Subsequent instructions are executed out of order before                                          physicaladdresswhentranslatingthem,andtheCPUcan
                             the exception is raised, leaking the data from the kernel                                         access the content of such addresses. The only differ-
                             address through the indirect memory access.                                                       ence to accessing a user space address is that the CPU
                                                                                                                               raises an exception as the current permission level does
                                                                                                                               not allow to access such an address. Hence, the user
                                                                                                                               spacecannotsimplyreadthecontentsofsuchanaddress.
                             software vulnerability exists that can be exploited to gain                                       However, Meltdown exploits the out-of-order execution
                             kernel privileges or leak information. The attacker tar-                                          of modern CPUs, which still executes instructions in the
                             gets secret user data, e.g., passwords and private keys, or                                       small time window between the illegal memory access
                             any other valuable information.                                                                   and the raising of the exception.
                                                                                                                                   In line 4 of Listing 2, we load the byte value located
                             5.1        Attack Description                                                                     at the target kernel address, stored in the RCX register,
                                                                                                                               into the least signiﬁcant byte of the RAX register repre-
                             Meltdown combines the two building blocks discussed                                               sented by AL. As explained in more detail in Section 2.1,
                             in Section 4. First, an attacker makes the CPU execute                                            the MOV instruction is fetched by the core, decoded into
                             a transient instruction sequence which uses an inacces-                                           µOPs,allocated,andsenttothereorderbuffer. There,ar-
                             sible secret value stored somewhere in physical memory                                            chitectural registers (e.g., RAX and RCX in Listing 2) are
                             (cf. Section 4.1). The transient instruction sequence acts                                        mappedtounderlyingphysicalregisters enabling out-of-
                             as the transmitter of a covert channel (cf. Section 4.2),                                         order execution. Trying to utilize the pipeline as much as
                             ultimately leaking the secret value to the attacker.                                              possible, subsequent instructions (lines 5-7) are already
                                 Meltdownconsists of 3 steps:                                                                  decoded and allocated as µOPs as well. The µOPs are
                             Step 1 The content of an attacker-chosen memory loca-                                             further sent to the reservation station holding the µOPs
                                   tion, which is inaccessible to the attacker, is loaded                                      while they wait to be executed by the corresponding ex-
                                   into a register.                                                                            ecution unit. The execution of a µOP can be delayed if
                             Step 2 A transient instruction accesses a cache line                                              execution units are already used to their corresponding
                                   based on the secret content of the register.                                                capacity, or operand values have not been computed yet.
                             Step 3 Theattacker uses Flush+Reload to determine the                                                 Whenthekerneladdressisloadedinline4, it is likely
                                   accessed cache line and hence the secret stored at the                                      that the CPU already issued the subsequent instructions
                                   chosen memory location.                                                                     as part of the out-of-order execution, and that their cor-
                             Byrepeating these steps for different memory locations,                                           responding µOPs wait in the reservation station for the
                             the attacker can dump the kernel memory, including the                                            content of the kernel address to arrive. As soon as the
                             entire physical memory.                                                                           fetched data is observed on the common data bus, the
                                 Listing 2 shows the basic implementation of the tran-                                         µOPscanbegintheir execution. Furthermore, processor
                             sient instruction sequence and the sending part of the                                            interconnects [31, 3] and cache coherence protocols [59]
                             covert channel, using x86 assembly instructions. Note                                             guaranteethatthemostrecentvalueofamemoryaddress
                             that this part of the attack could also be implemented en-                                        is read, regardless of the storage location in a multi-core
                             tirely in higher level languages like C. In the following,                                        or multi-CPU system.
                             we will discuss each step of Meltdown and the corre-                                                  When the µOPs ﬁnish their execution, they retire in-
                             sponding code line in Listing 2.                                                                  order, and, thus, their results are committed to the archi-
                                                                                                                               tectural state. During the retirement, any interrupts and
                             Step 1: Reading the secret.                           To load data from the                       exceptions that occurred during the execution of the in-
                             main memory into a register, the data in the main mem-                                            struction are handled. Thus, if the MOV instruction that
                             ory is referenced using a virtual address. In parallel to                                         loads the kernel address is retired, the exception is regis-
                             translating a virtual address into a physical address, the                                        tered, and the pipeline is ﬂushed to eliminate all results
                             CPU also checks the permission bits of the virtual ad-                                            of subsequent instructions which were executed out of
                    order. However, there is a race condition between raising         Step 3: Receiving the secret.        In step 3, the attacker
                    this exception and our attack step 2 as described below.          recovers the secret value (step 1) by leveraging a mi-
                       AsreportedbyGrussetal.[21],prefetchingkernelad-                croarchitectural side-channel attack (i.e., the receiving
                    dresses sometimes succeeds. We found that prefetching             endofamicroarchitectural covert channel) that transfers
                    the kernel address can slightly improve the performance           the cache state (step 2) back into an architectural state.
                    of the attack on some systems.                                    AsdiscussedinSection4.2,ourimplementationofMelt-
                                                                                      downrelies on Flush+Reload for this purpose.
                                                                                         When the transient instruction sequence of step 2 is
                    Step 2: Transmitting the secret.        The instruction se-       executed, exactly one cache line of the probe array is
                    quence from step 1 which is executed out of order has to          cached. The position of the cached cache line within the
                    bechoseninawaythatitbecomesatransientinstruction                  probe array depends only on the secret which is read in
                    sequence. If this transient instruction sequence is exe-          step 1. Thus, the attacker iterates over all 256 pages of
                    cuted before the MOV instruction is retired (i.e., raises the     the probe array and measures the access time for every
                    exception), and the transient instruction sequence per-           ﬁrst cache line (i.e., offset) on the page. The number of
                    formed computations based on the secret, it can be uti-           the page containing the cached cache line corresponds
                    lized to transmit the secret to the attacker.                     directly to the secret value.
                       Asalready discussed, we utilize cache attacks that al-
                    lowbuildingfastandlow-noisecovertchannelsusingthe                 Dumping the entire physical memory.            Repeating all
                    CPU’s cache. Thus, the transient instruction sequence             3 steps of Meltdown, an attacker can dump the entire
                    hastoencodethesecretintothemicroarchitecturalcache                memorybyiterating over all addresses. However, as the
                    state, similar to the toy example in Section 3.                   memoryaccess to the kernel address raises an exception
                       Weallocate a probe array in memory and ensure that             that terminates the program, we use one of the methods
                    nopart of this array is cached. To transmit the secret, the       from Section 4.1 to handle or suppress the exception.
                    transient instruction sequence contains an indirect mem-             Asall major operating systems also typically map the
                    ory access to an address which is computed based on the           entire physical memory into the kernel address space (cf.
                    secret (inaccessible) value. In line 5 of Listing 2, the se-      Section 2.2) in every user process, Meltdown can also
                    cret value from step 1 is multiplied by the page size, i.e.,      read the entire physical memory of the target machine.
                    4KB. The multiplication of the secret ensures that ac-
                    cesses to the array have a large spatial distance to each         5.2    Optimizations and Limitations
                    other. This prevents the hardware prefetcher from load-
                    ing adjacent memory locations into the cache as well.             Inherent bias towards 0.       While CPUs generally stall
                    Here, we read a single byte at once. Hence, our probe             if a value is not available during an out-of-order load op-
                    array is 256×4096 bytes, assuming 4KB pages.                      eration [28], CPUs might continue with the out-of-order
                       Note that in the out-of-order execution we have a              execution by assuming a value for the load [12]. We
                    noise-bias towards register value ‘0’. We discuss the rea-        observed that the illegal memory load in our Meltdown
                    sons for this in Section 5.2. However, for this reason, we        implementation (line 4 in Listing 2) often returns a ‘0’,
                    introduce a retry-logic into the transient instruction se-        which can be clearly observed when implemented using
                    quence. In case we read a ‘0’, we try to reread the secret        anaddinstructioninsteadofthemov. Thereasonforthis
                    (step 1). In line 7, the multiplied secret is added to the        bias to ‘0’ may either be that the memory load is masked
                    base address of the probe array, forming the target ad-           out by a failed permission check, or a speculated value
                    dress of the covert channel. This address is read to cache        because the data of the stalled load is not available yet.
                    the corresponding cache line. The address will be loaded             This inherent bias results from the race condition in
                    into the L1 data cache of the requesting core and, due to         the out-of-order execution, which maybewon(i.e.,reads
                    the inclusiveness, also the L3 cache where it can be read         the correct value), but is often lost (i.e., reads a value of
                    fromother cores. Consequently, our transient instruction          ‘0’). This bias varies between different machines as well
                    sequenceaffects the cache state based on the secret value         as hardware and software conﬁgurations and the speciﬁc
                    that was read in step 1.                                          implementation of Meltdown. In an unoptimized ver-
                       Since the transient instruction sequence in step 2 races       sion, the probability that a value of ’0’ is erroneously
                    against raising the exception, reducing the runtime of            returned is high. Consequently, our Meltdown imple-
                    step 2 can signiﬁcantly improve the performance of the            mentation performs a certain number of retries when the
                    attack. For instance, taking care that the address trans-         codeinListing2resultsinreadingavalueof‘0’fromthe
                    lation for the probe array is cached in the translation-          Flush+Reloadattack. The maximumnumberofretriesis
                    lookaside buffer (TLB) increases the attack performance           an optimization parameter inﬂuencing the attack perfor-
                    onsomesystems.                                                    mance and the error rate. On the Intel Core i5-6200U
                   using exeception handling, we read a ’0’ on average in          the numberofbitsreadandtransmittedatonceisatrade-
                   5.25% (σ =4.15) with our unoptimized version. With              off betweensomeimpliciterror-reductionandtheoverall
                   a simple retry loop, we reduced the probability to 0.67%        transmission rate of the covert channel.
                   (σ =1.47). On the Core i7-8700K, we read on average                However, since the error rates are quite small in either
                   a ’0’ in 1.78% (σ = 3.07). Using Intel TSX, the proba-          case, our evaluation (cf. Section 6) is based on the single-
                   bility is further reduced to 0.008%.                            bit transmission mechanics.
                   Optimizing the case of 0.      Due to the inherent bias of      Exception Suppression using Intel TSX.             In Sec-
                   Meltdown, a cache hit on cache line ‘0’ in the Flush+           tion 4.1, we discussed the option to prevent that an ex-
                   Reload measurement, does not provide the attacker with          ception is raised due an invalid memory access. Using
                   any information. Hence, measuring cache line ‘0’ can            Intel TSX, a hardware transactional memory implemen-
                   be omitted and in case there is no cache hit on any other       tation, we can completely suppress the exception [37].
                   cache line, the value can be assumed to be ‘0’. To min-            With Intel TSX, multiple instructions can be grouped
                   imize the number of cases where no cache hit on a non-          to a transaction, which appears to be an atomic opera-
                   zero line occurs, we retry reading the address in the tran-     tion, i.e., either all or no instruction is executed. If one
                   sient instruction sequence until it encounters a value dif-     instruction within the transaction fails, already executed
                   ferent from ‘0’ (line 6). This loop is terminated either        instructions are reverted, but no exception is raised.
                   byreadinganon-zerovalueorbytheraisedexceptionof                    If we wrap the code from Listing 2 with such a TSX
                   the invalid memory access. In either case, the time un-         instruction, any exception is suppressed. However, the
                   til exception handling or exception suppression returns         microarchitectural effects are still visible, i.e., the cache
                   the control ﬂow is independent of the loop after the in-        state is persistently manipulated from within the hard-
                   valid memory access, i.e., the loop does not slow down          ware transaction [19]. This results in higher channel ca-
                   the attack measurably. Hence, these optimizations may           pacity, as suppressing the exception is signiﬁcantly faster
                   increase the attack performance.                                than trapping into the kernel for handling the exception,
                                                                                   and continuing afterward.
                   Single-bit transmission.      In the attack description in
                   Section 5.1, the attacker transmitted 8 bits through the        Dealing with KASLR. In 2013, kernel address space
                                                              8
                   covert channel at once and performed 2 = 256 Flush+             layout randomization (KASLR) was introduced to the
                   Reload measurements to recover the secret. However,             Linux kernel (starting from version 3.14 [11]) allowing
                   there is a trade-off between running more transient in-         to randomize the location of kernel code at boot time.
                   struction sequences and performing more Flush+Reload            However, only as recently as May 2017, KASLR was
                   measurements. The attacker could transmit an arbitrary          enabled by default in version 4.12 [54]. With KASLR
                   numberofbitsinasingletransmissionthroughthecovert               also the direct-physical map is randomized and not ﬁxed
                   channel, by reading more bits using a MOV instruction for       at a certain address such that the attacker is required to
                   alarger data value. Furthermore, the attacker could mask        obtain the randomized offset before mounting the Melt-
                   bits using additional instructions in the transient instruc-    down attack. However, the randomization is limited to
                   tion sequence. We found the number of additional in-            40bit.
                   structions in the transient instruction sequence to have a         Thus, if we assume a setup of the target machine with
                   negligible inﬂuence on the performance of the attack.           8GB of RAM, it is sufﬁcient to test the address space
                      The performance bottleneck in the generic attack de-         for addresses in 8GB steps. This allows covering the
                   scribed above is indeed, the time spent on Flush+Reload         search space of 40 bit with only 128 tests in the worst
                   measurements. In fact, with this implementation, almost         case. If the attacker can successfully obtain a value from
                   the entire time is spent on Flush+Reload measurements.          a tested address, the attacker can proceed to dump the
                   By transmitting only a single bit, we can omit all but          entire memory from that location. This allows mount-
                   one Flush+Reload measurement, i.e., the measurement             ing Meltdown on a system despite being protected by
                   on cache line 1. If the transmitted bit was a ‘1’, then         KASLRwithinseconds.
                   we observe a cache hit on cache line 1. Otherwise, we
                   observe no cache hit on cache line 1.                           6    Evaluation
                      Transmitting only a single bit at once also has draw-
                   backs. As described above, our side channel has a bias          In this section, we evaluate Meltdown and the perfor-
                   towards a secret value of ‘0’. If we read and transmit                                                             11
                   multiple bits at once, the likelihood that all bits are ‘0’     mance of our proof-of-concept implementation.          Sec-
                   may be quite small for actual user data. The likelihood         tion 6.1 discusses the information which Meltdown can
                   that a single bit is ‘0’ is typically close to 50%. Hence,        11https://github.com/IAIK/meltdown
                               Table 1: Experimental setups.                  As Meltdown bypasses these permission settings, an at-
                                                                              tacker can leak the complete kernel memory if the vir-
                           Environment   CPUModel           Cores             tual address of the kernel base is known. Since all major
                               Lab       Celeron G540           2             operating systems also map the entire physical memory
                               Lab       Core i5-3230M          2             into the kernel address space (cf. Section 2.2), all physi-
                               Lab       Core i5-3320M          2             cal memory can also be read.
                               Lab       Core i7-4790           4               Before kernel 4.12, kernel address space layout ran-
                               Lab       Core i5-6200U          2             domization (KASLR) was not active by default [57]. If
                               Lab       Core i7-6600U          2             KASLRisactive, Meltdown can still be used to ﬁnd the
                               Lab       Core i7-6700K          4             kernel by searching through the address space (cf. Sec-
                               Lab       Core i7-8700K         12             tion 5.2). An attacker can also simply de-randomize the
                               Lab       XeonE5-1630v3          8
                              Cloud      XeonE5-2676v3         12             direct-physical map by iterating through the virtual ad-
                              Cloud      XeonE5-2650v4         12             dress space. Without KASLR, the direct-physical map
                              Phone      Exynos8890             8             starts at address 0xffff 8800 0000 0000 and linearly
                                                                              maps the entire physical memory. On such systems, an
                                                                              attacker can use Meltdown to dump the entire physical
                  leak, and Section 6.2 evaluates the performance of Melt-    memory, simply by reading from virtual addresses start-
                  down, including countermeasures. Finally, we discuss        ing at 0xffff 8800 0000 0000.
                  limitations for AMD and ARM in Section 6.3.                   Onnewersystems,whereKASLRisactivebydefault,
                     Table 1 shows a list of conﬁgurations on which we        the randomization of the direct-physical map is limited
                  successfully reproducedMeltdown. Fortheevaluationof         to 40 bit. It is even further limited due to the linearity of
                  Meltdown, we used both laptops as well as desktop PCs       themapping. Assumingthatthetargetsystemhasatleast
                  with Intel Core CPUs and an ARM-based mobile phone.         8GBofphysicalmemory,theattackercantestaddresses
                  For the cloud setup, we tested Meltdown in virtual ma-      in steps of 8GB, resulting in a maximum of 128 memory
                  chines running on Intel Xeon CPUs hosted in the Ama-        locations to test. Starting from one discovered location,
                  zon Elastic Compute Cloud as well as on DigitalOcean.       the attacker can again dump the entire physical memory.
                  NotethatforethicalreasonswedidnotuseMeltdownon                Hence, for the evaluation, we can assume that the ran-
                  addresses referring to physical memory of other tenants.    domization is either disabled, or the offset was already
                  6.1    LeakageandEnvironments                               retrieved in a pre-computation step.
                  We evaluated Meltdown on both Linux (cf. Sec-
                  tion 6.1.1), Windows 10 (cf. Section 6.1.3) and Android
                  (cf. Section 6.1.4), without the patches introducing the    6.1.2  LinuxwithKAISERPatch
                  KAISERmechanism. Ontheseoperatingsystems,Melt-
                  down can successfully leak kernel memory. We also           The KAISER patch by Gruss et al. [20] implements
                  evaluatedtheeffectoftheKAISERpatchesonMeltdown              a stronger isolation between kernel and user space.
                  on Linux, to show that KAISER prevents the leakage of       KAISER does not map any kernel memory in the user
                  kernel memory (cf. Section 6.1.2). Furthermore, we dis-     space, except for some parts required by the x86 archi-
                  cuss the information leakage when running inside con-       tecture (e.g., interrupt handlers). Thus, there is no valid
                  tainers such as Docker (cf. Section 6.1.5). Finally, we     mapping to either kernel memory or physical memory
                  evaluate Meltdown on uncached and uncacheable mem-          (via the direct-physical map) in the user space, and such
                  ory (cf. Section 6.1.6).                                    addresses can therefore not be resolved. Consequently,
                                                                              Meltdown cannot leak any kernel or physical memory
                  6.1.1  Linux                                                except for the few memory locations which have to be
                  We successfully evaluated Meltdown on multiple ver-         mappedinuserspace.
                  sions of the Linux kernel, from 2.6.32 to 4.13.0, with-       Weveriﬁed that KAISER indeed prevents Meltdown,
                  out the patches introducing the KAISER mechanism. On        andthereisnoleakageofanykernelorphysicalmemory.
                  all these versions of the Linux kernel, the kernel address    Furthermore, if KASLR is active, and the few re-
                  space is also mapped into the user address space. Thus,     mainingmemorylocationsarerandomized,ﬁndingthese
                  all kernel addresses are also mapped into the address       memorylocations is not trivial due to their small size of
                  space of user space applications, but any access is pre-    several kilobytes. Section 7.2 discusses the security im-
                  ventedduetothepermissionsettingsfortheseaddresses.          plications of these mapped memory locations.
                   6.1.3  Microsoft Windows                                     not only from the underlying kernel but also from all
                   We successfully evaluated Meltdown on a recent Mi-           other containers running on the same physical host.
                   crosoft Windows 10 operating system, last updated just         The commonality of most container solutions is that
                   before patches against Meltdown were rolled out. In line     every container uses the same kernel, i.e., the kernel is
                   with the results on Linux (cf. Section 6.1.1), Meltdown      shared among all containers. Thus, every container has
                   also can leak arbitrary kernel memory on Windows. This       a valid mapping of the entire physical memory through
                   is not surprising, since Meltdown does not exploit any       the direct-physical map of the shared kernel. Further-
                   software issues, but is caused by a hardware issue.          more, Meltdown cannot be blocked in containers, as it
                     In contrast to Linux, Windows does not have the con-       uses only memory accesses. Especially with Intel TSX,
                   cept of an identity mapping, which linearly maps the         only unprivileged instructions are executed without even
                   physical memory into the virtual address space. Instead,     trapping into the kernel.
                   a large fraction of the physical memory is mapped in           Thus, the isolation of containers sharing a kernel can
                   the paged pools, non-paged pools, and the system cache.      be entirely broken using Meltdown. This is especially
                   Furthermore, Windows maps the kernel into the address        critical for cheaper hosting providers where users are not
                   space of every application too. Thus, Meltdown can read      separated through fully virtualized machines, but only
                   kernel memory which is mapped in the kernel address          through containers. We veriﬁed that our attack works in
                   space, i.e., any part of the kernel which is not swapped     such a setup, by successfully leaking memory contents
                   out, and any page mapped in the paged and non-paged          from a container of a different user under our control.
                   pool, and the system cache.
                     Note that there are physical pages which are mapped        6.1.6  UncachedandUncacheableMemory
                   in one process but not in the (kernel) address space of      In this section, we evaluate whether it is a requirement
                   another process, i.e., physical pages which cannot be at-    for data to be leaked by MeltdowntoresideintheL1data
                   tacked using Meltdown. However, most of the physical         cache [33]. Therefore, we constructed a setup with two
                   memorywillstill be accessible through Meltdown.              processes pinned to different physical cores. By ﬂush-
                     We were successfully able to read the binary of the        ing the value, using the clflush instruction, and only
                   Windows kernel using Meltdown. To verify that the            reloading it on the other core, we create a situation where
                   leaked data is actual kernel memory, we ﬁrst used the        the target data is not in the L1 data cache of the attacker
                   Windows kernel debugger to obtain kernel addresses           core. As described in Section 6.2, we can still leak the
                   containing actual data. After leaking the data, we again     data at a lower reading rate. This clearly shows that data
                   usedtheWindowskerneldebuggertocomparetheleaked               presence in the attacker’s L1 data cache is not a require-
                   data with the actual memory content, conﬁrming that          ment for Meltdown. Furthermore, this observation has
                   Meltdowncansuccessfully leak kernel memory.                  also been conﬁrmed by other researchers [7, 35, 5].
                   6.1.4  Android                                                 The reason why Meltdown can leak uncached mem-
                                                                                ory may be that Meltdown implicitly caches the data.
                   We successfully evaluated Meltdown on a Samsung              We devise a second experiment, where we mark pages
                   Galaxy S7 mohile phone running LineageOS Android             as uncacheable and try to leak data from them. This
                   14.1withaLinuxkernel3.18.14. Thedeviceisequipped             has the consequence that every read or write operation to
                   with a Samsung Exynos 8 Octa 8890 SoC consisting             one of those pages will directly go to the main memory,
                   of a ARM Cortex-A53 CPU with 4 cores as well as an           thus, bypassing the cache. In practice, only a negligible
                   Exynos M1 ”Mongoose” CPU with 4 cores [6]. While             amount of system memory is marked uncacheable. We
                   we were not able to mount the attack on the Cortex-          observed that if the attacker is able to trigger a legitimate
                   A53CPU,wesuccessfully mounted Meltdown on Sam-               load of the target address, e.g., by issuing a system call
                   sung’s custom cores. Using exception suppression de-         (regular or in speculative execution [40]), on the same
                   scribed in Section 4.1, we successfully leaked a pre-        CPUcore as the Meltdown attack, the attacker can leak
                   deﬁned string using the direct-physical map located at       the content of the uncacheable pages. We suspect that
                   the virtual address 0xffff ffbf c000 0000.                   Meltdown reads the value from the line ﬁll buffers. As
                                                                                the ﬁll buffers are shared between threads running on the
                   6.1.5  Containers                                            samecore, the read to the same address within the Melt-
                                                                                down attack could be served from one of the ﬁll buffers
                   We evaluated Meltdown in containers sharing a kernel,        allowing the attack to succeed. However, we leave fur-
                   including Docker, LXC, and OpenVZ and found that the         ther investigations on this matter open for future work.
                   attack can be mounted without any restrictions. Running        A similar observation on uncacheable memory was
                   Meltdown inside a container allows to leak information       also made with Spectre attacks on the System Manage-
                   ment Mode [10]. While the attack works on memory                6.3    Limitations on ARM and AMD
                   set uncacheable over Memory-Type Range Registers, it            Wealso tried to reproduce the Meltdown bug on several
                   does not work on memory-mapped I/O regions, which               ARM and AMD CPUs. While we were able to suc-
                   is the expected behavior as accesses to memory-mapped           cessfully leak kernel memory with the attack described
                   I/O can always have architectural effects.                      in Section 5 on different Intel CPUs and a Samsung
                                                                                   ExynosM1processor,wedidnotmanagetomountMelt-
                   6.2     MeltdownPerformance                                     down on other ARM cores nor on AMD. In the case of
                                                                                   ARM,theonlyaffectedprocessoristheCortex-A75[17]
                   To evaluate the performance of Meltdown, we leaked              which has not been available and, thus, was not among
                   known values from kernel memory. This allows us to              our devices under test.     However, appropriate kernel
                   not only determine how fast an attacker can leak mem-           patches have already been provided [2]. Furthermore, an
                   ory, but also the error rate, i.e., how many byte errors to     altered attack of Meltdown targeting system registers in-
                   expect. The race condition in Meltdown (cf. Section 5.2)        stead of inaccessible memory locations is applicable on
                   has a signiﬁcant inﬂuence on the performance of the at-         several ARM processors [17]. Meanwhile, AMD pub-
                   tack, however, the race condition can always be won. If         licly stated that none of their CPUs are not affected by
                   the targeted data resides close to the core, e.g., in the       Meltdownduetoarchitectural differences [1].
                   L1 data cache, the race condition is won with a high               The major part of a microarchitecture is usually not
                   probability. In this scenario, we achieved average read-        publicly documented. Thus, it is virtually impossible
                   ing rates of up to 582KB/s (µ = 552.4,σ = 10.2) with            to know the differences in the implementations that al-
                   an error rate as low as 0.003% (µ = 0.009,σ = 0.014)            loworpreventMeltdownwithoutproprietaryknowledge
                   using exception suppression on the Core i7-8700K over           and, thus, the intellectual property of the individual CPU
                   10 runs over 10 seconds. With the Core i7-6700K we              manufacturers. The key point is that on a microarchitec-
                   achieved 569KB/s (µ = 515.5,σ = 5.99) with an min-              tural level the load to the unprivileged address and the
                   imumerror rate of 0.002% (µ = 0.003,σ = 0.001) and              subsequent instructions are executed while the fault is
                   491KB/s(µ =466.3,σ =16.75)withaminimumerror                     only handled when the faulting instruction is retired. It
                   rate of 10.7% (µ = 11.59,σ = 0.62) on the Xeon E5-              can be assumed that the execution units for the load and
                   1630. However, with a slower version with an average            the TLB are designed differently on ARM, AMD and
                   reading speed of 137KB/s, we were able to reduce the            Intel and, thus, the privileges for the load are checked
                   error rate to 0. Furthermore, on the Intel Core i7-6700K        differently and occurring faults are handled differently,
                   if the data resides in the L3 data cache but not in L1,         e.g., issuing a load only after the permission bit in the
                   the race condition can still be won often, but the average      page table entry has been checked. However, from a
                   reading rate decreases to 12.4KB/s with an error rate as        performance perspective, issuing the load in parallel or
                   low as 0.02% using exception suppression. However, if           only checking permissions while retiring an instruction
                   the data is uncached, winning the race condition is more        is a reasonable decision. As trying to load kernel ad-
                   difﬁcult and, thus, we have observed reading rates of less      dresses from user space is not what programs usually do
                   than 10B/s on most systems. Nevertheless, there are             and by guaranteeing that the state does not become ar-
                   two optimizations to improve the reading rate: First, by        chitecturally visible, not squashing the load is legitimate.
                   simultaneouslylettingotherthreadsprefetchthememory              However,asthestatebecomesvisibleonthemicroarchi-
                   locations [21] of and around the target value and access        tectural level, such implementations are vulnerable.
                   the target memory location (with exception suppression             However, for both ARM and AMD, the toy example
                   or handling). This increases the probability that the spy-      as described in Section 3 works reliably, indicating that
                   ing thread sees the secret data value in the right moment       out-of-order execution generally occurs and instructions
                   during the data race. Second, by triggering the hardware        past illegal memory accesses are also performed.
                   prefetcher through speculative accesses to memory loca-
                   tions of and around the target value. With these two opti-      7    Countermeasures
                   mizations, we can improve the reading rate for uncached
                   data to 3.2KB/s.                                                In this section, we discuss countermeasures against the
                      For all tests, we used Flush+Reload as a covert chan-        Meltdown attack. At ﬁrst, as the issue is rooted in the
                   nel to leak the memory as described in Section 5, and In-       hardware itself, we discuss possible microcode updates
                   tel TSX to suppress the exception. An extensive evalua-         and general changes in the hardware design. Second, we
                   tion of exception suppression using conditional branches        discuss the KAISER countermeasure that has been de-
                   wasdonebyKocheretal.[40]andisthusomittedinthis                  veloped to mitigate side-channel attacks against KASLR
                   paper for the sake of brevity.                                  which inadvertently also protects against Meltdown.
                    7.1    Hardware                                                  to KAISER, Gens et al. [14] proposed LAZARUS as a
                    Meltdown bypasses the hardware-enforced isolation of             modiﬁcation to the Linux kernel to thwart side-channel
                    security domains.      There is no software vulnerabil-          attacks breaking KASLR by separating address spaces
                    ity involved in Meltdown.       Any software patch (e.g.,        similar to KAISER. As the Linux kernel continued the
                    KAISER[20]) will leave small amounts of memory ex-               development of the original KAISER patch and Win-
                    posed (cf. Section 7.2).     There is no documentation           dows [53] and macOS [34] based their implementation
                    whether a ﬁx requires the development of completely              on the concept of KAISER to defeat Meltdown, we will
                    newhardware,orcanbeﬁxedusingamicrocodeupdate.                    discuss KAISER in more depth.
                      AsMeltdownexploitsout-of-order execution, a trivial               Although KAISER provides basic protection against
                    countermeasureistodisableout-of-orderexecutioncom-               Meltdown,itstillhassomelimitations. Duetothedesign
                    pletely. However, performance impacts would be devas-            of the x86 architecture, several privileged memory loca-
                    tating, as the parallelism of modern CPUs could not be           tions are still required to be mapped in user space [20],
                    leveraged anymore. Thus, this is not a viable solution.          leaving a residual attack surface for Meltdown, i.e., these
                      Meltdownissomeformofraceconditionbetweenthe                    memorylocationscanstillbereadfromuserspace. Even
                    fetch of a memory address and the corresponding per-             though these memory locations do not contain any se-
                    mission check for this address. Serializing the permis-          crets, e.g., credentials, they might still contain pointers.
                    sion check and the register fetch can prevent Meltdown,          Leaking one pointer can sufﬁce to break KASLR, as the
                    as the memory address is never fetched if the permission         randomization can be computed from the pointer value.
                    checkfails. However,thisinvolvesasigniﬁcantoverhead                 Still, KAISER is the best short-time solution currently
                    to every memory fetch, as the memory fetch has to stall          available and should therefore be deployed on all sys-
                    until the permission check is completed.                         tems immediately. Even with Meltdown, KAISER can
                      Amorerealistic solution would be to introduce a hard           avoid having any kernel pointers on memory locations
                    split of user space and kernel space. This could be en-          that are mapped in the user space which would leak in-
                    abled optionally by modern kernels using a new hard-             formation about the randomized offsets. This would re-
                    split bit in a CPU control register, e.g., CR4. If the hard-     quire trampoline locations for every kernel pointer, i.e.,
                    split bit is set, the kernel has to reside in the upper half     the interrupt handler would not call into kernel code di-
                    of the address space, and the user space has to reside in        rectly, but through a trampoline function. The trampo-
                    the lower half of the address space. With this hard split,       line function must only be mapped in the kernel. It must
                    a memoryfetchcanimmediatelyidentifywhethersucha                  be randomized with a different offset than the remaining
                    fetch of the destination would violate a security bound-         kernel. Consequently, an attacker can only leak pointers
                    ary, as the privilege level can be directly derived from         to the trampoline code, but not the randomized offsets of
                    the virtual address without any further lookups. We ex-          the remaining kernel. Such trampoline code is required
                    pect the performance impacts of such a solution to be            for every kernel memory that still has to be mapped in
                    minimal. Furthermore, the backwards compatibility is             user space and contains kernel addresses. This approach
                    ensured, since the hard-split bit is not set by default and      is a trade-off between performance and security which
                    the kernel only sets it if it supports the hard-split feature.   has to be assessed in future work.
                      Note that these countermeasures only prevent Melt-                The original KAISER patch [18] for the Linux kernel
                    down, and not the class of Spectre attacks described by          has been improved [24, 25, 26, 27] with various opti-
                    Kocheretal.[40]. Likewise,theirpresentedcountermea-              mizations, e.g., support for PCIDs. Afterwards, before
                    sures [40] do not affect Meltdown. We stress that it is im-      merging it into the mainline kernel, it has been renamed
                    portant to deploy countermeasures against both attacks.          to kernel page-table isolation (KPTI) [49, 15]. KPTI is
                                                                                     active in recent releases of the Linux kernel and has been
                                                                                     backported to older versions as well [30, 43, 44, 42].
                    7.2    KAISER                                                       Microsoft implemented a similar patch inspired by
                                                                                     KAISER [53] named KVA Shadow [39]. While KVA
                    As existing hardware is not as easy to patch, there is a         Shadow only maps a minimum of kernel transition
                    need for software workarounds until new hardware can             code and data pages required to switch between address
                    be deployed.    Gruss et al. [20] proposed KAISER, a             spaces, it does not protect against side-channel attacks
                    kernel modiﬁcation to not have the kernel mapped in              against KASLR [39].
                    the user space. This modiﬁcation was intended to pre-               Apple released updates in iOS 11.2, macOS 10.13.2
                    vent side-channel attacks breaking KASLR [29, 21, 37].           and tvOS 11.2 to mitigate Meltdown. Similar to Linux
                    However, it also prevents Meltdown, as it ensures that           andWindows,macOSsharedthekernelanduseraddress
                    there is no valid mapping to kernel space or physical            spaces in 64-bit mode unless the -no-shared-cr3 boot
                    memory available in user space.        In concurrent work        option was set [46]. This option unmaps the user space
                   while running in kernel mode but does not unmap the           such environments, which typically use containers, such
                   kernel while running in user mode [51]. Hence, it has         as Docker or OpenVZ, the kernel is shared among all
                   no effect on Meltdown. Consequently, Apple introduced         guests. Thus, the isolation between guests can simply be
                   DoubleMap[34]followingtheprinciplesofKAISERto                 circumvented with Meltdown, fully exposing the data of
                   mitigate Meltdown.                                            all other guests on the same host. For these providers,
                                                                                 changing their infrastructure to full virtualization or us-
                   8   Discussion                                                ing software workarounds such as KAISER would both
                                                                                 increase the costs signiﬁcantly.
                   Meltdownfundamentallychangesourperspective on the               Concurrent work has investigated the possibility to
                   security of hardware optimizations that manipulate the        read kernel memory via out-of-order or speculative ex-
                   state of microarchitectural elements. The fact that hard-     ecution, but has not succeeded [13, 50]. We are the ﬁrst
                   ware optimizations can change the state of microar-           to demonstrate that it is possible. Even if Meltdown is
                   chitectural elements, and thereby imperil secure soft-        ﬁxed, Spectre [40] will remain an issue, requiring differ-
                   ware implementations, is known since more than 20             ent defenses. Mitigating only one of them will leave the
                   years [41]. Both industry and the scientiﬁc community         security of the entire system at risk. Meltdown and Spec-
                   so far accepted this as a necessary evil for efﬁcient com-    tre open a new ﬁeld of research to investigate to what ex-
                   puting.  Today it is considered a bug when a crypto-          tent performance optimizations change the microarchi-
                   graphic algorithm is not protected against the microar-       tectural state, how this state can be translated into an ar-
                   chitectural leakage introduced by the hardware optimiza-      chitectural state, and how such attacks can be prevented.
                   tions. Meltdown changes the situation entirely. Melt-
                   down shifts the granularity from a comparably low spa-        9   Conclusion
                   tial and temporal granularity, e.g., 64-bytes every few
                   hundred cycles for cache attacks, to an arbitrary granu-
                   larity, allowing an attacker to read every single bit. This   In this paper, we presented Meltdown, a novel software-
                   is nothing any (cryptographic) algorithm can protect it-      based attack exploiting out-of-order execution and side
                   self against. KAISERisashort-termsoftwareﬁx,butthe            channels on modern processors to read arbitrary ker-
                   problem we have uncovered is much more signiﬁcant.            nel memory from an unprivileged user space program.
                     Weexpectseveral more performance optimizations in           Without requiring any software vulnerability and inde-
                   modern CPUs which affect the microarchitectural state         pendent of the operating system, Meltdown enables an
                   in some way, not even necessarily through the cache.          adversary to read sensitive data of other processes or vir-
                   Thus, hardware which is designed to provide certain se-       tual machines in the cloud with up to 503KB/s, affect-
                   curity guarantees, e.g., CPUs running untrusted code, re-     ing millions of devices. We showed that the counter-
                   quires a redesign to avoid Meltdown- and Spectre-like         measure KAISER, originally proposed to protect from
                   attacks. Meltdown also shows that even error-free soft-       side-channel attacks against KASLR, inadvertently im-
                   ware, which is explicitly written to thwart side-channel      pedes Meltdown as well. We stress that KAISER needs
                   attacks, is not secure if the design of the underlying hard-  to be deployed on every operating system as a short-term
                   ware is not taken into account.                               workaround,until Meltdownisﬁxedinhardware,topre-
                     With the integration of KAISER into all major oper-         vent large-scale exploitation of Meltdown.
                   ating systems, an important step has already been done
                   to prevent Meltdown. KAISER is a fundamental change           Acknowledgments
                   in operating system design. Instead of always mapping
                   everything into the address space, mapping only the min-
                   imally required memory locations appears to be a ﬁrst         Several authors of this paper found Meltdown indepen-
                   step in reducing the attack surface. However, it might not    dently, ultimately leading to this collaboration. We want
                   be enough, and even stronger isolation may be required.       to thank everyone who helped us in making this collabo-
                   In this case, we can trade ﬂexibility for performance and     ration possible, especially Intel who handled our respon-
                   security, by e.g., enforcing a certain virtual memory lay-    sible disclosure professionally, comunicatedacleartime-
                   out for every operating system. As most modern oper-          line and connected all involved researchers. We thank
                   ating systems already use a similar memory layout, this       Mark Brand from Google Project Zero for contributing
                   might be a promising approach.                                ideas and Peter Cordes and Henry Wong for valuable
                     Meltdown also heavily affects cloud providers, espe-        feedback. We would like to thank our anonymous re-
                   cially if the guests are not fully virtualized.  For per-     viewers for their valuable feedback. Furthermore, we
                   formance reasons, many hosting or cloud providers do          would like to thank Intel, ARM, Qualcomm, and Mi-
                   not have an abstraction layer for virtual memory.      In     crosoft for feedback on an early draft.
                          Daniel Gruss, Moritz Lipp, Stefan Mangard and                            [15] GLEIXNER, T.          x86/kpti:    Kernel Page Table Isolation
                       Michael Schwarz were supported by the European Re-                                (was KAISER), https://lkml.org/lkml/2017/12/4/709
                       search Council (ERC) under the European Union’s Hori-                             Dec2017.
                       zon 2020 research and innovation programme (grant                           [16] GRAS, B., RAZAVI, K., BOSMAN, E., BOS, H., AND GIUF-
                       agreement No 681402).                                                             FRIDA, C. ASLR on the Line: Practical Cache Attacks on the
                                                                                                         MMU. InNDSS(2017).
                          Daniel Genkin was supported by NSF awards                                [17] GRISENTHWAITE, R. Cache Speculation Side-channels, 2018.
                       #1514261 and #1652259, ﬁnancial assistance award                            [18] GRUSS, D. [RFC,PATCH]x86 64: KAISER-donotmapkernel
                       70NANB15H328 from the U.S. Department of Com-                                     in user mode, https://lkml.org/lkml/2017/5/4/220 May
                       merce, National Institute of Standards and Technol-                               2017.
                       ogy, the 2017-2018 Rothschild Postdoctoral Fellowship,                      [19] GRUSS, D., LETTNER, J., SCHUSTER, F., OHRIMENKO, O.,
                       and the Defense Advanced Research Project Agency                                  HALLER, I., AND COSTA, M. Strong and Efﬁcient Cache Side-
                       (DARPA)underContract#FA8650-16-C-7622.                                            Channel Protection using Hardware Transactional Memory. In
                                                                                                         USENIXSecurity Symposium (2017).
                                                                                                   [20] GRUSS, D., LIPP, M., SCHWARZ, M., FELLNER, R., MAU-
                       References                                                                        RICE, C., AND MANGARD, S. KASLR is Dead: Long Live
                                                                                                         KASLR. In International Symposium on Engineering Secure
                        [1] AMD. Software techniques for managing speculation on AMD                     Software and Systems (2017), Springer, pp. 161–176.
                             processors, 2018.                                                     [21] GRUSS, D., MAURICE, C., FOGH, A., LIPP, M., AND MAN-
                        [2] ARM.           AArch64 Linux kernel port (KPTI base),                        GARD, S. Prefetch Side-Channel Attacks: Bypassing SMAP and
                             https://git.kernel.org/pub/scm/linux/kernel/                                Kernel ASLR. In CCS (2016).
                             git/arm64/linux.git/log/?h=kpti2018.                                  [22] GRUSS, D., MAURICE, C., WAGNER, K., AND MANGARD,
                        [3] ARM LIMITED. ARM CoreLink CCI-400 Cache Coherent In-                         S. Flush+Flush: A Fast and Stealthy Cache Attack. In DIMVA
                             terconnect Technical Reference Manual, r1p5 ed. ARM Limited,                (2016).
                             2015.                                                                 [23] GRUSS, D., SPREITZER, R., AND MANGARD, S.                   Cache
                        [4] BENGER, N., VAN DE POL, J., SMART, N. P., AND YAROM, Y.                      Template Attacks: Automating Attacks on Inclusive Last-Level
                             “Ooh Aah... Just a Little Bit”: A small amount of side channel              Caches. In USENIX Security Symposium (2015).
                             can go a long way. In CHES’14 (2014).                                 [24] HANSEN,D.[PATCH00/23]KAISER:unmapmostofthekernel
                        [5] BOLDIN, P. Meltdown reading other process’s memory, https:                   from userspace page tables, https://lkml.org/lkml/2017/
                             //www.youtube.com/watch?v=EMBGXswJC4sJan2018.                               10/31/884Oct2017.
                                                                                                   [25] HANSEN, D. [v2] KAISER: unmap most of the kernel from
                        [6] BURGESS, B. Samsung Exynos M1 Processor. In IEEE Hot                         userspace page tables, https://lkml.org/lkml/2017/11/
                             Chips (2016).                                                               8/752Nov2017.
                        [7] CARVALHO, R.         Twitter:  Meltdown with uncached mem-             [26] HANSEN, D. [v3] KAISER: unmap most of the kernel from
                             ory,      https://twitter.com/raphael_scarv/status/                         userspace page tables, https://lkml.org/lkml/2017/11/
                             952078140028964864Jan2018.                                                  10/433Nov2017.
                        [8] CHENG, C.-C.       The schemes and performances of dynamic             [27] HANSEN, D. [v4] KAISER: unmap most of the kernel from
                             branch predictors. Berkeley Wireless Research Center, Tech. Rep             userspace page tables, https://lkml.org/lkml/2017/11/
                             (2000).                                                                     22/956Nov2017.
                        [9] DEVIES, A. M.         AMD Takes Computing to a New Hori-               [28] HENNESSY, J. L., AND PATTERSON, D. A. Computer Architec-
                                               TM                                                        ture: A Quantitative Approach, 6 ed. Morgan Kaufmann, 2017.
                             zon with Ryzen       Processors, https://www.amd.com/en-
                             us/press-releases/Pages/amd-takes-computing-                          [29] HUND, R., WILLEMS, C., AND HOLZ, T. PracticalTimingSide
                             2016dec13.aspx2016.                                                         Channel Attacks against Kernel Space ASLR. In S&P (2013).
                       [10] ECLYPSIUM. System Management Mode Speculative Execution                [30] HUTCHINGS, B. Linux 3.16.53, https://cdn.kernel.org/
                             Attacks,      https://blog.eclypsium.com/2018/05/17/                        pub/linux/kernel/v3.x/ChangeLog-3.16.532018.
                             system-management-mode-speculative-execution-                         [31] INTEL. An introduction to the intel quickpath interconnect, Jan
                             attacks/May2018.                                                            2009.
                       [11] EDGE, J. Kernel address space layout randomization, https:                                 R
                             //lwn.net/Articles/569635/2013.                                       [32] INTEL. Intel 64 and IA-32 Architectures Optimization Refer-
                                                                                                         ence Manual, 2017.
                       [12] EICKEMEYER, R., LE, H., NGUYEN, D., STOLT, B., AND                     [33] INTEL. Intel analysis of speculative execution side channels,
                             THOMPTO, B.        Load lookahead prefetch for microproces-                 https://newsroom.intel.com/wp-content/uploads/
                             sors, 2006.     https://encrypted.google.com/patents/                       sites/11/2018/01/Intel-Analysis-of-Speculative-
                             US20060149935USPatentApp.11/016,236.                                        Execution-Side-Channels.pdfJan2018.
                       [13] FOGH, A.      Negative Result: Reading Kernel Memory From              [34] IONESCU, A. Twitter: Apple Double Map, https://twitter.
                             User Mode, https://cyber.wtf/2017/07/28/negative-                           com/aionescu/status/9486098095400468492017.
                             result-reading-kernel-memory-from-user-mode/                          [35] IONESCU,       A.       Twitter:     Meltdown with uncached
                             2017.                                                                       memory,          https://twitter.com/aionescu/status/
                       [14] GENS, D., ARIAS, O., SULLIVAN, D., LIEBCHEN, C., JIN, Y.,                    950994906759143425Jan2018.
                             AND SADEGHI, A.-R. Lazarus: Practical side-channel resilient          [36] IRAZOQUI, G., INCI, M. S., EISENBARTH, T., AND SUNAR, B.
                             kernel-space randomization. In International Symposium on Re-               Wait a minute! A fast, Cross-VM attack on AES. In RAID’14
                             search in Attacks, Intrusions, and Defenses (2017).                         (2014).
                     [37] JANG, Y., LEE, S., AND KIM, T. Breaking Kernel Address         [56] PERCIVAL, C. Cache missing for fun and proﬁt. In Proceedings
                          Space Layout Randomization with Intel TSX. In CCS (2016).           of BSDCan(2005).
                             ´
                     [38] JIMENEZ, D. A., AND LIN, C. Dynamic branch prediction with     [57] PHORONIX.       Linux 4.12 To Enable KASLR By De-
                          perceptrons. In High-Performance Computer Architecture, 2001.       fault, https://www.phoronix.com/scan.php?page=news_
                          HPCA. The Seventh International Symposium on (2001), IEEE,          item&px=KASLR-Default-Linux-4.122017.
                          pp. 197–206.                                                   [58] SCHWARZ, M., LIPP, M., GRUSS, D., WEISER, S., MAURICE,
                     [39] JOHNSON, K. KVAShadow: MitigatingMeltdownonWindows,                 C., SPREITZER, R., AND MANGARD, S. KeyDrown: Eliminat-
                          https://blogs.technet.microsoft.com/srd/2018/03/                    ing Software-Based Keystroke Timing Side-Channel Attacks. In
                          23/kva-shadow-mitigating-meltdown-on-windows/                       NDSS’18(2018).
                          Mar2018.                                                       [59] SORIN, D. J., HILL, M. D., AND WOOD, D. A. A Primer on
                     [40] KOCHER, P., HORN, J., FOGH, A., GENKIN, D., GRUSS,                  MemoryConsistency and Cache Coherence. 2011.
                          G., HAAS, W., HAMBURG, M., LIPP, M., MANGARD, S.,                                                  ´
                          PRESCHER, T., SCHWARZ, M., AND YAROM, Y. Spectre at-           [60] TERAN, E., WANG, Z., AND JIMENEZ, D. A. Perceptron learn-
                          tacks: Exploiting speculative execution. In S&P (2019). A pre-      ing for reuse prediction. In Microarchitecture (MICRO), 2016
                          print was published in 2018 as arXiv:1801.01203.                    49th Annual IEEE/ACM International Symposium on (2016),
                                                                                              IEEE, pp. 1–12.
                     [41] KOCHER, P. C. Timing Attacks on Implementations of Diffe-      [61] TOMASULO, R. M. An efﬁcient algorithm for exploiting multi-
                          Hellman, RSA, DSS, and Other Systems. In CRYPTO (1996).             ple arithmetic units. IBM Journal of research and Development
                     [42] KROAH-HARTMAN, G.          Linux 4.14.11, https://cdn.              11, 1 (1967), 25–33.
                          kernel.org/pub/linux/kernel/v4.x/ChangeLog-                    [62] VINTAN, L. N., AND IRIDON, M. Towards a high performance
                          4.14.112018.                                                        neural branch predictor. In Neural Networks, 1999. IJCNN’99.
                     [43] KROAH-HARTMAN, G.          Linux 4.4.110, https://cdn.              International Joint Conference on (1999), vol. 2, IEEE, pp. 868–
                          kernel.org/pub/linux/kernel/v4.x/ChangeLog-                         873.
                          4.4.1102018.                                                   [63] YAROM, Y., AND FALKNER, K. Flush+Reload: a High Reso-
                     [44] KROAH-HARTMAN, G. Linux 4.9.75, https://cdn.kernel.                 lution, Low Noise, L3 Cache Side-Channel Attack. In USENIX
                          org/pub/linux/kernel/v4.x/ChangeLog-4.9.752018.                     Security Symposium (2014).
                     [45] LEE, B., MALISHEVSKY, A., BECK, D., SCHMID, A., AND            [64] YEH, T.-Y., AND PATT, Y. N.      Two-level adaptive training
                          LANDRY, E. Dynamic branch prediction. Oregon State Univer-          branch prediction. In Proceedings of the 24th annual interna-
                          sity.                                                               tional symposium on Microarchitecture (1991), ACM, pp. 51–61.
                     [46] LEVIN, J. Mac OS X and IOS Internals: To the Apple’s Core.     [65] ZHANG, Y., JUELS, A., REITER, M. K., AND RISTENPART,
                          John Wiley & Sons, 2012.                                            T. Cross-Tenant Side-Channel Attacks in PaaS Clouds. In CCS
                     [47] LIPP, M., GRUSS, D., SPREITZER, R., MAURICE, C., AND                (2014).
                          MANGARD, S. ARMageddon: Cache Attacks on Mobile De-
                          vices. In USENIX Security Symposium (2016).                    A MeltdowninPractice
                     [48] LIU, F., YAROM, Y., GE, Q., HEISER, G., AND LEE, R. B.
                          Last-Level Cache Side-Channel Attacks are Practical. In IEEE   In this section, we show how Meltdown can be used in
                          SymposiumonSecurityandPrivacy–SP(2015),IEEEComputer
                          Society, pp. 605–622.                                          practice. In Appendix A.1, we show physical memory
                     [49] LWN.Thecurrentstateofkernelpage-tableisolation,https://        dumps obtained via Meltdown, including passwords of
                          lwn.net/SubscriberLink/741878/eb6c9d3913d7cb2b/                the Firefox password manager. In Appendix A.2, we
                          Dec. 2017.                                                     demonstrate a real-world exploit.
                     [50] MAISURADZE, G., AND ROSSOW, C.         Speculose: Analyz-
                          ing the Security Implications of Speculative Execution in CPUs.
                          arXiv:1801.04084 (2018).                                       A.1     Physical-memory Dump using Melt-
                     [51] MANDT, T. Attacking the iOS Kernel: A Look at ’evasi0n’,               down
                          www.nislab.no/content/download/38610/481190/
                          file/NISlecture201303.pdf2013.                                 Listing 3 shows a memory dump using Meltdown on
                     [52] MAURICE, C., WEBER, M., SCHWARZ, M., GINER, L.,                an Intel Core i7-6700K running Ubuntu 16.10 with the
                          GRUSS, D., ALBERTO BOANO, C., MANGARD, S., AND                 Linux kernel 4.8.0.      In this example, we can identify
                            ¨
                          ROMER, K. Hello from the Other Side: SSH over Robust Cache     HTTP headers of a request to a web server running on
                          Covert Channels in the Cloud. In NDSS (2017).                  the machine. TheXXcasesrepresentbyteswheretheside
                     [53] MILLER, M. Mitigatingspeculativeexecutionsidechannelhard-      channel did not yield any results, i.e., no Flush+Reload
                          ware vulnerabilities, https://blogs.technet.microsoft.
                          com/srd/2018/03/15/mitigating-speculative-                     hit. Additional repetitions of the attack may still be able
                          execution-side-channel-hardware-vulnerabilities/               to read these bytes.
                          Mar2018.                                                          Listing 4 shows a memory dump of Firefox 56 using
                     [54] MOLNAR,      I.       x86:     Enable   KASLR by de-           Meltdown on the same machine. We can clearly iden-
                          fault,        https://git.kernel.org/pub/scm/linux/            tify some of the passwords that are stored in the internal
                          kernel/git/torvalds/linux.git/commit/?id=                      password manager, i.e., Dolphin18, insta 0203, and
                          6807c84652b0b7e2e198e50a9ad47ef41b236e592017.
                     [55] OSVIK, D. A., SHAMIR, A., AND TROMER, E. Cache Attacks         secretpwd0. The attack also recovered a URL which
                          and Countermeasures: the Case of AES. In CT-RSA (2006).        appears to be related to a Firefox add-on.
                             79cbb80: 6c4c 48 32 5a 78 66 56 44  73 4b 57 39 34 68 6d |lLH2ZxfVDsKW94hm|                  f94b76f0: 12 XX e0 81 19 XX e0 81 44  6f 6c 70 68 69 6e 31 |........Dolphin1|
                             79cbb90: 3364 2f 41 4d 41 45 44 41  41 41 41 41 51 45 42 |3d/AMAEDAAAAAQEB|                  f94b7700: 38 e5 e5 e5 e5 e5 e5 e5 e5  e5 e5 e5 e5 e5 e5 e5 |8...............|
                             79cbba0: 4141 41 41 41 41 3d 3d XX  XX XX XX XX XX XX XX |AAAAAA==........|                  f94b7710: 70 52 b8 6b 96 7f XX XX XX  XX XX XX XX XX XX XX |pR.k............|
                             79cbbb0: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7720: XX XX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|
                             79cbbc0: XXXX XX 65 2d 68 65 61 64  XX XX XX XX XX XX XX |...e-head.......|                  f94b7730: XX XX XX XX 4a XX XX XX XX  XX XX XX XX XX XX XX |....J...........|
                             79cbbd0: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7740: XX XX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|
                             79cbbe0: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7750: XX XX XX XX XX XX XX XX XX  XX e0 81 69 6e 73 74 |............inst|
                             79cbbf0: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7760: 61 5f 30 32 30 33 e5 e5 e5  e5 e5 e5 e5 e5 e5 e5 |a_0203..........|
                             79cbc00: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7770: 70 52 18 7d 28 7f XX XX XX  XX XX XX XX XX XX XX |pR.}(...........|
                             79cbc10: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7780: XX XX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|
                             79cbc20: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b7790: XX XX XX XX 54 XX XX XX XX  XX XX XX XX XX XX XX |....T...........|
                             79cbc30: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b77a0: XX XX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|
                             79cbc40: XXXX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|                  f94b77b0: XX XX XX XX XX XX XX XX XX  XX XX XX 73 65 63 72 |............secr|
                             79cbc50: XXXX XX XX 0d 0a XX 6f 72  69 67 69 6e 61 6c 2d |.......original-|                  f94b77c0: 65 74 70 77 64 30 e5 e5 e5  e5 e5 e5 e5 e5 e5 e5 |etpwd0..........|
                             79cbc60: 7265 73 70 6f 6e 73 65 2d  68 65 61 64 65 72 73 |response-headers|                  f94b77d0: 30 b4 18 7d 28 7f XX XX XX  XX XX XX XX XX XX XX |0..}(...........|
                             79cbc70: XX44 61 74 65 3a 20 53 61  74 2c 20 30 39 20 44 |.Date: Sat, 09 D|                  f94b77e0: XX XX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|
                             79cbc80: 6563 20 32 30 31 37 20 32  32 3a 32 39 3a 32 35 |ec 2017 22:29:25|                  f94b77f0: XX XX XX XX XX XX XX XX XX  XX XX XX XX XX XX XX |................|
                             79cbc90: 2047 4d 54 0d 0a 43 6f 6e  74 65 6e 74 2d 4c 65 | GMT..Content-Le|                  f94b7800: e5 e5 e5 e5 e5 e5 e5 e5 e5  e5 e5 e5 e5 e5 e5 e5 |................|
                             79cbca0: 6e67 74 68 3a 20 31 0d 0a  43 6f 6e 74 65 6e 74 |ngth: 1..Content|                  f94b7810: 68 74 74 70 73 3a 2f 2f 61  64 64 6f 6e 73 2e 63 |https://addons.c|
                             79cbcb0: 2d54 79 70 65 3a 20 74 65  78 74 2f 68 74 6d 6c |-Type: text/html|                  f94b7820: 64 6e 2e 6d 6f 7a 69 6c 6c  61 2e 6e 65 74 2f 75 |dn.mozilla.net/u|
                             79cbcc0: 3b20 63 68 61 72 73 65 74  3d 75 74 66 2d 38 0d |; charset=utf-8.|                  f94b7830: 73 65 72 2d 6d 65 64 69 61  2f 61 64 64 6f 6e 5f |ser-media/addon_|
                            Listing (3) MemorydumpshowingHTTPHeadersonUbuntu                                            Listing (4) Memory dump of Firefox 56 on Ubuntu 16.10 on
                            16.10 on a Intel Core i7-6700K                                                              a Intel Core i7-6700K disclosing saved passwords.
                            A.2        Real-world Meltdown Exploit                                                      ofthekerneladdressspace. Theremainderofthissection
                            In this section, we present a real-world exploit showing                                    assumes that addresses are already de-randomized using
                            the applicability of Meltdown in practice, implemented                                      the detected offset.
                            byPavelBoldinincollaboration with Raphael Carvalho.                                         A.2.2       Locating the Victim Process
                            Theexploitdumpsthememoryofaspeciﬁcprocess,pro-
                            vided either the process id (PID) or the process name.                                      Linux manages all processes (including their hierarchy)
                                First, the exploit de-randomizes the kernel address                                     in a linked list. The head of this task list is stored in the
                            space layout to be able to access internal kernel struc-                                    init task structure, which is at a ﬁxed offset that only
                            tures. Second, the kernel’s task list is traversed until the                                varies among different kernel builds. Thus, knowledge
                            victim process is found. Finally, the root of the victim’s                                  of the kernel build is sufﬁcient to locate the task list.
                            multilevel page table is extracted from the task structure                                      Among other members, each task list structure con-
                            and traversed to dump any of the victim’s pages.                                            tains a pointer to the next element in the task list as well
                                Thethree steps of the exploit are combined to an end-                                   as a task’s PID, name, and the root of the multilevel page
                            to-end exploit which targets a speciﬁc kernel build and                                     table. Thus, the exploit traverses the task list until the
                            a speciﬁc victim. The exploit can easily be adapted to                                      victim process is found.
                            work on any kernel build. The only requirement is ac-
                            cess to either the binary or the symbol table of the kernel,                                A.2.3       DumpingtheVictimProcess
                            which is true for all public kernels which are distributed
                            as packages, i.e., not self-compiled. In the remainder                                      The root of the multilevel page table is extracted from
                            of this section, we provide a detailed explanation of the                                   the victim’s task list entry.                The page table entries on
                            three steps.                                                                                all levels are physical page addresses. Meltdown can
                                                                                                                        read these addresses via the direct-physical map, i.e., by
                            A.2.1       Breaking KASLR                                                                  adding the base address of the direct-physical map to the
                                                                                                                        physical addresses. This base address is 0xffff 8800
                            The ﬁrst step is to de-randomize KASLR to access in-                                        0000 0000ifthedirect-physicalmapisnotrandomized.
                            ternal kernel structures.               The exploit locates a known                         If the direct-physical map is randomized, it can be ex-
                            value inside the kernel, speciﬁcally the Linux banner                                       tracted from the kernel’s page offset base variable.
                            string, as the content is known and it is large enough to                                       Starting at the root of the victim’s multilevel page ta-
                            rule out false positives. It starts looking for the banner                                  ble, the exploit can simply traverse the levels down to the
                            string at the (non-randomized) default address according                                    lowest level. For a speciﬁc address of the victim, the ex-
                            to the symbol table of the running kernel. If the string                                    ploit uses the paging structures to resolve the respective
                            is not found, the next attempt is made at the next pos-                                     physical address and read the content of this physical ad-
                            sible randomized address until the target is found. As                                      dress via the direct-physical map. The exploit can also
                            the Linux KASLR implementation only has an entropy                                          be easily extended to enumerate all pages belonging to
                            of 6 bits [37], there are only 64 possible randomization                                    the victim process, and then dump any (or all) of these
                            offsets, making this approach practical.                                                    pages.
                                Thedifferencebetweenthefoundaddressandthenon-
                            randomizedbaseaddressisthentherandomizationoffset
