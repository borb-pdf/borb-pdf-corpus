                                Simplicity: A New Language for Blockchains
                                                       Russell O’Connor
                                                 roconnor@blockstream.com
                                                          2017-12-13
                                                            Abstract
                                    Simplicity is a typed, combinator-based, functional language without
                                 loops and recursion, designed to be used for crypto-currencies and block-
                                 chain applications. It aims to improve upon existing crypto-currency lan-
                                 guages, such as Bitcoin Script and Ethereum’s EVM, while avoiding some
                                 of the problems they face. Simplicity comes with formal denotational
                                 semantics deﬁned in Coq, a popular, general purpose software proof as-
                                 sistant. Simplicity also includes operational semantics that are deﬁned
                                 with an abstract machine that we call the Bit Machine. The Bit Ma-
                                 chine is used as a tool for measuring the computational space and time
                                 resources needed to evaluate Simplicity programs. Owing to its Turing
                                 incompleteness, Simplicity is amenable to static analysis that can be used
                                 to derive upper bounds on the computational resources needed, prior to
                                 execution. While Turing incomplete, Simplicity can express any ﬁnitary
                                 function, which we believe is enough to build useful “smart contracts” for
                                 blockchain applications.
                            0    License
                            This  work is licensed    under  a  Creative  Com-
                            mons    “Attribution   4.0   International” license.
                            〈https://creativecommons.org/licenses/by/4.0/deed.en〉
                            1    Introduction
                            Blockchain and distributed ledger technologies deﬁne protocols that allow large,
                            ad-hoc, groups of users to transfer value between themselves without needing
                            to trust each other or any central authority. Using public-key cryptography,
                            users can sign transactions that transfer ownership of funds to other users. To
                            prevent transactions from conﬂicting with each other, for example when one
                            user attempts to transfer the same funds to multiple diﬀerent users at the same
                            time, a consistent sequence of blocks of transactions is committed using a proof
                            of work scheme. This proof of work is created by participants called miners.
                            Each user veriﬁes every block of transactions; among multiple sequences of valid
                            blocks, the sequence with the most proof of work is declared to be authoritative.
                                                               1
                           Bitcoin [20] was the ﬁrst protocol to use this blockchain technology to create
                        a secure and permissionless crypto-currency. It comes with a built-in program-
                        ming language, called Bitcoin Script [6, 22], which determines if a transaction
                        is authorized to transfer funds. Rather than sending funds to a speciﬁc party,
                        users send funds to a speciﬁc Bitcoin Script program. This program guards the
                        funds and only allows them to be redeemed by a transaction input that causes
                        the program to return successfully. Every peer in the Bitcoin network must exe-
                        cute each of these programs with the input provided by the transaction data and
                        all these programs must return successfully in order for the given transaction to
                        be considered valid.
                           A typical program speciﬁes a public key and simply requires that a valid
                        digital signature of the transaction for that key be provided. Only someone
                        with knowledge of the corresponding private key can create such a signature.
                           Funds can be guarded by more complex programs. Examples range from
                        simpler programs that require signatures from multiple parties, permitting es-
                        crow services [14], to more complex programs that allow for zero-knowledge
                        contingent payments [19], allowing for trustless and atomic purchases of digital
                        data. This last example illustrates how Bitcoin Script can be used to build
                        smart contracts, which allow parties to create conditional transactions that are
                        enforced by the protocol itself.
                           Because of its Script language, Bitcoin is sometimes described as pro-
                        grammable money.
                        1.1  Bitcoin Script
                        Bitcoin Script is a stack-based language similar to Forth. A program in Bitcoin
                        Script is a sequence of operations for its stack machine. Bitcoin Script has
                        conditionals but no loops, thus all programs halt and the language is not Turing
                        complete.
                           Originally, these programs were committed as part of the output ﬁeld of a
                        Bitcoin transaction. The program from the output being redeemed is executed
                        starting with the initial stack provided by the input redeeming it. The program
                        is successful if it completes without crashing and leaves a non-zero value on the
                        top of stack.
                           Later, a new option called pay to script hash (P2SH) [1] was added to Bitcoin.
                        Using this option, programs are committed by specifying a hash of the source
                        code as part of the output ﬁeld of a Bitcoin transaction. The input ﬁeld of a
                        redeeming Bitcoin transaction then provides both the program and the initial
                        stack for the program. The transaction is valid if the hash of the provided
                        program matches the hash speciﬁed in the output being redeemed, and if that
                        program executes successfully with the provided input, as before. The main
                        eﬀect here is moving the cost of large programs from the person sending funds
                        to the person redeeming funds.
                           Bitcoin Script has some drawbacks. Many operations were disabled by Bit-
                        coin’s creator, Satoshi Nakamoto [21]. This has left Bitcoin Script with a few
                        arithmetic (multiplication was disabled), conditional, stack manipulation, hash-
                                                     2
                               ing, and digital-signature veriﬁcation operations. In practice, almost all pro-
                               grams found in Bitcoin follow a small set of simple templates to perform digital
                               signature veriﬁcation.
                                   However, Bitcoin Script also has some desirable properties.    All Bitcoin
                               Script operations are pure functions of the machine state except for the
                               signature-veriﬁcation operations.  These signature-veriﬁcation operations re-
                               quire a hash of some of the transaction data. Together, this means the pro-
                               gram’s success or failure is purely a function of the transaction data. Therefore,
                               the person creating a transaction can know whether the transaction they have
                               created is valid or not.
                                   Bitcoin Script is also amenable to static analysis, which is another desirable
                               property. The digital-signature veriﬁcation operations are the most expensive
                               operations. Prior to execution, Bitcoin counts the number of occurrences of
                               these operations to compute an upper bound on the number of expensive calls
                               that may occur. Programs whose count exceeds a certain threshold are invalid.
                               This is a form of static analysis that ensures the amount of computation that
                               will be done isn’t excessive.  Moreover, before committing a program to an
                               output, the creator of the program can ensure that the amount of computation
                               that will be done will not be excessive.
                               1.2    Ethereum and the EVM
                               Ethereum [31] is another crypto-currency with programmable transactions. It
                               deﬁnes a language called EVM for its transactions. While more expressive and
                               ﬂexible than Bitcoin Script, the design of Ethereum and the EVM has several
                               issues.
                                   TheEVMisaTuring-completeprogramminglanguagewithastack, random
                               access memory, and persistent storage. To prevent inﬁnite loops, execution is
                               limited by a counter called gas, which is paid for in Ethereum’s unit of account,
                               Ether, to the miner of the block containing the transaction. Static analysis isn’t
                               practical with a Turing-complete language. Therefore, when a program runs
                               out of gas, the transaction is nulliﬁed but the gas is still paid to the miner to
                               ensure they are compensated for their computation eﬀorts.
                                   Because of direct access to persistent storage, EVM programs are a function
                               of both the transaction and the state of the blockchain at the point the transac-
                               tion is inserted into the blockchain. This means users cannot necessarily know
                               what the result of their transaction will be when they create it, nor can they
                               necessarily know how much gas will be consumed. Users must provide enough
                               gas to cover the worst-case use scenario and there is no general purpose algo-
                               rithm that can compute that bound. In particular, there is no practical general
                               purpose way to tell if any given program will run out of gas in some context
                               either at redemption time or creation time. There have been some eﬀorts to
                               perform static analysis on a subset of the EVM language [5], but these tools are
                               limited (e.g. they do not support programs with loops).
                                   Unlike Bitcoin, there are many instances of ad-hoc, one-oﬀ, special purpose
                               programs in Ethereum. These programs are usually written in a language called
                                                                      3
                        Solidity [12] and compiled to the EVM. These ad-hoc programs are regularly
                        broken owing to the complex semantics of both Solidity and the EVM; the
                        most famous of these failures were the DAO [8] and Parity’s multiple signature
                        validation program [26].
                        1.3  ANewLanguage
                        In this paper, we propose a new language that maintains or enhances the desir-
                        able properties that Bitcoin Script has while adding expressiveness. Our design
                        goals are:
                           • Create an expressive language that provides users with the tools needed
                            to build novel programs and smart contracts.
                           • Enable static analysis that provides useful upper bounds on the amount
                            of computation required.
                           • Minimize bandwidth and storage requirements and enhance privacy by
                            removing unused code at redemption time.
                           • Maintain Bitcoin’s design of self-contained transactions whereby programs
                            do not have access to any information outside the transaction.
                           • Provide formal semantics that facilitate easy reasoning about programs
                            using existing oﬀ-the-shelf proof-assistant software.
                           Afew of these goals deserve additional explanation:
                           Static analysis allows the protocol to place limits on the amount of compu-
                        tation a transaction can have, so that nodes running the protocol are not overly
                        burdened. Furthermore, the static analysis can provide program creators with
                        a general purpose tool for verifying that the programs they build will always
                        ﬁt within these limits. Additionally, it is easy for the other participants in a
                        contract to check the bounds on the smart contract’s programs themselves.
                           Self-contained transactions ensure that execution does not depend on the
                        global state of the blockchain. Once a transaction’s programs have been vali-
                        dated, that fact can be cached. This is particularly useful when transactions
                        are being passed around the network before inclusion in the blockchain; once
                        included in the blockchain, the programs do not need to be executed again.
                           Finally, formal semantics that work with proof-assistant software provide
                        the opportunity for contract developers to reason about their programs to rule
                        out logical errors and to help avoid scenarios like the DAO and Parity’s multi-
                        signature program failure.
                           Like Bitcoin Script and the EVM, our language is designed as low-level
                        language for executing smart contracts, not as a language for coding in directly.
                        As such, we expect it to be a target for other, higher-level, languages to be
                        compiled to.
                           Wecall our new language Simplicity.
                                                     4
                                                                             s : A ⊢ B    t : B ⊢ C
                                                    iden : A ⊢ A                compst:A⊢C
                                                                 unit : A ⊢ 1
                                                     t : A ⊢ B                     t : A ⊢ C
                                                 injl t : A ⊢ B + C            injr t : A ⊢ B + C
                                          s : A × C ⊢ D     t : B × C ⊢ D    s : A ⊢ B    t : A ⊢ C
                                             casest : (A +B)×C ⊢ D            pairst : A ⊢ B ×C
                                                     t : A ⊢ C                     t : B ⊢ C
                                                 taket : A × B ⊢ C             dropt : A ×B ⊢ C
                                           Figure 1: Typing rules for the terms of core Simplicity.
                               2     Core Simplicity
                               Simplicity is a typed combinator language. Each well-typed Simplicity expres-
                               sion is associated with two types, an input type and an output type. Every
                               expression denotes a function from its input type to its output type.
                               2.1    Types in Simplicity
                               Types in Simplicity come in three ﬂavors.
                                   • The unit type, written as 1, is the type with one element.
                                   • A sum type, written as A + B, contains the tagged union of values from
                                     either the left type A or the right type B.
                                   • Aproduct type, written as A×B, contains pairs of elements with the ﬁrst
                                     one from the type A and the second one from the type B.
                                   There are no recursive types in Simplicity. Every type in Simplicity only
                               contains a ﬁnite number of values; the number of possible values a type contains
                               can be computed by interpreting the type as an arithmetic expression.
                               2.2    Terms in Simplicity
                               ThetermlanguageforSimplicityisbasedonGentzen’ssequentcalculus[13]. We
                               write a type-annotated Simplicity expression as t : A ⊢ B where t a Simplicity
                               expression, A is the expression’s input type, and B is the expression’s output
                               type.
                                                                      5
                           The core of Simplicity consists of nine combinators for building expressions.
                        They capture the fundamental operations for the three ﬂavors of types in Sim-
                        plicity. The typing rules for these nine combinators is given in Figure 1.
                           Wecan classify the combinators based on the ﬂavor of types they support.
                           • The unit term returns the singular value of the unit type and ignores its
                            argument.
                           • The injl and injr combinators create tagged values, while the case com-
                            binator, Simplicity’s branching operation, evaluates one of its two sub-
                            expressions based on the tag of the ﬁrst component of its input.
                           • The pair combinator creates pairs, while the take and drop combinators
                            access ﬁrst and second components of a pair respectively.
                           • The iden and comp combinators are not speciﬁc to any ﬂavor of type.
                            The iden term represents the identity function for any type and the comp
                            combinator provides function composition.
                        Simplicity expressions form an abstract syntax tree. The leaves of this tree are
                        either iden or unit terms. The nodes are one of the other seven combinators.
                        Each node has one or two children depending on which combinator the node
                        represents.
                           Precise semantics are given in the next section. Extensions to this core set
                        of combinators is given in Section 4.
                        2.3  Denotational Semantics of Simplicity
                        Before giving the semantics of Simplicity terms, we need notations for the values
                        of Simplicity types.
                           • We write hi : 1 for the singular value of the unit type.
                           • We write σL(a) : A+B when a : A for left-tagged values of the sum type.
                           • We write σR(b) : A + B when b : B for right-tagged values of the sum
                            type.
                           • We write ha,bi : A×B when a : A and b : B for values of the pair type.
                           Weemphasize that these values are not directly representable in Simplicity
                        because Simplicity expressions can only denote functions; we use these values
                        only to deﬁne the functional semantics of Simplicity.
                           Simplicity’s denotational semantics are recursively deﬁned. For an expres-
                        sion t : A ⊢ B, we deﬁne its semantics JtK : A → B as follows.
                                                     6
                                                          :
                                                  JidenK(a) = a
                                                          :
                                               JcompstK(a) = JtK(JsK(a))
                                                          :
                                                   JunitK(a) = hi
                                                          :   L
                                                  Jinjl tK(a) = σ (JtK(a))
                                                          :   R
                                                  Jinjr tK(a) = σ (JtK(a))
                                                    L     :
                                           JcasestKhσ (a),ci = JsKha,ci
                                                    R     :
                                           JcasestKhσ (b),ci = JtKhb,ci
                                                          :
                                                JpairstK(a) = hJsK(a),JtK(a)i
                                                          :
                                                JtaketKha,bi = JtK(a)
                                                          :
                                                JdroptKha,bi = JtK(b)
                            WehaveformalizedthelanguageandsemanticsofcoreSimplicity in the Coq
                         proof assistant [29]. The formal semantics in Coq are the oﬃcial semantics of
                         Simplicity, and for core Simplicity, it is short enough that it ﬁts in Appendix A
                         of this paper. Having semantics in a general purpose proof assistant allows
                         us to formally reason both about programs written in Simplicity and about
                         algorithms that analyze Simplicity programs.
                         2.4   Completeness
                         Simplicity cannot express general computation. It can only express ﬁnitary func-
                         tions, because each Simplicity type contains only ﬁnitely many values. However,
                         within this domain, Simplicity’s set of combinators is complete: any function
                         between Simplicity’s types can be expressed.
                         Theorem 2.1 (Finitary Completeness) Let A and B be Simplicity types.
                         Let f : A → B be any function between these types. Then there exists some core
                         Simplicity expression t : A ⊢ B such that JtK = f.
                         Wehave veriﬁed this theorem with Coq.
                            This theorem holds because functions between ﬁnite types can be described,
                         in principle, by a lookup table that maps inputs to outputs. In principle, such a
                         lookup table can be encoded as a Simplicity expression that does repeated case
                         analysis on its input and returns a ﬁxed-output value for each possible case.
                            However, using this theorem to construct Simplicity expressions is not prac-
                         tical. For example, a lookup table for the compression function for SHA-256 [24],
                                                                                       776
                         which maps 768 bits to 256 bits, would be astronomical in size, requiring 2
                         bits. To create practical programs in Simplicity, we need to take advantage of
                         structured computation in order to succinctly express functions.
                                                         7
                                  2.5     Example Programs
                                  The combinators of core Simplicity may seem paltry, so in this section we il-
                                  lustrate how we can construct programs in Simplicity. We begin by deﬁning a
                                  type for a bit, 2, as the sum of two unit types.
                                                                          :
                                                                        2 =1+1
                                      We choose an interpretation of bits as numbers where we deﬁne the left-
                                  tagged value as denoting zero and the right tagged value as denoting one.
                                                                          L     :
                                                                       ⌈σ hi⌉    =0
                                                                              2
                                                                          R     :
                                                                       ⌈σ hi⌉ =1
                                                                              2
                                      Wecan write Simplicity programs to manipulate bits. For example, we can
                                  deﬁne the not function to ﬂip a bit.
                                                  not : 2 ⊢ 2
                                                      :
                                                  not = comp(pairidenunit)(case(injrunit)(injlunit))
                                      By recursively taking products, we can deﬁne types for multi-bit words.
                                                                        1 :
                                                                       2 =2
                                                                       2n :    n     n
                                                                      2    =2 ×2
                                                           32
                                      For example, the 2      type can represent 32-bit words.
                                      Werecursively deﬁne the interpretation of pairs of words as numbers, choos-
                                  ing to use big-endian order.
                                                                         :      n    n        n
                                                             ⌈ha,bi⌉ 2n = ⌈a⌉     · 2  +⌈b⌉
                                                                     2         2             2
                                      Wecan write a half-adder of two bits in Simplicity.
                                                                             2
                                                      half-adder : 2 × 2 ⊢ 2
                                                                 :
                                                      half-adder = case (drop(pair(injlunit) iden))
                                                                          (drop(pairiden not))
                                      Wecan prove the half-adder expression correct.
                                  Theorem 2.2 (Half Adder Correct) Let a,b : 2 be two bits. Then
                                                           ⌈Jhalf-adderKha,bi⌉ 2 = ⌈a⌉ +⌈b⌉
                                                                               2        2       2
                                      WehaveproventhistheoreminCoq. This particular theorem can be proven
                                  by exhaustive case analysis (there are only four cases) and equational reasoning
                                  using Simplicity’s denotational semantics.
                                      We continue and deﬁne a full adder by combining two half adders. From
                                  there we can build ripple-carry adders for larger word sizes by combining full
                                                                             8
                              adders from smaller word sizes. The interested reader can ﬁnd the Simplicity
                              expressions for these full adders in Appendix B.
                                  Continuing, we can build multipliers and other bit-manipulation functions.
                              These can be combined to implement more sophisticated functions.
                                  Wehavewritten the SHA-256 block compression function in Simplicity. Us-
                              ing 256-bit arithmetic, we have also constructed expressions for elliptic curve
                              operations over the Secp256k1 curve [9] that Bitcoin uses, and we have built a
                              form of ECDSA signature validation [23] in Simplicity.
                                  TogainanunderstandingofthesizeofSimplicityexpressions, let us examine
                              our implementation of the SHA-256 block compression function, sha-256-block :
                                256   512    256
                              2    ×2     ⊢2 . OurSimplicity expression consists of 3274442 combinators.
                              However, this counts the total number of nodes in the abstract syntax tree that
                              makes up the expression. Several sub-expressions of this expression are dupli-
                              cated and can be shared. Imagine taking the abstract syntax tree and sharing
                              identical sub-expressions to create a directed acyclic graph (DAG) representing
                              the same expression. Counting this way, the same expression contains only 1130
                              unique typed sub-expressions, which is the number of nodes that would occur
                              in the DAG representing the expression.
                                  Taking advantage of shared sub-expressions is critical because it makes the
                              representation of typical expressions exponentially smaller in size. We choose
                              to leave sub-expression sharing implicit in Simplicity’s term language. This
                              ensures that Simplicity’s semantics are not aﬀected by how sub-expressions are
                              shared. However, we do transmit and store Simplicity expressions in a DAG
                              format. This DAG representation of expressions is also important when we
                              consider static analysis in Section 3.3.
                                  Using our formal semantics of Simplicity in Coq, we have proven our imple-
                              mentation of SHA-256 is correct.
                                                                                256              512
                              Theorem 2.3 (SHA-256 Correct) Let a : 2                and b : 2      .   Let
                                                256    512     256
                              sha-256-block : 2    ×2      ⊢ 2     be our Simplicity implementation of the
                                                                                        256   512     256
                              SHA-256 block compression function. Let SHA256Block : 2      ×2 →2 be
                              the SHA-256 block compression function. Then
                                                 Jsha-256-blockKha,bi = SHA256Blockha,bi                  1
                                  Ourreference implementation of the SHA-256 compression function in Coq
                              is taken from the Veriﬁed Software Toolchain (VST) project [3] where they use
                              it as their reference implementation for proving OpenSSL’s C implementation
                              of SHA-256 correct [2]. If we combine our Coq proof with the VST project’s
                              Coq proof, we would get a formal proof that our Simplicity implementation of
                              SHA-256 matches OpenSSL’s C implementation of SHA-256.
                                 1The type of the reference implementation for the SHA-256 compression function in Coq
                              actually uses lists of 32-bit words. To simplify the presentation here, we have omitted the
                              translation between representations of the compression function’s inputs and outputs.
                                                                    9
                              3     The Bit Machine
                              One of the design goals for Simplicity is to be able to compute a bound on the
                              computation costs of evaluating a Simplicity program. While the denotational
                              semantics of Simplicity are adequate for determining the functional behavior
                              of Simplicity programs, we need operational semantics to provide a measure of
                              computational resources used. To do this, we create an abstract machine, called
                              the Bit Machine, tailored for evaluating Simplicity programs.
                                  The Bit Machine is an abstract imperative machine whose state consists of
                              two non-empty stacks of data frames. One stack holds read-only frames, and
                              the other stack holds write-only frames. A data frame consists of an array of
                              cells and a cursor pointing either at one of the cells or pointing just beyond the
                              end of the array. Each cell contains one of three values: a zero bit, a one bit, or
                              an undeﬁned value. The Bit Machine has a set of instructions that manipulate
                              the two stacks and their data frames.
                                  Notionally, we will write a frame like in the following example.
                                                                [010?1?1]
                                  This frame contains 7 cells. The ? character denotes a cell with an undeﬁned
                              value. The 0 and 1 characters denotes cells with the corresponding bit value.
                              The frame’s cursor is pointing to the underscored cell.
                                  When a frame’s cursor is pointing past the end of the array, we will write
                              an underscore after the array’s cells like the following.
                                                                [010?1?1]
                                  Table 1 illustrates an example of a possible state of the Bit Machine. This
                              examplecontainsaread-framestackthathasfourdataframesandawrite-frame
                              stack that has two data frames. The top frame of the read-frame stack is called
                              the active read frame, and the top frame of the write-frame stack is called the
                              active write frame.
                                                 read frame stack      write frame stack
                                                 [10011??110101000]    [11??1101]
                                                 [0000]                [111??]
                                                 []
                                                 [10]
                                               Table 1: Example state for the Bit Machine
                                  The Bit Machine has ten instructions to manipulate its state, which we
                              describe below.
                                  • nop: This instruction doesn’t change the state of the machine.
                                                                   10
                • write(b): This instruction writes bit value b to the cell under the active
                 write frame’s cursor and advances the cursor by one cell.
                  – The value b must be either 0 or 1 or else the machine crashes.
                  – The active write frame’s cursor must not be beyond the end of the
                   array or else the machine crashes.
                  – The cell written to must have an undeﬁned value before writing to it
                   or else the machine crashes.
                • copy(n): This instruction copies n cells from the active read frame, start-
                 ing at its cursor, to the active write frame, starting at its cursor, and
                 advances the active write frame’s cursor by n cells.
                  – There must be at least n cells between the active read frame’s cursor
                   and the end of its array or else the machine crashes.
                  – There must be at least n cells between the active write frame’s cursor
                   and the end of its array and they all must have an undeﬁned value
                   before writing to them or else the machine crashes.
                  – Note that undeﬁned values can be copied.
                • skip(n): This instruction advances the active write frame’s cursor by n
                 cells.
                  – This instruction is allowed to advance the cursor to the point just
                   past the end of the array; however if n is large enough that it would
                   advance it past this point, the machine crashes instead.
                • fwd(n): This instruction moves the active read frame’s cursor forward by
                 n cells.
                  – This instruction is allowed to advance the cursor to the point just
                   past the end of the array; however if n is large enough that it would
                   advance it past this point, the machine crashes instead.
                • bwd(n): This instruction moves the active read frame’s cursor backwards
                 by n cells.
                  – If this instruction would move the cursor before the beginning of the
                   array, the machine crashes instead.
                • newFrame(n): This instruction allocates a new frame with n cells and
                 pushes it onto the write-frame stack, making it the new active write frame.
                  – The cursor for this new frame starts at the beginning of the array.
                  – The cells of the new frame are initialized with undeﬁned values.
                • moveFrame: This instruction pops a frame oﬀ the write-frame stack and
                 pushes it onto the read-frame stack.
                               11
                                       – The moved frame has its cursor reinitialized to the beginning of the
                                          array.
                                       – If this would leave the machine with an empty write frame stack, the
                                          machine crashes instead.
                                  • dropFrame: This instruction pops a frame oﬀ the read-frame stack and
                                     deallocates it.
                                       – If this would leave the machine with an empty read-frame stack, the
                                          machine crashes instead.
                                  • read: This instruction doesn’t modify the state of the machine. Instead
                                     it returns the value of the bit under the active read frame’s cursor to the
                                     machine’s operator.
                                       – if the value under the active read frame’s cursor is undeﬁned, or if it
                                          is past the end of its array, the machine crashes instead.
                                  The Bit Machine is deliberately designed to crash at anything resembling
                               undeﬁned behavior.
                               3.1    Bit Machine Values
                               We can use the Bit Machine to evaluate Simplicity programs on their inputs.
                               First, we deﬁne how many cells are needed to hold the values of a given type.
                                                             :
                                                   bitSize(1) = 0
                                                             :
                                              bitSize(A +B) = 1+max(bitSize(A),bitSize(B))
                                                             :
                                              bitSize(A ×B) = bitSize(A)+bitSize(B)
                                  The unit type doesn’t need any bits to represent its one value. A value of
                               sum type needs one bit for its tag and then enough bits to represent either of
                               its left or right values. A value of product type needs space to hold both its
                               values.
                                  We precisely deﬁne a representation of values for Simplicity types as array
                               of cells below:
                                                                 :
                                                           phiq  =[]
                                                               1
                                                      L          :        padl(A,B)
                                                    pσ (a)q      =[0]·[?]         · paq
                                                            A+B                        A
                                                      R          :        padr(A,B)
                                                    pσ (b)q      =[1]·[?]         · pbq
                                                            A+B                        B
                                                                 :
                                                    pha,biq      =paq ·pbq
                                                            A×B        A     B
                                 nFor the notation above, · denotes the concatenation of arrays of cells and
                               [b] denotes an array of n cells all containing b.
                                                                     12
                                 The padding for left and right values ﬁlls the array with suﬃcient undeﬁned
                              values so that the array ends up with the required length.
                                                    :
                                          padl(A,B) = max(bitSize(A),bitSize(B))−bitSize(A)
                                                    :
                                          padr(A,B) = max(bitSize(A),bitSize(B))−bitSize(B)
                                 Below are some examples of values represented as arrays of cells for the Bit
                              Machine. We deﬁne the inverse of ⌈·⌉ n to be ⌊·⌋ n that maps numbers to the
                                                                 2          2
                              values that represent them.
                                                          L
                                                       pσ (⌊3⌋ 2)q 2    =[011]
                                                               2   2 +2
                                                          R
                                                        pσ (⌊0⌋2)q 2    =[1?0]
                                                                   2 +2
                                 The array of cells contains a list of the tags from the sum types and that is
                                                                                   n
                              about it. Notice that values of a multi-bit word type, 2 , have exactly n cells
                              and the representation is identical to its big-endian binary representation.
                              3.2   Operational Semantics
                              The operational semantics for Simplicity are given by recursively translating
                              a Simplicity expression into a sequence of instructions for the Bit Machine.
                              Figure 2 deﬁnes ⟪t : A ⊢ B⟫∗, which results in a sequence of instructions for the
                              Bit Machine that evaluates the function JtK.
                                 We have formalized the Bit Machine in Coq and Figure 2’s translation of
                              Simplicity expressions into Bit Machine instructions. We have veriﬁed, with
                              Coq, that our Bit Machine implementation of Simplicity respects Simplicity’s
                              denotational semantics.
                              Theorem 3.1 (Correctness of Operational Semantics) Let t : A ⊢ B be
                              any Simplicity expression. Let v : A be any value of type A. Initialize a Bit
                              Machine with
                                 • the value pvqA as the only frame on the read-frame stack with its cursor
                                   at the beginning of the frame, and
                                               bitSize(B)
                                 • the value [?]       as the only frame on the write-frame stack with its
                                   cursor at the beginning of the frame.
                                                                       ∗
                              After executing the instructions ⟪t : A ⊢ B⟫ , the ﬁnal state of the Bit Machine
                              has
                                 • the value pvq  as the only frame on the read-frame stack, with its cursor
                                               A
                                   at the beginning of the frame, and
                                 • the value pJtK(v)q as the only frame on the write-frame stack, with its
                                                    B
                                   cursor at the end of the frame.
                                                                  13
                                                           ∗ :
                                             ⟪iden : A ⊢ A⟫∗ = copy(bitSize(A))                   ∗
                                                             :
                                          ⟪compst:A⊢C⟫ = newFrame(bitSize(B));⟪s:A⊢B⟫ ;
                                                                                        ∗
                                                                moveFrame;⟪t:B ⊢C⟫ ;
                                                                dropFrame
                                                           ∗ :
                                              ⟪unit : A ⊢ 1⟫∗ = nop                                  ∗
                                                             :
                                         ⟪injlt : A ⊢ B + C⟫∗ = write(0);skip(padl(B,C));⟪t : A ⊢ B⟫∗
                                                             :
                                        ⟪injrt : A ⊢ B + C⟫∗ = write(1);skip(padr(B,C));⟪t : A ⊢ C⟫
                                                             :
                                ⟪casest : (A+B)×C ⊢D⟫ = match read with
                                                                
                                                                  0 → fwd(1+padl(A,B));
                                                                
                                                                
                                                                                     ∗
                                                                      ⟪s : A ×C ⊢ D⟫ ;
                                                                
                                                                
                                                                      bwd(1+padl(A,B))
                                                                
                                                                  1 → fwd(1+padr(A,B));
                                                                
                                                                                     ∗
                                                                
                                                                      ⟪t : B × C ⊢ D⟫ ;
                                                                
                                                                      bwd(1+padr(A,B))
                                                           ∗ :            ∗            ∗
                                       ⟪pairst : A ⊢ B ×C⟫ = ⟪s : A ⊢ B⟫ ;⟪t : A ⊢ C⟫
                                                           ∗ :            ∗
                                        ⟪taket : A ×B ⊢ C⟫∗ = ⟪t : A ⊢ C⟫                  ∗
                                                             :
                                       ⟪dropt : A×B ⊢ C⟫ = fwd(bitSize(A));⟪t : B ⊢ C⟫ ;
                                                                bwd(bitSize(A))
                                  Figure 2: Operational Semantics for Simplicity using the Bit Machine.
                              In particular, the Bit Machine never crashes during this execution.
                                 The fact that the Bit Machine never crashes means that during execution it
                              never reads from an undeﬁned cell, nor does it ever write to a deﬁned cell. This
                              means that, if one implements the Bit Machine on a real computer, one can
                              use an ordinary array of bits to represent the array of cells and cells that are
                              supposed to hold undeﬁned values can be safely set to any bit value. As long as
                              this implementation only executes instructions translated from Simplicity and
                              started from a proper initial state, the resulting computation will be the same
                              as if one had used an explicit representation for undeﬁned values.
                              3.3   Static Analysis
                              Using the Bit Machine, we can measure computational resources needed by a
                              Simplicity program. For instance we can:
                                 • count the number of instructions executed by the Bit Machine.
                                 • count the number of cells copied by the Bit Machine.
                                                                  14
                                              :
                             extraCellBnd(iden : A ⊢ A) =0
                                              :
                           extraCellBnd(compst : A ⊢ C) =bitSize(B)+
                                                max(extraCellBnd(s : A ⊢ B),
                                                   extraCellBnd(t : B ⊢ C))
                                              :
                              extraCellBnd(unit : A ⊢ 1) =0
                                              :
                          extraCellBnd(injlt : A ⊢ B + C) =extraCellBnd(t : A ⊢ B)
                                              :
                          extraCellBnd(injrt : A ⊢ B + C) =extraCellBnd(t : A ⊢ C)
                                              :
                    extraCellBnd(casest : (A +B)×C ⊢ D) =max(extraCellBnd(s : A×C ⊢ D),
                                                  extraCellBnd(t : B × C ⊢ D))
                                              :
                         extraCellBnd(pairst : A ⊢ B ×C) =max(extraCellBnd(s : A ⊢ B),
                                                   extraCellBnd(t : A ⊢ C))
                                              :
                         extraCellBnd(taket : A × B ⊢ C) =extraCellBnd(t : A ⊢ C)
                                              :
                         extraCellBnd(dropt : A ×B ⊢ C) =extraCellBnd(t : B ⊢ C)
                                  :
                       cellBnd(t : A ⊢ B) = bitSize(A) + bitSize(B) + extraCellBnd(t : A ⊢ B)
                                   Figure 3: Deﬁnition of cellBnd.
                      • count the maximum number of cells in both stacks at any point during
                       execution.
                      • count the maximum number of frames in both stacks at any point during
                       execution.
                      The ﬁrst two are measurements of time used by the Bit Machine, and the
                    last two are measurements of space used by the Bit Machine.
                      Using simple static analysis, we can quickly compute an upper bound on
                    these sorts of resource costs. In this paper, we will focus on the example of
                    counting the maximum number of cells in both stacks at any point during ex-
                    ecution. Figure 3 deﬁnes a function cellBnd that computes an upper bound on
                    the maximum number of cells that are needed during execution.
                    Theorem 3.2 (Static Analysis of Cell Usage) Let t : A ⊢ B be any Sim-
                    plicity expression. Let v : A be any value of type A. Initialize a Bit Machine as
                    speciﬁed in Theorem 3.1. The maximum number of cells in both stacks of the
                                                          ∗
                    Bit Machine at any point during the execution of ⟪t : A ⊢ B⟫ from this initial
                    state never exceeds cellBnd(t : A ⊢ B).
                      Wehave formalized the above static analysis and proven the above theorem
                    in Coq.
                                            15
                                   These kinds of static analyses are simple recursive functions of Simplicity
                               expressions, and the intermediate results for sub-expressions can be shared. By
                               using a DAG for the in-memory representation of Simplicity expressions, we
                               can transparently cache these intermediate results. This means the time needed
                               to compute static analysis is proportional to the size of the DAG representing
                               the Simplicity expression, as opposed to the time needed for dynamic analysis
                               such as evaluation, which may take time proportional to the size of the tree
                               representing the Simplicity expression.
                                   The Bit Machine is an abstract machine, so we can think of these sorts of
                               static analyses as bounding abstract resource costs. As long as the abstract
                               resource costs are limited, then the resource costs of any implementation of
                               Simplicity will also be limited. These sorts of precise static analyses of resource
                               costs are more sophisticated than what is currently available for Bitcoin Script.
                                   Notice that the deﬁnition of cellBnd does not directly reference the Bit Ma-
                               chine, so limits on the bounds computed by these static analyses can be imposed
                               on protocols that use Simplicity without necessarily requiring that applications
                               use the Bit Machine for evaluation. While we do use an implementation of the
                               Bit Machine in our prototype Simplicity evaluator written in C, others are free
                               to explore other models of evaluation. For example, the Bit Machine copies
                               data to implement the iden combinator, but another model of evaluation might
                               create shared references to data instead.
                               3.3.1   Tail Composition Optimization
                               Tail call optimization is an optimization used in many languages where a proce-
                               dure’s stack frame is freed prior to a call to another procedure when that call is
                               the last command of the procedure. The comp combinator in Simplicity behaves
                               muchlike a procedure call, and we can implement an analogous optimization for
                               the translation of Simplicity to the Bit Machine. Interested readers can ﬁnd this
                                                                                  tco
                               tail composition optimized translation, ⟪t : A ⊢ B⟫   , deﬁned in Appendix C,
                                                                                  oﬀ
                               along with a static analysis of its memory use.
                               3.4    Jets
                               Evaluation of a Simplicity expression with the Bit Machine recursively traverses
                               the expression. Before evaluating some sub-expression t : A ⊢ B, the Bit Ma-
                               chine is always in a state where the active read frame is of the form
                                                                r ·pvq ·r
                                                                 1     A    2
                               for some value v : A and some arrays r and r , and where the cursor is placed
                                                                      1      2
                               at the beginning of the pvq  array slice.
                                                          A
                                   Furthermore the active write frame is of the form
                                                                    bitSize(B)
                                                             w1·[?]         · w2
                               for some arrays w1 and w2, and where the cursor is placed at the beginning of
                                     bitSize(B)
                               the [?]        array slice.
                                                                     16
                                  After the evaluation of the sub-expression t : A ⊢ B, the active write frame
                              is of the form
                                                            w1·pJtK(v)qB ·w2
                              and where the cursor is placed at the beginning of the w2 array slice.
                                  Taking an idea found in Urbit [32], we notice that if we recognize a familiar
                              sub-expression t : A ⊢ B, the interpreter may bypass the BitMachine’s execution
                                            ∗
                              of ⟪t : A ⊢ B⟫ and instead directly compute and write pJtK(v)q   to the active
                                                                                             B
                              write frame. Following Urbit, we call such a familiar expression and the code
                              that replaces it a jet.
                                  Jets are essential for making Simplicity a practical language. For our Block-
                              chain application we expect to have jets for at least the following expressions:
                                  • arithmetic operations (addition, subtraction, and multiplication) from
                                    8-bit to 256-bit word size,
                                  • comparison operations (less than, less than or equal to, equality) from
                                    8-bit to 256-bit word size,
                                  • logical bitwise operation for 8-bit to 256-bit word sizes,
                                  • constant functions for every possible 8-bit word,
                                  • compression functions from hash functions such as SHA-256’s compression
                                    function,
                                  • elliptic curve point operations for the Secp256k1 curve [9], and
                                  • digital signature validation for ECDSA [23] or Schnorr [28] signatures.
                                  Wetake advantage of the fact that the representation of the values used for
                              arithmetic expressions in the Bit Machine match the binary memory format for
                              real hardware. This lets us write these jets by directly reading from and writing
                              to data frames.
                                  Jets have several nice properties:
                                  • Jets provide a formal speciﬁcation of their behavior. The implementation
                                    of a jet must produce output identical to the output that would be pro-
                                    duced by the Simplicity expression being replaced. There is no possibility
                                    for an ambiguous interpretation of what a jet computes.
                                  • Jets cannot accidentally introduce new behavior or new side eﬀects be-
                                    cause they can only replicate the behavior of Simplicity expressions. To
                                    add new behavior to Simplicity we must explicitly extend Simplicity (see
                                    Section 4).
                                  • Jets are transparent when it comes to reasoning about Simplicity expres-
                                    sions. Jets are logically equal to the code they replace. Therefore, when
                                    proving properties of one’s Simplicity code, jets can safely be ignored.
                                                                    17
                                 Naturally, we expect jetted expressions to have properties already proven and
                                 available; this will aid reasoning about Simplicity programs that make use of
                                 jets.
                                     Because jets are transparent, the static analyses of resource costs are not
                                 aﬀected by their existence. To encourage the use of jets, we anticipate discounts
                                 to be applied to the resource costs of programs that use jets based on the
                                 estimated savings of using jets.
                                     When a suitably rich set of jets is available, we expect the bulk of the
                                 computation speciﬁed by a Simplicity program to be made up of these jets,
                                 with only a few combinators used to combine the various jets. This should
                                 bring the computational requirements needed for Simplicity programs in line
                                 withexistingblockchainlanguages. Inlightofthis, onecouldconsiderSimplicity
                                 to be a family of languages, where each language is deﬁned by a set of jets that
                                 provide computational elements tailored for its particular application.
                                 4     Integration with Blockchains
                                 Core Simplicity is language that does pure computation. In order to interact
                                 with blockchains we extend Simplicity with new combinators.
                                 4.1     Transaction Digests
                                 The main operation used in Bitcoin Script is OP CHECKSIG which, given a
                                 public key, a digital signature, and a SigHash type [15], generates a digest of the
                                 transaction in accordance with the SigHash type and validates that the digital
                                 signature for the digest is correct for the given public key. This operation allows
                                 users to create programs that require their signatures for their transactions to
                                 be authorized.
                                     In core Simplicity we can implement, and jet, the digital signature validation
                                 algorithm. However, it is not possible to generate the transaction digest because
                                 core Simplicity doesn’t have access to the transaction data. To remedy this, we
                                 add a new primitive combinator to Simplicity
                                                                                       256
                                                            sighash : SigHashType ⊢ 2
                                                      :
                                 where SigHashType = (1+2)×2 is a Simplicity type suitable for encoding all
                                 possible SigHash types.
                                     This combinator returns the digest of the transaction for the given SigHash
                                 type. Together with the Simplicity implementation of digital signature veriﬁca-
                                 tion, we can implement the equivalent of Bitcoin’s OP CHECKSIG.
                                     We can add other primitives to Simplicity to access speciﬁc ﬁelds of trans-
                                 action data in order to implement features such as Bitcoin’s timelock oper-
                                 ations [30, 7].  While Simplicity avoids providing direct access to persistent
                                 storage, one could imagine an application where transactions contain data for
                                 transactional updates to a persistent store. Simplicity could support primitives
                                                                          18
                                   to read the details of these transactional updates and thereby enforce any set
                                   of programmable rules on them.
                                   4.2     Merklized Abstract Syntax Tree
                                   Recall that when using P2SH, users commit to their program by hashing it and
                                   placing that hash in the outputs of transactions. Only when redeeming their
                                   funds does the user reveal their program, whose hash must match the committed
                                   hash.
                                       Pay to Merklized Abstract Syntax Tree, or P2MAST [17], enhances the P2SH
                                   idea. Instead of hashing a linear encoding of a Simplicity expression, we use
                                                                                                       256     512      256
                                   the SHA-256’s block compression function, SHA256Block : 2               ×2 →2 ,
                                   to recursively hash Simplicity sub-expressions. This computes a Merkle root of
                                   Simplicity’s abstract syntax tree that we denote by #(·) and deﬁne as
                                                                :                               512
                                                       #(iden) = SHA256Blockhtag          , ⌊0⌋    i
                                                                                       iden    2
                                                                :
                                                  #(compst) =SHA256Blockhtagcomp,h#(s),#(t)ii
                                                                :                               512
                                                       #(unit) = SHA256Blockhtag          , ⌊0⌋    i
                                                                                       unit    2
                                                                :                                     256
                                                       #(injlt) = SHA256Blockhtaginjl,h#(t),⌊0⌋2         ii
                                                                :                                      256
                                                      #(injrt) = SHA256Blockhtaginjr,h#(t),⌊0⌋2          ii
                                                                :
                                                    #(casest) = SHA256Blockhtagcase,h#(s),#(t)ii
                                                                :
                                                    #(pairst) = SHA256Blockhtagpair,h#(s),#(t)ii
                                                                :                                      256
                                                     #(taket) = SHA256Blockhtagtake,h#(t),⌊0⌋2            ii
                                                                :                                      256
                                                     #(dropt) = SHA256Blockhtag           , h#(t),⌊0⌋     ii
                                                                                       drop           2
                                                                :                                 512
                                                   #(sighash) = SHA256Blockhtag              , ⌊0⌋   i
                                                                                       sighash   2
                                                   256
                                   where tagc : 2      is an appropriate unique set of initial vectors per combinator.
                                   Weuse the SHA-256 hash of the combinator name for its tag value.
                                       When computing Merkle roots, like other kinds of static analysis, the inter-
                                   mediate results of sub-expressions can be shared. Bitcoin Script cannot share
                                   sub-expressions in this manner due to the linear encoding of Bitcoin Script
                                   programs.
                                       Another advantage of Merkle roots is that unused branches of case expres-
                                   sions can be pruned at redemption time. Each unused branch can be replaced
                                   with the value of its Merkle root. This saves on bandwidth, storage costs, and
                                   enhances privacy by not revealing more of a Simplicity program than necessary.
                                   Again, this is something not possible in Bitcoin Script.
                                       To enable redemption of pruned Simplicity expressions, we add two new
                                   combinators to replace the case combinator when pruning.
                                                                         256            256
                                               s : A × C ⊢ D        h:2            h:2          t : B × C ⊢ D
                                              assertlsh : (A + B) ×C ⊢ D         assertrht : (A + B) ×C ⊢ D
                                                                              19
                                       These assertion combinators follow the same form as the case combinator,
                                   except one branch is replaced by a hash. The semantics of these combinators
                                   require that the ﬁrst component of their input be σL or σR as appropriate and
                                                                                             256
                                   then they evaluate the available branch. The h : 2            values do not aﬀect the
                                   semantics; they instead inﬂuence the Merkle root computation.
                                                                    :
                                                     #(assertlsh) = SHA256Blockhtagcase,h#(s),hii
                                                                    :
                                                     #(assertrht) = SHA256Blockhtagcase,hh,#(t)ii
                                       Notice that we use tagcase for the tags of the assertions. During redemption,
                                   one can replace case statements with appropriate assertions while still matching
                                   the committed Merkle root of the whole expression.
                                                    #(casest) = #(assertls#(t)) = #(assertr#(s)t)
                                   As long as the assertions hold, the computation remains unchanged. If an
                                   assertion fails, because you pruned oﬀ a branch that was actually necessary,
                                   then the computation fails and a transaction trying to redeem funds in that
                                   manner is invalid.
                                       Because failure is now a possible result during evaluation, we add a combi-
                                   nator fail to allow one to develop programs that use assertions.
                                                                         fail : A ⊢ B
                                                                  :                              512
                                                          #(fail) = SHA256Blockhtag        , ⌊0⌋    i
                                                                                         fail   2
                                       When combined with the signature veriﬁcation expression, one can build
                                   the equivalent of Bitcoin’s OP CHECKSIGVERIFY operation to assert that a
                                   signature is valid.
                                       Degenerate assertions can also be used to enhance privacy by mixing entropy
                                   into Merkle roots of sub-expressions. Given t : A ⊢ B the expression
                                                   comp(pair(injliden) unit)(assertl(taket)h) : A ⊢ B
                                   is semantically identical to t, but mixes h into its Merkle root computation.
                                   Whenusedinsidebranchesthatarelikelytobepruned,thispreventsadversaries
                                   from eﬀectively grinding out Simplicity expressions to see if they match the hash
                                   of the missing branch.
                                       The Merkle root of an expression does not commit to its types. We use
                                   ﬁrst-order uniﬁcation [27] to perform type inference on Simplicity expressions,
                                   replacing any remaining type variables with the unit type. Because the types of
                                   prunedbranchesarediscarded, theinferredtypesmayendupsmallerthaninthe
                                   originally committed program. When this happens, the memory requirements
                                   for evaluation with the Bit Machine may also decrease.
                                                                              20
                                   4.3     Witness Values
                                   During redemption, the user must provide inputs, such as digital signatures and
                                   other witness data, in order to authorize a transaction. Rather than passing this
                                   input as an argument to the Simplicity program, we embed such witness values
                                   directly into the Simplicity expressions using the witness combinator.
                                                                             b : B
                                                                      witnessb : A ⊢ B
                                       Semantically, the witness combinator just denotes a constant function, which
                                   is something we can already write in core Simplicity. The diﬀerence lies in its
                                   Merkle root computation.
                                                                   :                                  512
                                                     #(witnessb) = SHA256Blockhtagwitness,⌊0⌋2           i
                                       The value b is not committed by the Merkle root. This allows the user to
                                   set witness value at redemption time, without aﬀecting the expression’s Merkle
                                   root. Users can use witness combinators at places where digital signatures are
                                   needed and at places where choices are made at redemption time.
                                       Using witness combinators enhances privacy because they are pruned away
                                   when they occur in unused branches. This leaves little evidence that there was
                                   an optional input at all.
                                       The amount of witness data allowed at redemption time is limited at com-
                                   mitment time because each witness data type is ﬁnite and there can only be
                                   a ﬁnite number of witness combinators committed. This limits the computa-
                                   tional power of Simplicity. For example, it is not possible to create a Simplicity
                                   program that allows hashing of an unbounded amount of witness data in order
                                   to validate a digital signature. However, it is possible to create a Simplicity
                                   program that allows a large, but bounded, amount of witness data to be hashed
                                   that is more than will ever be needed in practice. Thanks to pruning, only
                                   the code used to hash the amount of witness data that actually occurs need be
                                   provided at redemption time.
                                       Type inference determines the minimal type for witness values. This pre-
                                   vents them from being ﬁlled with unnecessary data.
                                       The witness combinator is not allowed to be used in jets.
                                   4.4     Extended Simplicity Semantics
                                   In order to accommodate these extensions to core Simplicity, we need to broaden
                                   Simplicity’s semantics. We use a monad, M, to capture the new eﬀects of these
                                   extensions.
                                                                           :
                                                                   M(A) =Trans→A⊥
                                       This monad is a combination of an environment monad (also called a reader
                                   monad) with an exception monad.
                                                                              21
                                            This monad provides implicit access to a value of Trans type, which we
                                        deﬁne to be the type of transaction data for the particular blockchain. During
                                        evaluation, it is ﬁlled with the transaction containing the input redeeming the
                                        Simplicity program being evaluated. This is used to give semantics to the sighash
                                        and other similar primitives.
                                            The monad also adds a failure value to the result type, denoted by ⊥ : A⊥
                                        This allows us to give semantics to assertions and fail.
                                            Given an expression t : A ⊢ B, we denote this extended semantics by JtK                        :
                                                                                                                                        M
                                        A→M(B). ThecoreSimplicity semantics are lifted in the natural way so that
                                                                         JtK   (a) = λe : Trans.JtK(a)
                                                                            M
                                        holds whenever t is composed of only core Simplicity combinators. The extended
                                        set of combinators have the following semantics
                                                                                         :
                                                                       JsighashK     (a) = λe.MakeSigHash(a,e)
                                                                                  M
                                                                               L         :
                                                            JassertlshK     hσ (a),ci = λe.JsK ha,ci(e)
                                                                          M                          M
                                                                               R         :
                                                            JassertlshK     hσ (b),ci = λe.⊥
                                                                          M
                                                                               L         :
                                                            JassertrhtK     hσ (a),ci = λe.⊥
                                                                          M
                                                                               R         :
                                                            JassertrhtK     hσ (b),ci = λe.JtK hb,ci(e)
                                                                          M                         M
                                                                                         :
                                                                            JfailK   (a) = λe.⊥
                                                                                  M
                                                                                         :
                                                                     JwitnessbK      (a) = λe.b
                                                                                  M
                                        where MakeSigHash(a,e) is a function that returns a hash of a given transaction
                                        e in accordance with the given SigHash type a.
                                            Theoperational semantics are also extended to support our new combinators
                                        by providing the Bit Machine with access to the transaction data and by adding
                                        an explicit crash instruction to support assertions and fail.
                                            Wenotethat the eﬀects captured by our monad are commutative and idem-
                                                 2
                                        potent. While Simplicity’s operational semantics implicitly specify an order of
                                        evaluation, the extended denotational semantics are independent of evaluation
                                        order. This simpliﬁes formal reasoning about Simplicity programs that use the
                                        extended semantics. That said, we expect the majority of Simplicity program’s
                                        sub-expressions to be written in core Simplicity whose denotational semantics
                                        contain no eﬀects at all, making reasoning about them simpler still.
                                        4.5      Using Simplicity Programs in Blockchains
                                        Simplicity programs are Simplicity expressions of type p : 1 ⊢ 1, that may use
                                        any of our extended combinators. Users transact by constructing their Simplic-
                                           2We use the terms ‘commutative’ and ‘idempotent’ in the sense of King and Wadler [16]
                                        as opposed to the traditional category theoretic deﬁnition of an idempotent monad.
                                                                                        22
                            ity program and computing its Merkle root #(p). They have their counterparty
                            create a transaction that sends funds to that hash.
                               Later, when a user wants to redeem their received funds, they create a trans-
                            action whose input contains a Simplicity program whose Merkle root matches
                            the previous hash. At this point they have the ability to set the witness values
                            and prune any unneeded branches from case expressions. The witness combi-
                            nators handle the program’s eﬀective inputs, so the program p is evaluated at
                            the value hi : 1. No output is needed because the program can use assertions to
                            fail in case of invalid witnesses. If the execution completes successfully, without
                            failing, the transaction is considered valid.
                               The basic signature program that mimics Bitcoin’s basic signature program
                            is composed of the following core Simplicity expressions
                                                                           256
                                             checkSig : Signature×(PubKey×2   ) ⊢ 2
                                                      pubKey : A ⊢ PubKey
                            where checkSig checks whether a given signature validates for a given public key
                            and message hash, and pubKey returns a user’s speciﬁc public key.
                               These expressions can be combined into a basic signature veriﬁcation pro-
                            gram.
                                              :
                               basicSigVerifybc = comp(pair(witnessb)
                                              (pairpubKey(comp(witnessc)sighash)))
                                                              (comp(paircheckSigunit)(casefailunit))
                               Other, more complex programs can be built to perform multi-signature
                            checks, to implement sophisticated smart contracts such as zero-knowledge con-
                            tingent payments, or to create novel smart contracts.
                            5    Results and Future Work
                            In many ways, Simplicity is best characterized by what features it leaves out
                            rather than what features it contains.
                               • Simplicity has no state. Purely functional, expression-based languages
                                 facilitate equational reasoning about the semantics of expressions. For
                                 example, there are no concerns about aliased references to a global heap,
                                 so there is no need to work with separation logic or Hoare logic.
                               • Simplicity has no named variables. Using combinators lets us avoid deal-
                                 ing with binders and environments for bound variables. This helps keep
                                 our interpreter and static analyses simple and further eases equational
                                 reasoning about Simplicity expressions.
                                                               23
                                    • Simplicity has no function types and therefore no higher-order functions.
                                       While it is possible to compute upper bounds of computation resources of
                                       expressions in the presence of function types, it likely that those bounds
                                       would be so far above their actual needs that such analysis would not be
                                       useful.
                                    • Simplicity has no unbounded loops or recursion. It is possible to build
                                       smart contracts with state carried through loops using covenants [25],
                                       without requiring unbounded loops within Simplicity itself.         Bounded
                                       loops, such as the 64 rounds needed by our SHA-256 implementation,
                                       can be achieved by unrolling the loop. Because of sub-expression sharing,
                                       this doesn’t unreasonably impact program size. We do not directly write
                                       Simplicity, rather we use functions written in Coq or Haskell to generate
                                       Simplicity.  These languages do support recursion and we use loops in
                                       these meta-languages to generate unrolled loops in Simplicity.
                                    Throughout this paper we have noted which theorems we have veriﬁed with
                                 Coq. Other proofs are under development. In particular, we plan to formally
                                 verify the denotational and operational semantics of the full Simplicity language,
                                 including assertions and blockchain primitives.
                                    To validate the suitability of Simplicity, we will be building example smart
                                 contracts in a test blockchain or sidechain [4] application using Simplicity.
                                    We also plan to use the VST project [3] to prove the correctness of our
                                 C implementation of the Bit Machine. This would let us formally verify that
                                 the assembly code generated by the CompCert compiler [18] from our C imple-
                                 mentation respects Simplicity’s formal semantics. In particular, we would be
                                 able to prove that substituting jets, such as SHA-256, with fast C or assembly
                                 implementations preserves the semantics of Simplicity.
                                    Simplicity is designed as a low-level language interpreted by blockchain soft-
                                 ware. We anticipate higher-level languages will be used for development and
                                 compiled to Simplicity. Ivy [10] and the Σ-State Authentication Language [11],
                                 are existing eﬀorts that may be suitable for being compiled to Simplicity. If
                                 these higher-level languages come with formal semantics of their own, we will
                                 have the opportunity to prove correct the compiler to Simplicity for these lan-
                                 guages. For the time being, generating Simplicity with our Haskell and Coq
                                 libraries is possible.
                                 6     Conclusion
                                 Wehave deﬁned a new language designed to be used for crypto-currencies and
                                 blockchains. It could be deployed in new blockchain applications, including
                                 sidechains [4], or possibly in Bitcoin itself. Simplicity has the potential to be
                                 used in any application where ﬁnitary programs need to be transported and
                                 executed under potentially adversarial conditions.
                                    Our language is bounded, without loops, but is expressive enough to repre-
                                 sent any ﬁnitary function. These constraints allow for general purpose static
                                                                         24
              analysis that can eﬀectively bound the amount of computational resources
              needed by a Simplicity program prior to execution.
                Simplicity has simple, functional semantics, which make formal reasoning
              withsoftwareproofassistantsrelatively easy. This provides the means for people
              whodevelop smart contract to formally verify the correctness of their programs.
                We have written several low-level functions in Simplicity such as addition,
              subtraction, and multiplication for various ﬁnite-bit words and formally veriﬁed
              their correctness. With these we have built mid-level functions such as elliptic
              curve addition and multiplication, ECDSA signature validation, and a SHA-
              256 compression function. This is already suﬃcient to create simple single and
              multi-signature veriﬁcation programs in Simplicity. We have formally veriﬁed
              our SHA-256 compression function is correct and have plans to formally verify
              the remaining functions.
                               25
                  A Simplicity Semantics in Coq
                  Below is the formal deﬁnition of core Simplicity as expressed in Coq [29]. The
                  Term type is the type of well-typed Simplicity expressions. The eval function
                  provides the denotational semantics of well-typed Simplicity expressions.
                  Inductive Ty : Set :=
                   | Unit : Ty
                   | Sum : Ty -> Ty -> Ty
                   | Prod : Ty -> Ty -> Ty.
                  Fixpoint tySem (x : Ty) : Set :=
                   match x with
                   | Unit => Datatypes.unit
                   | Sum a b => tySem a + tySem b
                   | Prod a b => tySem a * tySem b
                   end.
                  Inductive Term : Ty -> Ty -> Set :=
                   | iden : forall {A}, Term A A
                   | comp : forall {A B C},
                    Term A B -> Term B C -> Term A C
                   | unit : forall {A}, Term A Unit
                   | injl : forall {A B C},
                    Term A B -> Term A (Sum B C)
                   | injr : forall {A B C},
                    Term A C -> Term A (Sum B C)
                   | case : forall {A B C D},
                    Term (Prod A C) D -> Term (Prod B C) D ->
                    Term (Prod (Sum A B) C) D
                   | pair : forall {A B C},
                    Term A B -> Term A C -> Term A (Prod B C)
                   | take : forall {A B C},
                    Term A C -> Term (Prod A B) C
                   | drop : forall {A B C},
                    Term B C -> Term (Prod A B) C.
                  Fixpoint eval {A B} (x : Term A B) :
                    tySem A -> tySem B :=
                   match x in Term A B
                    return tySem A -> tySem B with
                   | iden => fun a => a
                   | comp s t => fun a => eval t (eval s a)
                   | unit => fun _ => tt
                   | injl t => fun a => inl (eval t a)
                   | injr t => fun a => inr (eval t a)
                                       26
                            | case s t => fun p => let (ab, c) := p in
                                match ab with
                                | inl a => eval s (a, c)
                                | inr b => eval t (b, c)
                                end
                            | pair s t => fun a => (eval s a, eval t a)
                            | take t => fun ab => eval t (fst ab)
                            | drop t => fun ab => eval t (snd ab)
                            end.
                          B Full Word Adders in Simplicity
                          Below we recursively deﬁne Simplicity programs for ripple-carry full-adders for
                               n
                          any 2 -bit word size. A full-adder takes two n-bit words and a carry-in bit as
                          inputs and returns a carry-out bit and an n-bit word.
                                                 n   n           n
                                     full-addern : (2 × 2 ) × 2 ⊢ 2 × 2
                                              :
                                     full-adder1 = comp(pair(takehalf-adder)(dropiden))
                                                (comp(pair(take(takeiden))
                                                (comp (pair(take(dropiden))(dropiden))
                                                      half-adder))
                                                (pair (case(drop(takeiden))(injrunit))
                                                     (drop(dropiden))))
                                              :
                                    full-adder2n = comp(pair(take(pair (take(takeiden))
                                                                  (drop(takeiden))))
                                                (comp (pair (take(pair (take(dropiden))
                                                                   (drop(dropiden))))
                                                           (dropiden))
                                                      full-addern))
                                                (comp (pair(drop(dropiden))
                                                      (comp (pair (takeiden)
                                                                (drop(takeiden)))
                                                            full-addern))
                                                (pair (drop(takeiden))
                                                     (pair(drop(dropiden))(takeiden))))
                                                                                            n
                          Theorem B.1 (Full Adder Correct) Let n be a power of two. Let a,b : 2
                          be two n-bit words. Let c : 2 be a bit. Then
                                           ⌈x⌉ ·2n +⌈y⌉ n = ⌈a⌉ n +⌈b⌉ n +⌈c⌉
                                             2         2      2      2     2
                                                          27
                                where
                                                          Jfull-adderKhha,bi,ci = hx,yi
                                    Wehave veriﬁed the above theorem in Coq.
                                                                                     n
                                    We have similarly deﬁned multiplication for 2 -bit words and proven its
                                correctness theorem in Coq.
                                C Tail Composition Optimization
                                                                                                                ∗
                                We deﬁne a variant of the translation of Simplicity to the Bit Machine, ⟪·⟫ ,
                                to add a tail composition optimization (TCO). This optimization moves the
                                dropFrame instruction earlier, potentially reducing the memory requirements
                                for execution by the Bit Machine. This is analogous to the tail call optimization
                                found in other languages. Our new deﬁnition will be a pair of mutually recursive
                                              tco        tco
                                functions, ⟪·⟫   and ⟪·⟫    .
                                              oﬀ         on
                                                         tco                          ∗               ∗        tco
                                    The deﬁnition of ⟪·⟫    is identical to that of ⟪·⟫ , replacing ⟪·⟫ by ⟪·⟫   ,
                                                         oﬀ                                                    oﬀ
                                                                  tco
                                except for the ⟪compst : A ⊢ C⟫      clause which is given below.
                                                                  oﬀ
                                                      tco :
                                   ⟪compst:A⊢C⟫oﬀ =newFrame(bitSize(B));
                                                               tco                           tco
                                                   ⟪s : A ⊢ B⟫   ; moveFrame;⟪t : B ⊢ C⟫
                                                               oﬀ                            on
                                    In the tail position of the comp combinator, we removed the dropFrame
                                                        tco                               tco
                                instruction and call ⟪·⟫    instead. The deﬁnition of ⟪·⟫    is given in Figure 4.
                                                        on                                on
                                                                                                               tco
                                    WehaveformallyveriﬁedinCoqthefollowingcorrectnesstheoremfor⟪·⟫ .
                                                                                                               oﬀ
                                Theorem C.1 (Correctness of TCO Operational Semantics) Let t                     :
                                A ⊢ B be any Simplicity expression.        Let v : A be any value of type A.
                                Initialize a Bit Machine with
                                    • the value pvq   as the only frame on the read-frame stack with its cursor
                                                    A
                                      at the beginning of the frame, and
                                                   bitSize(B)
                                    • the value [?]         as the only frame on the write-frame stack with its
                                      cursor at the beginning of the frame.
                                                                             tco
                                After executing the instructions ⟪t : A ⊢ B⟫   , the ﬁnal state of the Bit Machine
                                                                             oﬀ
                                has
                                    • the value pvq   as the only frame on the read-frame stack with its cursor
                                                    A
                                      at the beginning of the frame, and
                                    • the value pJtK(v)qB as the only frame on the write-frame stack with its
                                      cursor at the end of the frame.
                                In particular, the Bit Machine never crashes during this execution.
                                                                        28
                                                              tco :
                                               ⟪iden : A ⊢ A⟫     =copy(bitSize(A));dropFrame
                                                              on
                                                              tco :                                      tco
                                           ⟪compst:A⊢C⟫           = newFrame(bitSize(B));⟪s : A ⊢ B⟫        ;
                                                              on                                         on
                                                                                               tco
                                                                    moveFrame;⟪t:B ⊢C⟫
                                                                                               on
                                                              tco :
                                                ⟪unit : A ⊢ 1⟫    =dropFrame
                                                              on
                                                              tco :                                         tco
                                          ⟪injlt : A ⊢ B + C⟫     =write(0);skip(padl(B,C));⟪t : A ⊢ B⟫
                                                              on                                            on
                                                              tco :                                         tco
                                          ⟪injrt : A ⊢ B + C⟫     =write(1);skip(padr(B,C));⟪t : A ⊢ C⟫
                                                              on                                            on
                                                              tco :
                                 ⟪casest : (A+B)×C ⊢D⟫            = match read with
                                                              on     
                                                                       0 → fwd(1+padl(A,B));
                                                                     
                                                                     
                                                                                            tco
                                                                            ⟪s : A ×C ⊢ D⟫
                                                                                             on
                                                                     
                                                                       1 → fwd(1+padr(A,B));
                                                                     
                                                                                            tco
                                                                            ⟪t : B × C ⊢ D⟫
                                                                                             on
                                                              tco :             tco            tco
                                        ⟪pairst : A ⊢ B ×C⟫       =⟪s:A⊢B⟫ ;⟪t:A⊢C⟫
                                                              on                oﬀ             on
                                                              tco :             tco
                                         ⟪taket : A ×B ⊢ C⟫       =⟪t:A⊢C⟫
                                                              on                on
                                                              tco :                              tco
                                         ⟪dropt : A×B ⊢ C⟫        =fwd(bitSize(A));⟪t : B ⊢ C⟫
                                                              on                                 on
                                Figure 4: Operational semantics for Simplicity using the Bit Machine with TCO.
                                   The proof proceeds by establishing that the machine state transformation
                                induced by executing the instructions
                                                                      tco
                                                          ⟪t : A ⊢ B⟫   ; dropFrame
                                                                      oﬀ
                                and the instructions
                                                                             tco
                                                                 ⟪t : A ⊢ B⟫
                                                                             on
                                are identical.
                                   WewouldlikeanimprovedstaticanalysisofthememoryuseofthisTCOex-
                                                                                    tco
                                ecution. Figure 5 deﬁnes the static analysis cellBnd  (t : A ⊢ B) which bounds
                                the memory use of the TCO execution. The static analysis becomes somewhat
                                more intricate with the more complex translation. But we may proceed with
                                conﬁdencebecausewehaveaformalveriﬁcationinCoqofthefollowingtheorem.
                                Theorem C.2 (Static Analysis of Cell Usage with TCO) Let t : A ⊢ B
                                be any Simplicity expression. Let v : A be any value of type A. Initialize a Bit
                                Machine as speciﬁed in Theorem C.1. The maximum number of cells in both
                                                                                                              tco
                                stacks of the Bit Machine at any point during the execution of ⟪t : A ⊢ B⟫
                                                                            tco                               oﬀ
                                from this initial state never exceeds cellBnd (t : A ⊢ B).
                                   The proof proceeds by establishing that the additional memory used
                                               tco                 tco
                                by ⟪t : A ⊢ B⟫     and ⟪t : A ⊢ B⟫     in any machine state is no more than
                                               oﬀ                  on                                      tco
                                max(n ,n )andmax(n −m,n )respectivelywherehn ,n i = extraCellBnd             (t :
                                      1   2            1      2                       1  2
                                                                       29
                              A⊢B)andmisthenumber of cells in the active read frame before executing
                                         tco
                              ⟪t : A ⊢ B⟫  .
                                         on
                                 There is a possibility for a head composition optimization where the
                              newFrame(n) instruction is delayed in order to potentially save memory.
                              It is unclear to us if this is worth the added complexity, so we have not pursued
                              this yet.
                              Acknowledgements
                              Thank you to Shannon Appelcline for his help editing this paper.
                                                                   30
                                                           tco              :
                                              extraCellBnd   (iden : A ⊢ A) = h0,0i
                                                       tco                  :
                                          extraCellBnd   (compst : A ⊢ C) = let hn ,n i =
                                                                                     1   2
                                                                                            tco
                                                                                extraCellBnd   (s : A ⊢ B) in
                                                                               let hm ,m i =
                                                                                      1   2
                                                                                            tco
                                                                                extraCellBnd   (t : B ⊢ C) in
                                                                               let b = bitSize(B) in
                                                                               hmax(b+n ,m ,b+m ),b+n i
                                                                                          1    1       2       2
                                                            tco             :
                                               extraCellBnd   (unit : A ⊢ 1) = h0,0i
                                                      tco                   :              tco
                                         extraCellBnd   (injl t : A ⊢ B + C) = extraCellBnd   (t : A ⊢ B)
                                                      tco                   :              tco
                                         extraCellBnd   (injr t : A ⊢ B + C) = extraCellBnd   (t : A ⊢ C)
                                             tco                            :
                                extraCellBnd   (casest : (A +B)×C ⊢ D) = let hn ,n i =
                                                                                     1   2
                                                                                            tco
                                                                                extraCellBnd   (s : A × C ⊢ D)
                                                                                in
                                                                               let hm ,m i =
                                                                                      1   2
                                                                                            tco
                                                                                extraCellBnd   (t : B × C ⊢ D)
                                                                                in
                                                                               hmax(n ,m ),max(n ,m )i
                                                                                       1   1        2   2
                                                    tco                     :
                                       extraCellBnd   (pairst : A ⊢ B ×C) = let hn ,n i =
                                                                                     1   2
                                                                                            tco
                                                                                extraCellBnd   (s : A ⊢ B) in
                                                                               let hm ,m i =
                                                                                      1   2
                                                                                            tco
                                                                                extraCellBnd   (t : A ⊢ C) in
                                                                               hm ,max(n ,n ,m )i
                                                                                  1        1  2   2
                                                     tco                    :              tco
                                        extraCellBnd   (taket : A × B ⊢ C) = extraCellBnd     (t : A ⊢ C)
                                                    tco                     :              tco
                                        extraCellBnd   (dropt : A ×B ⊢ C) = extraCellBnd      (t : B ⊢ C)
                                              tco           :                             tco
                                       cellBnd  (t : A ⊢ B) = let hn ,n i = extraCellBnd    (t : A ⊢ B) in
                                                                     1  2
                                                                bitSize(A) + bitSize(B) + max(n ,n )
                                                                                                1   2
                                                                                      tco
                                                       Figure 5: Deﬁnition of cellBnd    .
                                                                       31
                              References
                               [1] G. Andresen.     BIP16:    Pay to script hash.       Bitcoin Improve-
                                  mentProposal, 2012. https://github.com/bitcoin/bips/blob/master/
                                  bip-0016.mediawiki.
                               [2] A. W. Appel. Veriﬁcation of a cryptographic primitive: ‘-256. ACM Trans.
                                  Program. Lang. Syst., 37(2):7:1–7:31, April 2015.
                               [3] A. W. Appel. Veriﬁable C. http://vst.cs.princeton.edu/download/
                                  VC.pdf, July 2016.
                               [4] A. Back, M. Corallo, L. Dashjr, M. Friedenbach, G. Maxwell, A. Miller,
                                  A. Poelstra, J. Tim´on, and P. Wuille. Enabling blockchain innovations with
                                  pegged sidechains, 2014.  https://www.blockstream.com/sidechains.
                                  pdf.
                               [5] K. Bhargavan, A. Delignat-Lavaud, C. Fournet, A. Gollamudi, G. Gonthier,
                                  N. Kobeissi, N. Kulatova, A. Rastogi, T. Sibut-Pinote, N. Swamy, and
                                  S. Zanella-B´eguelin. Formal veriﬁcation of smart contracts: Short paper.
                                  In Proceedings of the 2016 ACM Workshop on Programming Languages and
                                  Analysis for Security, PLAS ’16, pages 91–96, New York, NY, USA, 2016.
                                  ACM.
                               [6] bitcoinwiki.  Script.   https://en.bitcoin.it/w/index.php?title=
                                  Script&oldid=61707, 2016.
                               [7] BtcDrak, M. Friedenbach, and E. Lombrozo. BIP112: Checksequencever-
                                  ify. Bitcoin Improvement Proposal, 2015. https://github.com/bitcoin/
                                  bips/blob/master/bip-0112.mediawiki.
                               [8] V.   Buterin.         CRITICAL      UPDATE      Re:       DAO     Vul-
                                  nerability.                  https://blog.ethereum.org/2016/06/17/
                                  critical-update-re-dao-vulnerability/, June 2016.
                               [9] Certicom Research. Standards for Eﬃcient Cryptography 2: Recommended
                                  Elliptic Curve Domain Parameters. Standard SEC2, Certicom Corp., Mis-
                                  sissauga, ON, USA, September 2000.
                              [10] Chain. Announcing ivy playground, May 2017. https://blog.chain.
                                  com/announcing-ivy-playground-395364675d0a.
                              [11] A. Chepurnoy. σ-state authentication language, an alternative to bitcoin
                                  script. Poster Session at the 21st International Conference on Financial
                                  Cryptography and Data Security, April 2017.
                              [12] Ethereum.   Solidity Documentation: Release 0.4.14.   https://media.
                                  readthedocs.org/pdf/solidity/develop/solidity.pdf, June 2017.
                                                                  32
                               [13] G. Gentzen. Investigations into logical deduction. In M.E. Szabo, editor,
                                   The collected papers of Gerhard Gentzen, Studies in logic and the founda-
                                   tions of mathematics, chapter 3. North-Holland Pub. Co., 1969.
                               [14] S. Goldfeder, J. Bonneau, R. Gennaro, and A. Narayanan. Escrow pro-
                                   tocols for cryptocurrencies: How to buy physical goods using bitcoin.
                                   http://fc17.ifca.ai/preproceedings/paper_122.pdf, April 2017. To
                                   appear in the proceedings of the 21st International Conference on Financial
                                   Cryptography and Data Security.
                               [15] Bitcoin Developer Guide. Signature hash types, 2014. https://bitcoin.
                                   org/en/developer-guide#signature-hash-types.
                               [16] D. J. King and P. Wadler. Combining Monads, pages 134–143. Springer
                                   London, London, 1993.
                               [17] J. Lau.  BIP114: Merkelized abstract syntax tree.      Bitcoin Improve-
                                   mentProposal, 2016. https://github.com/bitcoin/bips/blob/master/
                                   bip-0114.mediawiki.
                               [18] X. Leroy. Formal veriﬁcation of a realistic compiler. Communications of
                                   the ACM, 52(7):107–115, 2009.
                               [19] G. Maxwell.   Zero-knowledge contingent payment, 2011.     https://en.
                                   bitcoin.it/wiki/Zero_Knowledge_Contingent_Payment.
                               [20] S. Nakamoto. Bitcoin: A peer-to-peer electronic cash system. http://
                                   bitcoin.org/bitcoin.pdf, November 2008.
                               [21] S. Nakamoto.   misc changes.   https://github.com/bitcoin/bitcoin/
                                   commit/4bd188c4383d6e614e18f79dc337fbabe8464c82,           August 2010.
                                   https://bitcoin.svn.sourceforge.net/svnroot/bitcoin/trunk@131.
                               [22] S. Nakamoto.     Re:   Transactions and Scripts:    DUP HASH160 ...
                                   EQUALVERIFY CHECKSIG. https://bitcointalk.org/index.php?
                                   topic=195.msg1611#msg1611, June 2010.
                               [23] National institute of standards and technology. FIPS pub 186-4 federal
                                   information processing standards publication digital signature standard
                                   (dss). 2013.
                               [24] National institute of standards and technology. FIPS 180-4, secure hash
                                   standard, federal information processing standard (FIPS), publication 180-
                                   4. Technical report, DEPARTMENT OF COMMERCE, August 2015.
                               [25] R. O’Connor. Covenants in elements alpha, 2016. Blog post, https://
                                   blockstream.com/2016/11/02/covenants-in-elements-alpha.html.
                               [26] Parity.  The multi-sig hack:    A postmortem, July 2017.       https://
                                   paritytech.io/blog/the-multi-sig-hack-a-postmortem.html.
                                                                    33
                            [27] M. S. Paterson and M. N. Wegman. Linear uniﬁcation. Journal of Com-
                                 puter and System Sciences, 16(2):158 – 167, 1978.
                            [28] C. P. Schnorr. Eﬃcient identiﬁcation and signatures for smart cards. In
                                 Proceedings of CRYPTO ’89, 1989.
                            [29] The Coq Development Team. The Coq Proof Assistant Reference Manual:
                                 Version 8.6. https://coq.inria.fr/refman/, 2016.
                            [30] P. Todd.    BIP65:   Op checklocktimeverify.   Bitcoin Improvement
                                 Proposal, 2014.    https://github.com/bitcoin/bips/blob/master/
                                 bip-0065.mediawiki.
                            [31] G. Wood. Ethereum: A secure decentralised generalised transaction ledger,
                                 2014. http://gavwood.com/paper.pdf.
                            [32] C. Yarvin, P. Monk, A. Dyudin, and R. Pasco. Urbit: A solid-state inter-
                                 preter, May 2016. http://media.urbit.org/whitepaper.pdf.
                                                               34
